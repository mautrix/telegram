// Code generated by gotdgen, DO NOT EDIT.

package tg

import (
	"context"
	"errors"
	"fmt"
	"sort"
	"strings"

	"go.uber.org/multierr"

	"go.mau.fi/mautrix-telegram/pkg/gotd/bin"
	"go.mau.fi/mautrix-telegram/pkg/gotd/tdjson"
	"go.mau.fi/mautrix-telegram/pkg/gotd/tdp"
	"go.mau.fi/mautrix-telegram/pkg/gotd/tgerr"
)

// No-op definition for keeping imports.
var (
	_ = bin.Buffer{}
	_ = context.Background()
	_ = fmt.Stringer(nil)
	_ = strings.Builder{}
	_ = errors.Is
	_ = multierr.AppendInto
	_ = sort.Ints
	_ = tdp.Format
	_ = tgerr.Error{}
	_ = tdjson.Encoder{}
)

// MessagesForwardMessagesRequest represents TL type `messages.forwardMessages#38f0188c`.
// Forwards messages by their IDs.
//
// See https://core.telegram.org/method/messages.forwardMessages for reference.
type MessagesForwardMessagesRequest struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// Whether to send messages silently (no notification will be triggered on the
	// destination clients)
	Silent bool
	// Whether to send the message in background
	Background bool
	// When forwarding games, whether to include your score in the game
	WithMyScore bool
	// Whether to forward messages without quoting the original author
	DropAuthor bool
	// Whether to strip captions from media
	DropMediaCaptions bool
	// Only for bots, disallows further re-forwarding and saving of the messages, even if the
	// destination chat doesn't have content protection¹ enabled
	//
	// Links:
	//  1) https://telegram.org/blog/protected-content-delete-by-date-and-more
	Noforwards bool
	// Bots only: if set, allows sending up to 1000 messages per second, ignoring
	// broadcasting limits¹ for a fee of 0.1 Telegram Stars per message. The relevant Stars
	// will be withdrawn from the bot's balance.
	//
	// Links:
	//  1) https://core.telegram.org/bots/faq#how-can-i-message-all-of-my-bot-39s-subscribers-at-once
	AllowPaidFloodskip bool
	// Source of messages
	FromPeer InputPeerClass
	// IDs of messages
	ID []int
	// Random ID to prevent resending of messages
	RandomID []int64
	// Destination peer
	ToPeer InputPeerClass
	// Destination forum topic¹
	//
	// Links:
	//  1) https://core.telegram.org/api/forum#forum-topics
	//
	// Use SetTopMsgID and GetTopMsgID helpers.
	TopMsgID int
	// ReplyTo field of MessagesForwardMessagesRequest.
	//
	// Use SetReplyTo and GetReplyTo helpers.
	ReplyTo InputReplyToClass
	// Scheduled message date for scheduled messages
	//
	// Use SetScheduleDate and GetScheduleDate helpers.
	ScheduleDate int
	// Forward the messages as the specified peer
	//
	// Use SetSendAs and GetSendAs helpers.
	SendAs InputPeerClass
	// Add the messages to the specified quick reply shortcut »¹, instead.
	//
	// Links:
	//  1) https://core.telegram.org/api/business#quick-reply-shortcuts
	//
	// Use SetQuickReplyShortcut and GetQuickReplyShortcut helpers.
	QuickReplyShortcut InputQuickReplyShortcutClass
	// VideoTimestamp field of MessagesForwardMessagesRequest.
	//
	// Use SetVideoTimestamp and GetVideoTimestamp helpers.
	VideoTimestamp int
	// AllowPaidStars field of MessagesForwardMessagesRequest.
	//
	// Use SetAllowPaidStars and GetAllowPaidStars helpers.
	AllowPaidStars int64
}

// MessagesForwardMessagesRequestTypeID is TL type id of MessagesForwardMessagesRequest.
const MessagesForwardMessagesRequestTypeID = 0x38f0188c

// Ensuring interfaces in compile-time for MessagesForwardMessagesRequest.
var (
	_ bin.Encoder     = &MessagesForwardMessagesRequest{}
	_ bin.Decoder     = &MessagesForwardMessagesRequest{}
	_ bin.BareEncoder = &MessagesForwardMessagesRequest{}
	_ bin.BareDecoder = &MessagesForwardMessagesRequest{}
)

func (f *MessagesForwardMessagesRequest) Zero() bool {
	if f == nil {
		return true
	}
	if !(f.Flags.Zero()) {
		return false
	}
	if !(f.Silent == false) {
		return false
	}
	if !(f.Background == false) {
		return false
	}
	if !(f.WithMyScore == false) {
		return false
	}
	if !(f.DropAuthor == false) {
		return false
	}
	if !(f.DropMediaCaptions == false) {
		return false
	}
	if !(f.Noforwards == false) {
		return false
	}
	if !(f.AllowPaidFloodskip == false) {
		return false
	}
	if !(f.FromPeer == nil) {
		return false
	}
	if !(f.ID == nil) {
		return false
	}
	if !(f.RandomID == nil) {
		return false
	}
	if !(f.ToPeer == nil) {
		return false
	}
	if !(f.TopMsgID == 0) {
		return false
	}
	if !(f.ReplyTo == nil) {
		return false
	}
	if !(f.ScheduleDate == 0) {
		return false
	}
	if !(f.SendAs == nil) {
		return false
	}
	if !(f.QuickReplyShortcut == nil) {
		return false
	}
	if !(f.VideoTimestamp == 0) {
		return false
	}
	if !(f.AllowPaidStars == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (f *MessagesForwardMessagesRequest) String() string {
	if f == nil {
		return "MessagesForwardMessagesRequest(nil)"
	}
	type Alias MessagesForwardMessagesRequest
	return fmt.Sprintf("MessagesForwardMessagesRequest%+v", Alias(*f))
}

// FillFrom fills MessagesForwardMessagesRequest from given interface.
func (f *MessagesForwardMessagesRequest) FillFrom(from interface {
	GetSilent() (value bool)
	GetBackground() (value bool)
	GetWithMyScore() (value bool)
	GetDropAuthor() (value bool)
	GetDropMediaCaptions() (value bool)
	GetNoforwards() (value bool)
	GetAllowPaidFloodskip() (value bool)
	GetFromPeer() (value InputPeerClass)
	GetID() (value []int)
	GetRandomID() (value []int64)
	GetToPeer() (value InputPeerClass)
	GetTopMsgID() (value int, ok bool)
	GetReplyTo() (value InputReplyToClass, ok bool)
	GetScheduleDate() (value int, ok bool)
	GetSendAs() (value InputPeerClass, ok bool)
	GetQuickReplyShortcut() (value InputQuickReplyShortcutClass, ok bool)
	GetVideoTimestamp() (value int, ok bool)
	GetAllowPaidStars() (value int64, ok bool)
}) {
	f.Silent = from.GetSilent()
	f.Background = from.GetBackground()
	f.WithMyScore = from.GetWithMyScore()
	f.DropAuthor = from.GetDropAuthor()
	f.DropMediaCaptions = from.GetDropMediaCaptions()
	f.Noforwards = from.GetNoforwards()
	f.AllowPaidFloodskip = from.GetAllowPaidFloodskip()
	f.FromPeer = from.GetFromPeer()
	f.ID = from.GetID()
	f.RandomID = from.GetRandomID()
	f.ToPeer = from.GetToPeer()
	if val, ok := from.GetTopMsgID(); ok {
		f.TopMsgID = val
	}

	if val, ok := from.GetReplyTo(); ok {
		f.ReplyTo = val
	}

	if val, ok := from.GetScheduleDate(); ok {
		f.ScheduleDate = val
	}

	if val, ok := from.GetSendAs(); ok {
		f.SendAs = val
	}

	if val, ok := from.GetQuickReplyShortcut(); ok {
		f.QuickReplyShortcut = val
	}

	if val, ok := from.GetVideoTimestamp(); ok {
		f.VideoTimestamp = val
	}

	if val, ok := from.GetAllowPaidStars(); ok {
		f.AllowPaidStars = val
	}

}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessagesForwardMessagesRequest) TypeID() uint32 {
	return MessagesForwardMessagesRequestTypeID
}

// TypeName returns name of type in TL schema.
func (*MessagesForwardMessagesRequest) TypeName() string {
	return "messages.forwardMessages"
}

// TypeInfo returns info about TL type.
func (f *MessagesForwardMessagesRequest) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messages.forwardMessages",
		ID:   MessagesForwardMessagesRequestTypeID,
	}
	if f == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Silent",
			SchemaName: "silent",
			Null:       !f.Flags.Has(5),
		},
		{
			Name:       "Background",
			SchemaName: "background",
			Null:       !f.Flags.Has(6),
		},
		{
			Name:       "WithMyScore",
			SchemaName: "with_my_score",
			Null:       !f.Flags.Has(8),
		},
		{
			Name:       "DropAuthor",
			SchemaName: "drop_author",
			Null:       !f.Flags.Has(11),
		},
		{
			Name:       "DropMediaCaptions",
			SchemaName: "drop_media_captions",
			Null:       !f.Flags.Has(12),
		},
		{
			Name:       "Noforwards",
			SchemaName: "noforwards",
			Null:       !f.Flags.Has(14),
		},
		{
			Name:       "AllowPaidFloodskip",
			SchemaName: "allow_paid_floodskip",
			Null:       !f.Flags.Has(19),
		},
		{
			Name:       "FromPeer",
			SchemaName: "from_peer",
		},
		{
			Name:       "ID",
			SchemaName: "id",
		},
		{
			Name:       "RandomID",
			SchemaName: "random_id",
		},
		{
			Name:       "ToPeer",
			SchemaName: "to_peer",
		},
		{
			Name:       "TopMsgID",
			SchemaName: "top_msg_id",
			Null:       !f.Flags.Has(9),
		},
		{
			Name:       "ReplyTo",
			SchemaName: "reply_to",
			Null:       !f.Flags.Has(22),
		},
		{
			Name:       "ScheduleDate",
			SchemaName: "schedule_date",
			Null:       !f.Flags.Has(10),
		},
		{
			Name:       "SendAs",
			SchemaName: "send_as",
			Null:       !f.Flags.Has(13),
		},
		{
			Name:       "QuickReplyShortcut",
			SchemaName: "quick_reply_shortcut",
			Null:       !f.Flags.Has(17),
		},
		{
			Name:       "VideoTimestamp",
			SchemaName: "video_timestamp",
			Null:       !f.Flags.Has(20),
		},
		{
			Name:       "AllowPaidStars",
			SchemaName: "allow_paid_stars",
			Null:       !f.Flags.Has(21),
		},
	}
	return typ
}

// SetFlags sets flags for non-zero fields.
func (f *MessagesForwardMessagesRequest) SetFlags() {
	if !(f.Silent == false) {
		f.Flags.Set(5)
	}
	if !(f.Background == false) {
		f.Flags.Set(6)
	}
	if !(f.WithMyScore == false) {
		f.Flags.Set(8)
	}
	if !(f.DropAuthor == false) {
		f.Flags.Set(11)
	}
	if !(f.DropMediaCaptions == false) {
		f.Flags.Set(12)
	}
	if !(f.Noforwards == false) {
		f.Flags.Set(14)
	}
	if !(f.AllowPaidFloodskip == false) {
		f.Flags.Set(19)
	}
	if !(f.TopMsgID == 0) {
		f.Flags.Set(9)
	}
	if !(f.ReplyTo == nil) {
		f.Flags.Set(22)
	}
	if !(f.ScheduleDate == 0) {
		f.Flags.Set(10)
	}
	if !(f.SendAs == nil) {
		f.Flags.Set(13)
	}
	if !(f.QuickReplyShortcut == nil) {
		f.Flags.Set(17)
	}
	if !(f.VideoTimestamp == 0) {
		f.Flags.Set(20)
	}
	if !(f.AllowPaidStars == 0) {
		f.Flags.Set(21)
	}
}

// Encode implements bin.Encoder.
func (f *MessagesForwardMessagesRequest) Encode(b *bin.Buffer) error {
	if f == nil {
		return fmt.Errorf("can't encode messages.forwardMessages#38f0188c as nil")
	}
	b.PutID(MessagesForwardMessagesRequestTypeID)
	return f.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (f *MessagesForwardMessagesRequest) EncodeBare(b *bin.Buffer) error {
	if f == nil {
		return fmt.Errorf("can't encode messages.forwardMessages#38f0188c as nil")
	}
	f.SetFlags()
	if err := f.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messages.forwardMessages#38f0188c: field flags: %w", err)
	}
	if f.FromPeer == nil {
		return fmt.Errorf("unable to encode messages.forwardMessages#38f0188c: field from_peer is nil")
	}
	if err := f.FromPeer.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messages.forwardMessages#38f0188c: field from_peer: %w", err)
	}
	b.PutVectorHeader(len(f.ID))
	for _, v := range f.ID {
		b.PutInt(v)
	}
	b.PutVectorHeader(len(f.RandomID))
	for _, v := range f.RandomID {
		b.PutLong(v)
	}
	if f.ToPeer == nil {
		return fmt.Errorf("unable to encode messages.forwardMessages#38f0188c: field to_peer is nil")
	}
	if err := f.ToPeer.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messages.forwardMessages#38f0188c: field to_peer: %w", err)
	}
	if f.Flags.Has(9) {
		b.PutInt(f.TopMsgID)
	}
	if f.Flags.Has(22) {
		if f.ReplyTo == nil {
			return fmt.Errorf("unable to encode messages.forwardMessages#38f0188c: field reply_to is nil")
		}
		if err := f.ReplyTo.Encode(b); err != nil {
			return fmt.Errorf("unable to encode messages.forwardMessages#38f0188c: field reply_to: %w", err)
		}
	}
	if f.Flags.Has(10) {
		b.PutInt(f.ScheduleDate)
	}
	if f.Flags.Has(13) {
		if f.SendAs == nil {
			return fmt.Errorf("unable to encode messages.forwardMessages#38f0188c: field send_as is nil")
		}
		if err := f.SendAs.Encode(b); err != nil {
			return fmt.Errorf("unable to encode messages.forwardMessages#38f0188c: field send_as: %w", err)
		}
	}
	if f.Flags.Has(17) {
		if f.QuickReplyShortcut == nil {
			return fmt.Errorf("unable to encode messages.forwardMessages#38f0188c: field quick_reply_shortcut is nil")
		}
		if err := f.QuickReplyShortcut.Encode(b); err != nil {
			return fmt.Errorf("unable to encode messages.forwardMessages#38f0188c: field quick_reply_shortcut: %w", err)
		}
	}
	if f.Flags.Has(20) {
		b.PutInt(f.VideoTimestamp)
	}
	if f.Flags.Has(21) {
		b.PutLong(f.AllowPaidStars)
	}
	return nil
}

// Decode implements bin.Decoder.
func (f *MessagesForwardMessagesRequest) Decode(b *bin.Buffer) error {
	if f == nil {
		return fmt.Errorf("can't decode messages.forwardMessages#38f0188c to nil")
	}
	if err := b.ConsumeID(MessagesForwardMessagesRequestTypeID); err != nil {
		return fmt.Errorf("unable to decode messages.forwardMessages#38f0188c: %w", err)
	}
	return f.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (f *MessagesForwardMessagesRequest) DecodeBare(b *bin.Buffer) error {
	if f == nil {
		return fmt.Errorf("can't decode messages.forwardMessages#38f0188c to nil")
	}
	{
		if err := f.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messages.forwardMessages#38f0188c: field flags: %w", err)
		}
	}
	f.Silent = f.Flags.Has(5)
	f.Background = f.Flags.Has(6)
	f.WithMyScore = f.Flags.Has(8)
	f.DropAuthor = f.Flags.Has(11)
	f.DropMediaCaptions = f.Flags.Has(12)
	f.Noforwards = f.Flags.Has(14)
	f.AllowPaidFloodskip = f.Flags.Has(19)
	{
		value, err := DecodeInputPeer(b)
		if err != nil {
			return fmt.Errorf("unable to decode messages.forwardMessages#38f0188c: field from_peer: %w", err)
		}
		f.FromPeer = value
	}
	{
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode messages.forwardMessages#38f0188c: field id: %w", err)
		}

		if headerLen > 0 {
			f.ID = make([]int, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := b.Int()
			if err != nil {
				return fmt.Errorf("unable to decode messages.forwardMessages#38f0188c: field id: %w", err)
			}
			f.ID = append(f.ID, value)
		}
	}
	{
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode messages.forwardMessages#38f0188c: field random_id: %w", err)
		}

		if headerLen > 0 {
			f.RandomID = make([]int64, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := b.Long()
			if err != nil {
				return fmt.Errorf("unable to decode messages.forwardMessages#38f0188c: field random_id: %w", err)
			}
			f.RandomID = append(f.RandomID, value)
		}
	}
	{
		value, err := DecodeInputPeer(b)
		if err != nil {
			return fmt.Errorf("unable to decode messages.forwardMessages#38f0188c: field to_peer: %w", err)
		}
		f.ToPeer = value
	}
	if f.Flags.Has(9) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode messages.forwardMessages#38f0188c: field top_msg_id: %w", err)
		}
		f.TopMsgID = value
	}
	if f.Flags.Has(22) {
		value, err := DecodeInputReplyTo(b)
		if err != nil {
			return fmt.Errorf("unable to decode messages.forwardMessages#38f0188c: field reply_to: %w", err)
		}
		f.ReplyTo = value
	}
	if f.Flags.Has(10) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode messages.forwardMessages#38f0188c: field schedule_date: %w", err)
		}
		f.ScheduleDate = value
	}
	if f.Flags.Has(13) {
		value, err := DecodeInputPeer(b)
		if err != nil {
			return fmt.Errorf("unable to decode messages.forwardMessages#38f0188c: field send_as: %w", err)
		}
		f.SendAs = value
	}
	if f.Flags.Has(17) {
		value, err := DecodeInputQuickReplyShortcut(b)
		if err != nil {
			return fmt.Errorf("unable to decode messages.forwardMessages#38f0188c: field quick_reply_shortcut: %w", err)
		}
		f.QuickReplyShortcut = value
	}
	if f.Flags.Has(20) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode messages.forwardMessages#38f0188c: field video_timestamp: %w", err)
		}
		f.VideoTimestamp = value
	}
	if f.Flags.Has(21) {
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode messages.forwardMessages#38f0188c: field allow_paid_stars: %w", err)
		}
		f.AllowPaidStars = value
	}
	return nil
}

// SetSilent sets value of Silent conditional field.
func (f *MessagesForwardMessagesRequest) SetSilent(value bool) {
	if value {
		f.Flags.Set(5)
		f.Silent = true
	} else {
		f.Flags.Unset(5)
		f.Silent = false
	}
}

// GetSilent returns value of Silent conditional field.
func (f *MessagesForwardMessagesRequest) GetSilent() (value bool) {
	if f == nil {
		return
	}
	return f.Flags.Has(5)
}

// SetBackground sets value of Background conditional field.
func (f *MessagesForwardMessagesRequest) SetBackground(value bool) {
	if value {
		f.Flags.Set(6)
		f.Background = true
	} else {
		f.Flags.Unset(6)
		f.Background = false
	}
}

// GetBackground returns value of Background conditional field.
func (f *MessagesForwardMessagesRequest) GetBackground() (value bool) {
	if f == nil {
		return
	}
	return f.Flags.Has(6)
}

// SetWithMyScore sets value of WithMyScore conditional field.
func (f *MessagesForwardMessagesRequest) SetWithMyScore(value bool) {
	if value {
		f.Flags.Set(8)
		f.WithMyScore = true
	} else {
		f.Flags.Unset(8)
		f.WithMyScore = false
	}
}

// GetWithMyScore returns value of WithMyScore conditional field.
func (f *MessagesForwardMessagesRequest) GetWithMyScore() (value bool) {
	if f == nil {
		return
	}
	return f.Flags.Has(8)
}

// SetDropAuthor sets value of DropAuthor conditional field.
func (f *MessagesForwardMessagesRequest) SetDropAuthor(value bool) {
	if value {
		f.Flags.Set(11)
		f.DropAuthor = true
	} else {
		f.Flags.Unset(11)
		f.DropAuthor = false
	}
}

// GetDropAuthor returns value of DropAuthor conditional field.
func (f *MessagesForwardMessagesRequest) GetDropAuthor() (value bool) {
	if f == nil {
		return
	}
	return f.Flags.Has(11)
}

// SetDropMediaCaptions sets value of DropMediaCaptions conditional field.
func (f *MessagesForwardMessagesRequest) SetDropMediaCaptions(value bool) {
	if value {
		f.Flags.Set(12)
		f.DropMediaCaptions = true
	} else {
		f.Flags.Unset(12)
		f.DropMediaCaptions = false
	}
}

// GetDropMediaCaptions returns value of DropMediaCaptions conditional field.
func (f *MessagesForwardMessagesRequest) GetDropMediaCaptions() (value bool) {
	if f == nil {
		return
	}
	return f.Flags.Has(12)
}

// SetNoforwards sets value of Noforwards conditional field.
func (f *MessagesForwardMessagesRequest) SetNoforwards(value bool) {
	if value {
		f.Flags.Set(14)
		f.Noforwards = true
	} else {
		f.Flags.Unset(14)
		f.Noforwards = false
	}
}

// GetNoforwards returns value of Noforwards conditional field.
func (f *MessagesForwardMessagesRequest) GetNoforwards() (value bool) {
	if f == nil {
		return
	}
	return f.Flags.Has(14)
}

// SetAllowPaidFloodskip sets value of AllowPaidFloodskip conditional field.
func (f *MessagesForwardMessagesRequest) SetAllowPaidFloodskip(value bool) {
	if value {
		f.Flags.Set(19)
		f.AllowPaidFloodskip = true
	} else {
		f.Flags.Unset(19)
		f.AllowPaidFloodskip = false
	}
}

// GetAllowPaidFloodskip returns value of AllowPaidFloodskip conditional field.
func (f *MessagesForwardMessagesRequest) GetAllowPaidFloodskip() (value bool) {
	if f == nil {
		return
	}
	return f.Flags.Has(19)
}

// GetFromPeer returns value of FromPeer field.
func (f *MessagesForwardMessagesRequest) GetFromPeer() (value InputPeerClass) {
	if f == nil {
		return
	}
	return f.FromPeer
}

// GetID returns value of ID field.
func (f *MessagesForwardMessagesRequest) GetID() (value []int) {
	if f == nil {
		return
	}
	return f.ID
}

// GetRandomID returns value of RandomID field.
func (f *MessagesForwardMessagesRequest) GetRandomID() (value []int64) {
	if f == nil {
		return
	}
	return f.RandomID
}

// GetToPeer returns value of ToPeer field.
func (f *MessagesForwardMessagesRequest) GetToPeer() (value InputPeerClass) {
	if f == nil {
		return
	}
	return f.ToPeer
}

// SetTopMsgID sets value of TopMsgID conditional field.
func (f *MessagesForwardMessagesRequest) SetTopMsgID(value int) {
	f.Flags.Set(9)
	f.TopMsgID = value
}

// GetTopMsgID returns value of TopMsgID conditional field and
// boolean which is true if field was set.
func (f *MessagesForwardMessagesRequest) GetTopMsgID() (value int, ok bool) {
	if f == nil {
		return
	}
	if !f.Flags.Has(9) {
		return value, false
	}
	return f.TopMsgID, true
}

// SetReplyTo sets value of ReplyTo conditional field.
func (f *MessagesForwardMessagesRequest) SetReplyTo(value InputReplyToClass) {
	f.Flags.Set(22)
	f.ReplyTo = value
}

// GetReplyTo returns value of ReplyTo conditional field and
// boolean which is true if field was set.
func (f *MessagesForwardMessagesRequest) GetReplyTo() (value InputReplyToClass, ok bool) {
	if f == nil {
		return
	}
	if !f.Flags.Has(22) {
		return value, false
	}
	return f.ReplyTo, true
}

// SetScheduleDate sets value of ScheduleDate conditional field.
func (f *MessagesForwardMessagesRequest) SetScheduleDate(value int) {
	f.Flags.Set(10)
	f.ScheduleDate = value
}

// GetScheduleDate returns value of ScheduleDate conditional field and
// boolean which is true if field was set.
func (f *MessagesForwardMessagesRequest) GetScheduleDate() (value int, ok bool) {
	if f == nil {
		return
	}
	if !f.Flags.Has(10) {
		return value, false
	}
	return f.ScheduleDate, true
}

// SetSendAs sets value of SendAs conditional field.
func (f *MessagesForwardMessagesRequest) SetSendAs(value InputPeerClass) {
	f.Flags.Set(13)
	f.SendAs = value
}

// GetSendAs returns value of SendAs conditional field and
// boolean which is true if field was set.
func (f *MessagesForwardMessagesRequest) GetSendAs() (value InputPeerClass, ok bool) {
	if f == nil {
		return
	}
	if !f.Flags.Has(13) {
		return value, false
	}
	return f.SendAs, true
}

// SetQuickReplyShortcut sets value of QuickReplyShortcut conditional field.
func (f *MessagesForwardMessagesRequest) SetQuickReplyShortcut(value InputQuickReplyShortcutClass) {
	f.Flags.Set(17)
	f.QuickReplyShortcut = value
}

// GetQuickReplyShortcut returns value of QuickReplyShortcut conditional field and
// boolean which is true if field was set.
func (f *MessagesForwardMessagesRequest) GetQuickReplyShortcut() (value InputQuickReplyShortcutClass, ok bool) {
	if f == nil {
		return
	}
	if !f.Flags.Has(17) {
		return value, false
	}
	return f.QuickReplyShortcut, true
}

// SetVideoTimestamp sets value of VideoTimestamp conditional field.
func (f *MessagesForwardMessagesRequest) SetVideoTimestamp(value int) {
	f.Flags.Set(20)
	f.VideoTimestamp = value
}

// GetVideoTimestamp returns value of VideoTimestamp conditional field and
// boolean which is true if field was set.
func (f *MessagesForwardMessagesRequest) GetVideoTimestamp() (value int, ok bool) {
	if f == nil {
		return
	}
	if !f.Flags.Has(20) {
		return value, false
	}
	return f.VideoTimestamp, true
}

// SetAllowPaidStars sets value of AllowPaidStars conditional field.
func (f *MessagesForwardMessagesRequest) SetAllowPaidStars(value int64) {
	f.Flags.Set(21)
	f.AllowPaidStars = value
}

// GetAllowPaidStars returns value of AllowPaidStars conditional field and
// boolean which is true if field was set.
func (f *MessagesForwardMessagesRequest) GetAllowPaidStars() (value int64, ok bool) {
	if f == nil {
		return
	}
	if !f.Flags.Has(21) {
		return value, false
	}
	return f.AllowPaidStars, true
}

// MessagesForwardMessages invokes method messages.forwardMessages#38f0188c returning error if any.
// Forwards messages by their IDs.
//
// Possible errors:
//
//	400 BROADCAST_PUBLIC_VOTERS_FORBIDDEN: You can't forward polls with public voters.
//	400 CHANNEL_INVALID: The provided channel is invalid.
//	406 CHANNEL_PRIVATE: You haven't joined this channel/supergroup.
//	403 CHAT_ADMIN_REQUIRED: You must be an admin in this chat to do this.
//	406 CHAT_FORWARDS_RESTRICTED: You can't forward messages from a protected chat.
//	403 CHAT_GUEST_SEND_FORBIDDEN: You join the discussion group before commenting, see here » for more info.
//	400 CHAT_ID_INVALID: The provided chat id is invalid.
//	400 CHAT_RESTRICTED: You can't send messages in this chat, you were restricted.
//	403 CHAT_SEND_AUDIOS_FORBIDDEN: You can't send audio messages in this chat.
//	403 CHAT_SEND_DOCS_FORBIDDEN: You can't send documents in this chat.
//	403 CHAT_SEND_GAME_FORBIDDEN: You can't send a game to this chat.
//	403 CHAT_SEND_GIFS_FORBIDDEN: You can't send gifs in this chat.
//	403 CHAT_SEND_MEDIA_FORBIDDEN: You can't send media in this chat.
//	403 CHAT_SEND_PHOTOS_FORBIDDEN: You can't send photos in this chat.
//	403 CHAT_SEND_PLAIN_FORBIDDEN: You can't send non-media (text) messages in this chat.
//	403 CHAT_SEND_POLL_FORBIDDEN: You can't send polls in this chat.
//	403 CHAT_SEND_STICKERS_FORBIDDEN: You can't send stickers in this chat.
//	403 CHAT_SEND_VIDEOS_FORBIDDEN: You can't send videos in this chat.
//	403 CHAT_SEND_VOICES_FORBIDDEN: You can't send voice recordings in this chat.
//	403 CHAT_WRITE_FORBIDDEN: You can't write in this chat.
//	400 GROUPED_MEDIA_INVALID: Invalid grouped media.
//	400 INPUT_USER_DEACTIVATED: The specified user was deleted.
//	400 MEDIA_EMPTY: The provided media object is invalid.
//	400 MESSAGE_IDS_EMPTY: No message ids were provided.
//	400 MESSAGE_ID_INVALID: The provided message id is invalid.
//	400 MSG_ID_INVALID: Invalid message ID provided.
//	406 PAYMENT_UNSUPPORTED: A detailed description of the error will be received separately as described here ».
//	400 PEER_ID_INVALID: The provided peer id is invalid.
//	403 PREMIUM_ACCOUNT_REQUIRED: A premium account is required to execute this action.
//	406 PRIVACY_PREMIUM_REQUIRED: You need a Telegram Premium subscription to send a message to this user.
//	400 QUICK_REPLIES_TOO_MUCH: A maximum of appConfig.quick_replies_limit shortcuts may be created, the limit was reached.
//	400 QUIZ_ANSWER_MISSING: You can forward a quiz while hiding the original author only after choosing an option in the quiz.
//	500 RANDOM_ID_DUPLICATE: You provided a random ID that was already used.
//	400 RANDOM_ID_INVALID: A provided random ID is invalid.
//	400 REPLY_MESSAGES_TOO_MUCH: Each shortcut can contain a maximum of appConfig.quick_reply_messages_limit messages, the limit was reached.
//	400 SCHEDULE_BOT_NOT_ALLOWED: Bots cannot schedule messages.
//	400 SCHEDULE_DATE_TOO_LATE: You can't schedule a message this far in the future.
//	400 SCHEDULE_TOO_MUCH: There are too many scheduled messages.
//	400 SEND_AS_PEER_INVALID: You can't send messages as the specified peer.
//	400 SLOWMODE_MULTI_MSGS_DISABLED: Slowmode is enabled, you cannot forward multiple messages to this group.
//	420 SLOWMODE_WAIT_%d: Slowmode is enabled in this chat: wait %d seconds before sending another message to this chat.
//	406 TOPIC_CLOSED: This topic was closed, you can't send messages to it anymore.
//	406 TOPIC_DELETED: The specified topic was deleted.
//	400 USER_BANNED_IN_CHANNEL: You're banned from sending messages in supergroups/channels.
//	403 USER_IS_BLOCKED: You were blocked by this user.
//	400 USER_IS_BOT: Bots can't send messages to other bots.
//	403 VOICE_MESSAGES_FORBIDDEN: This user's privacy settings forbid you from sending voice messages.
//	400 YOU_BLOCKED_USER: You blocked this user.
//
// See https://core.telegram.org/method/messages.forwardMessages for reference.
// Can be used by bots.
func (c *Client) MessagesForwardMessages(ctx context.Context, request *MessagesForwardMessagesRequest) (UpdatesClass, error) {
	var result UpdatesBox

	if err := c.rpc.Invoke(ctx, request, &result); err != nil {
		return nil, err
	}
	return result.Updates, nil
}
