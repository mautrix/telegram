// Code generated by gotdgen, DO NOT EDIT.

package tg

import (
	"context"
	"errors"
	"fmt"
	"sort"
	"strings"

	"go.uber.org/multierr"

	"go.mau.fi/mautrix-telegram/pkg/gotd/bin"
	"go.mau.fi/mautrix-telegram/pkg/gotd/tdjson"
	"go.mau.fi/mautrix-telegram/pkg/gotd/tdp"
	"go.mau.fi/mautrix-telegram/pkg/gotd/tgerr"
)

// No-op definition for keeping imports.
var (
	_ = bin.Buffer{}
	_ = context.Background()
	_ = fmt.Stringer(nil)
	_ = strings.Builder{}
	_ = errors.Is
	_ = multierr.AppendInto
	_ = sort.Ints
	_ = tdp.Format
	_ = tgerr.Error{}
	_ = tdjson.Encoder{}
)

// InputBotInlineMessageMediaAuto represents TL type `inputBotInlineMessageMediaAuto#3380c786`.
// A media
//
// See https://core.telegram.org/constructor/inputBotInlineMessageMediaAuto for reference.
type InputBotInlineMessageMediaAuto struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// If set, any eventual webpage preview will be shown on top of the message instead of at
	// the bottom.
	InvertMedia bool
	// Caption
	Message string
	// Message entities for styled text¹
	//
	// Links:
	//  1) https://core.telegram.org/api/entities
	//
	// Use SetEntities and GetEntities helpers.
	Entities []MessageEntityClass
	// Inline keyboard
	//
	// Use SetReplyMarkup and GetReplyMarkup helpers.
	ReplyMarkup ReplyMarkupClass
}

// InputBotInlineMessageMediaAutoTypeID is TL type id of InputBotInlineMessageMediaAuto.
const InputBotInlineMessageMediaAutoTypeID = 0x3380c786

// construct implements constructor of InputBotInlineMessageClass.
func (i InputBotInlineMessageMediaAuto) construct() InputBotInlineMessageClass { return &i }

// Ensuring interfaces in compile-time for InputBotInlineMessageMediaAuto.
var (
	_ bin.Encoder     = &InputBotInlineMessageMediaAuto{}
	_ bin.Decoder     = &InputBotInlineMessageMediaAuto{}
	_ bin.BareEncoder = &InputBotInlineMessageMediaAuto{}
	_ bin.BareDecoder = &InputBotInlineMessageMediaAuto{}

	_ InputBotInlineMessageClass = &InputBotInlineMessageMediaAuto{}
)

func (i *InputBotInlineMessageMediaAuto) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.Flags.Zero()) {
		return false
	}
	if !(i.InvertMedia == false) {
		return false
	}
	if !(i.Message == "") {
		return false
	}
	if !(i.Entities == nil) {
		return false
	}
	if !(i.ReplyMarkup == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputBotInlineMessageMediaAuto) String() string {
	if i == nil {
		return "InputBotInlineMessageMediaAuto(nil)"
	}
	type Alias InputBotInlineMessageMediaAuto
	return fmt.Sprintf("InputBotInlineMessageMediaAuto%+v", Alias(*i))
}

// FillFrom fills InputBotInlineMessageMediaAuto from given interface.
func (i *InputBotInlineMessageMediaAuto) FillFrom(from interface {
	GetInvertMedia() (value bool)
	GetMessage() (value string)
	GetEntities() (value []MessageEntityClass, ok bool)
	GetReplyMarkup() (value ReplyMarkupClass, ok bool)
}) {
	i.InvertMedia = from.GetInvertMedia()
	i.Message = from.GetMessage()
	if val, ok := from.GetEntities(); ok {
		i.Entities = val
	}

	if val, ok := from.GetReplyMarkup(); ok {
		i.ReplyMarkup = val
	}

}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputBotInlineMessageMediaAuto) TypeID() uint32 {
	return InputBotInlineMessageMediaAutoTypeID
}

// TypeName returns name of type in TL schema.
func (*InputBotInlineMessageMediaAuto) TypeName() string {
	return "inputBotInlineMessageMediaAuto"
}

// TypeInfo returns info about TL type.
func (i *InputBotInlineMessageMediaAuto) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputBotInlineMessageMediaAuto",
		ID:   InputBotInlineMessageMediaAutoTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "InvertMedia",
			SchemaName: "invert_media",
			Null:       !i.Flags.Has(3),
		},
		{
			Name:       "Message",
			SchemaName: "message",
		},
		{
			Name:       "Entities",
			SchemaName: "entities",
			Null:       !i.Flags.Has(1),
		},
		{
			Name:       "ReplyMarkup",
			SchemaName: "reply_markup",
			Null:       !i.Flags.Has(2),
		},
	}
	return typ
}

// SetFlags sets flags for non-zero fields.
func (i *InputBotInlineMessageMediaAuto) SetFlags() {
	if !(i.InvertMedia == false) {
		i.Flags.Set(3)
	}
	if !(i.Entities == nil) {
		i.Flags.Set(1)
	}
	if !(i.ReplyMarkup == nil) {
		i.Flags.Set(2)
	}
}

// Encode implements bin.Encoder.
func (i *InputBotInlineMessageMediaAuto) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputBotInlineMessageMediaAuto#3380c786 as nil")
	}
	b.PutID(InputBotInlineMessageMediaAutoTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputBotInlineMessageMediaAuto) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputBotInlineMessageMediaAuto#3380c786 as nil")
	}
	i.SetFlags()
	if err := i.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputBotInlineMessageMediaAuto#3380c786: field flags: %w", err)
	}
	b.PutString(i.Message)
	if i.Flags.Has(1) {
		b.PutVectorHeader(len(i.Entities))
		for idx, v := range i.Entities {
			if v == nil {
				return fmt.Errorf("unable to encode inputBotInlineMessageMediaAuto#3380c786: field entities element with index %d is nil", idx)
			}
			if err := v.Encode(b); err != nil {
				return fmt.Errorf("unable to encode inputBotInlineMessageMediaAuto#3380c786: field entities element with index %d: %w", idx, err)
			}
		}
	}
	if i.Flags.Has(2) {
		if i.ReplyMarkup == nil {
			return fmt.Errorf("unable to encode inputBotInlineMessageMediaAuto#3380c786: field reply_markup is nil")
		}
		if err := i.ReplyMarkup.Encode(b); err != nil {
			return fmt.Errorf("unable to encode inputBotInlineMessageMediaAuto#3380c786: field reply_markup: %w", err)
		}
	}
	return nil
}

// Decode implements bin.Decoder.
func (i *InputBotInlineMessageMediaAuto) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputBotInlineMessageMediaAuto#3380c786 to nil")
	}
	if err := b.ConsumeID(InputBotInlineMessageMediaAutoTypeID); err != nil {
		return fmt.Errorf("unable to decode inputBotInlineMessageMediaAuto#3380c786: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputBotInlineMessageMediaAuto) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputBotInlineMessageMediaAuto#3380c786 to nil")
	}
	{
		if err := i.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputBotInlineMessageMediaAuto#3380c786: field flags: %w", err)
		}
	}
	i.InvertMedia = i.Flags.Has(3)
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputBotInlineMessageMediaAuto#3380c786: field message: %w", err)
		}
		i.Message = value
	}
	if i.Flags.Has(1) {
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode inputBotInlineMessageMediaAuto#3380c786: field entities: %w", err)
		}

		if headerLen > 0 {
			i.Entities = make([]MessageEntityClass, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := DecodeMessageEntity(b)
			if err != nil {
				return fmt.Errorf("unable to decode inputBotInlineMessageMediaAuto#3380c786: field entities: %w", err)
			}
			i.Entities = append(i.Entities, value)
		}
	}
	if i.Flags.Has(2) {
		value, err := DecodeReplyMarkup(b)
		if err != nil {
			return fmt.Errorf("unable to decode inputBotInlineMessageMediaAuto#3380c786: field reply_markup: %w", err)
		}
		i.ReplyMarkup = value
	}
	return nil
}

// SetInvertMedia sets value of InvertMedia conditional field.
func (i *InputBotInlineMessageMediaAuto) SetInvertMedia(value bool) {
	if value {
		i.Flags.Set(3)
		i.InvertMedia = true
	} else {
		i.Flags.Unset(3)
		i.InvertMedia = false
	}
}

// GetInvertMedia returns value of InvertMedia conditional field.
func (i *InputBotInlineMessageMediaAuto) GetInvertMedia() (value bool) {
	if i == nil {
		return
	}
	return i.Flags.Has(3)
}

// GetMessage returns value of Message field.
func (i *InputBotInlineMessageMediaAuto) GetMessage() (value string) {
	if i == nil {
		return
	}
	return i.Message
}

// SetEntities sets value of Entities conditional field.
func (i *InputBotInlineMessageMediaAuto) SetEntities(value []MessageEntityClass) {
	i.Flags.Set(1)
	i.Entities = value
}

// GetEntities returns value of Entities conditional field and
// boolean which is true if field was set.
func (i *InputBotInlineMessageMediaAuto) GetEntities() (value []MessageEntityClass, ok bool) {
	if i == nil {
		return
	}
	if !i.Flags.Has(1) {
		return value, false
	}
	return i.Entities, true
}

// SetReplyMarkup sets value of ReplyMarkup conditional field.
func (i *InputBotInlineMessageMediaAuto) SetReplyMarkup(value ReplyMarkupClass) {
	i.Flags.Set(2)
	i.ReplyMarkup = value
}

// GetReplyMarkup returns value of ReplyMarkup conditional field and
// boolean which is true if field was set.
func (i *InputBotInlineMessageMediaAuto) GetReplyMarkup() (value ReplyMarkupClass, ok bool) {
	if i == nil {
		return
	}
	if !i.Flags.Has(2) {
		return value, false
	}
	return i.ReplyMarkup, true
}

// MapEntities returns field Entities wrapped in MessageEntityClassArray helper.
func (i *InputBotInlineMessageMediaAuto) MapEntities() (value MessageEntityClassArray, ok bool) {
	if !i.Flags.Has(1) {
		return value, false
	}
	return MessageEntityClassArray(i.Entities), true
}

// InputBotInlineMessageText represents TL type `inputBotInlineMessageText#3dcd7a87`.
// Simple text message
//
// See https://core.telegram.org/constructor/inputBotInlineMessageText for reference.
type InputBotInlineMessageText struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// Disable webpage preview
	NoWebpage bool
	// If set, any eventual webpage preview will be shown on top of the message instead of at
	// the bottom.
	InvertMedia bool
	// Message
	Message string
	// Message entities for styled text¹
	//
	// Links:
	//  1) https://core.telegram.org/api/entities
	//
	// Use SetEntities and GetEntities helpers.
	Entities []MessageEntityClass
	// Inline keyboard
	//
	// Use SetReplyMarkup and GetReplyMarkup helpers.
	ReplyMarkup ReplyMarkupClass
}

// InputBotInlineMessageTextTypeID is TL type id of InputBotInlineMessageText.
const InputBotInlineMessageTextTypeID = 0x3dcd7a87

// construct implements constructor of InputBotInlineMessageClass.
func (i InputBotInlineMessageText) construct() InputBotInlineMessageClass { return &i }

// Ensuring interfaces in compile-time for InputBotInlineMessageText.
var (
	_ bin.Encoder     = &InputBotInlineMessageText{}
	_ bin.Decoder     = &InputBotInlineMessageText{}
	_ bin.BareEncoder = &InputBotInlineMessageText{}
	_ bin.BareDecoder = &InputBotInlineMessageText{}

	_ InputBotInlineMessageClass = &InputBotInlineMessageText{}
)

func (i *InputBotInlineMessageText) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.Flags.Zero()) {
		return false
	}
	if !(i.NoWebpage == false) {
		return false
	}
	if !(i.InvertMedia == false) {
		return false
	}
	if !(i.Message == "") {
		return false
	}
	if !(i.Entities == nil) {
		return false
	}
	if !(i.ReplyMarkup == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputBotInlineMessageText) String() string {
	if i == nil {
		return "InputBotInlineMessageText(nil)"
	}
	type Alias InputBotInlineMessageText
	return fmt.Sprintf("InputBotInlineMessageText%+v", Alias(*i))
}

// FillFrom fills InputBotInlineMessageText from given interface.
func (i *InputBotInlineMessageText) FillFrom(from interface {
	GetNoWebpage() (value bool)
	GetInvertMedia() (value bool)
	GetMessage() (value string)
	GetEntities() (value []MessageEntityClass, ok bool)
	GetReplyMarkup() (value ReplyMarkupClass, ok bool)
}) {
	i.NoWebpage = from.GetNoWebpage()
	i.InvertMedia = from.GetInvertMedia()
	i.Message = from.GetMessage()
	if val, ok := from.GetEntities(); ok {
		i.Entities = val
	}

	if val, ok := from.GetReplyMarkup(); ok {
		i.ReplyMarkup = val
	}

}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputBotInlineMessageText) TypeID() uint32 {
	return InputBotInlineMessageTextTypeID
}

// TypeName returns name of type in TL schema.
func (*InputBotInlineMessageText) TypeName() string {
	return "inputBotInlineMessageText"
}

// TypeInfo returns info about TL type.
func (i *InputBotInlineMessageText) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputBotInlineMessageText",
		ID:   InputBotInlineMessageTextTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "NoWebpage",
			SchemaName: "no_webpage",
			Null:       !i.Flags.Has(0),
		},
		{
			Name:       "InvertMedia",
			SchemaName: "invert_media",
			Null:       !i.Flags.Has(3),
		},
		{
			Name:       "Message",
			SchemaName: "message",
		},
		{
			Name:       "Entities",
			SchemaName: "entities",
			Null:       !i.Flags.Has(1),
		},
		{
			Name:       "ReplyMarkup",
			SchemaName: "reply_markup",
			Null:       !i.Flags.Has(2),
		},
	}
	return typ
}

// SetFlags sets flags for non-zero fields.
func (i *InputBotInlineMessageText) SetFlags() {
	if !(i.NoWebpage == false) {
		i.Flags.Set(0)
	}
	if !(i.InvertMedia == false) {
		i.Flags.Set(3)
	}
	if !(i.Entities == nil) {
		i.Flags.Set(1)
	}
	if !(i.ReplyMarkup == nil) {
		i.Flags.Set(2)
	}
}

// Encode implements bin.Encoder.
func (i *InputBotInlineMessageText) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputBotInlineMessageText#3dcd7a87 as nil")
	}
	b.PutID(InputBotInlineMessageTextTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputBotInlineMessageText) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputBotInlineMessageText#3dcd7a87 as nil")
	}
	i.SetFlags()
	if err := i.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputBotInlineMessageText#3dcd7a87: field flags: %w", err)
	}
	b.PutString(i.Message)
	if i.Flags.Has(1) {
		b.PutVectorHeader(len(i.Entities))
		for idx, v := range i.Entities {
			if v == nil {
				return fmt.Errorf("unable to encode inputBotInlineMessageText#3dcd7a87: field entities element with index %d is nil", idx)
			}
			if err := v.Encode(b); err != nil {
				return fmt.Errorf("unable to encode inputBotInlineMessageText#3dcd7a87: field entities element with index %d: %w", idx, err)
			}
		}
	}
	if i.Flags.Has(2) {
		if i.ReplyMarkup == nil {
			return fmt.Errorf("unable to encode inputBotInlineMessageText#3dcd7a87: field reply_markup is nil")
		}
		if err := i.ReplyMarkup.Encode(b); err != nil {
			return fmt.Errorf("unable to encode inputBotInlineMessageText#3dcd7a87: field reply_markup: %w", err)
		}
	}
	return nil
}

// Decode implements bin.Decoder.
func (i *InputBotInlineMessageText) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputBotInlineMessageText#3dcd7a87 to nil")
	}
	if err := b.ConsumeID(InputBotInlineMessageTextTypeID); err != nil {
		return fmt.Errorf("unable to decode inputBotInlineMessageText#3dcd7a87: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputBotInlineMessageText) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputBotInlineMessageText#3dcd7a87 to nil")
	}
	{
		if err := i.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputBotInlineMessageText#3dcd7a87: field flags: %w", err)
		}
	}
	i.NoWebpage = i.Flags.Has(0)
	i.InvertMedia = i.Flags.Has(3)
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputBotInlineMessageText#3dcd7a87: field message: %w", err)
		}
		i.Message = value
	}
	if i.Flags.Has(1) {
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode inputBotInlineMessageText#3dcd7a87: field entities: %w", err)
		}

		if headerLen > 0 {
			i.Entities = make([]MessageEntityClass, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := DecodeMessageEntity(b)
			if err != nil {
				return fmt.Errorf("unable to decode inputBotInlineMessageText#3dcd7a87: field entities: %w", err)
			}
			i.Entities = append(i.Entities, value)
		}
	}
	if i.Flags.Has(2) {
		value, err := DecodeReplyMarkup(b)
		if err != nil {
			return fmt.Errorf("unable to decode inputBotInlineMessageText#3dcd7a87: field reply_markup: %w", err)
		}
		i.ReplyMarkup = value
	}
	return nil
}

// SetNoWebpage sets value of NoWebpage conditional field.
func (i *InputBotInlineMessageText) SetNoWebpage(value bool) {
	if value {
		i.Flags.Set(0)
		i.NoWebpage = true
	} else {
		i.Flags.Unset(0)
		i.NoWebpage = false
	}
}

// GetNoWebpage returns value of NoWebpage conditional field.
func (i *InputBotInlineMessageText) GetNoWebpage() (value bool) {
	if i == nil {
		return
	}
	return i.Flags.Has(0)
}

// SetInvertMedia sets value of InvertMedia conditional field.
func (i *InputBotInlineMessageText) SetInvertMedia(value bool) {
	if value {
		i.Flags.Set(3)
		i.InvertMedia = true
	} else {
		i.Flags.Unset(3)
		i.InvertMedia = false
	}
}

// GetInvertMedia returns value of InvertMedia conditional field.
func (i *InputBotInlineMessageText) GetInvertMedia() (value bool) {
	if i == nil {
		return
	}
	return i.Flags.Has(3)
}

// GetMessage returns value of Message field.
func (i *InputBotInlineMessageText) GetMessage() (value string) {
	if i == nil {
		return
	}
	return i.Message
}

// SetEntities sets value of Entities conditional field.
func (i *InputBotInlineMessageText) SetEntities(value []MessageEntityClass) {
	i.Flags.Set(1)
	i.Entities = value
}

// GetEntities returns value of Entities conditional field and
// boolean which is true if field was set.
func (i *InputBotInlineMessageText) GetEntities() (value []MessageEntityClass, ok bool) {
	if i == nil {
		return
	}
	if !i.Flags.Has(1) {
		return value, false
	}
	return i.Entities, true
}

// SetReplyMarkup sets value of ReplyMarkup conditional field.
func (i *InputBotInlineMessageText) SetReplyMarkup(value ReplyMarkupClass) {
	i.Flags.Set(2)
	i.ReplyMarkup = value
}

// GetReplyMarkup returns value of ReplyMarkup conditional field and
// boolean which is true if field was set.
func (i *InputBotInlineMessageText) GetReplyMarkup() (value ReplyMarkupClass, ok bool) {
	if i == nil {
		return
	}
	if !i.Flags.Has(2) {
		return value, false
	}
	return i.ReplyMarkup, true
}

// MapEntities returns field Entities wrapped in MessageEntityClassArray helper.
func (i *InputBotInlineMessageText) MapEntities() (value MessageEntityClassArray, ok bool) {
	if !i.Flags.Has(1) {
		return value, false
	}
	return MessageEntityClassArray(i.Entities), true
}

// InputBotInlineMessageMediaGeo represents TL type `inputBotInlineMessageMediaGeo#96929a85`.
// Geolocation
//
// See https://core.telegram.org/constructor/inputBotInlineMessageMediaGeo for reference.
type InputBotInlineMessageMediaGeo struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// Geolocation
	GeoPoint InputGeoPointClass
	// For live locations¹, a direction in which the location moves, in degrees; 1-360
	//
	// Links:
	//  1) https://core.telegram.org/api/live-location
	//
	// Use SetHeading and GetHeading helpers.
	Heading int
	// Validity period
	//
	// Use SetPeriod and GetPeriod helpers.
	Period int
	// For live locations¹, a maximum distance to another chat member for proximity alerts,
	// in meters (0-100000)
	//
	// Links:
	//  1) https://core.telegram.org/api/live-location
	//
	// Use SetProximityNotificationRadius and GetProximityNotificationRadius helpers.
	ProximityNotificationRadius int
	// Reply markup for bot/inline keyboards
	//
	// Use SetReplyMarkup and GetReplyMarkup helpers.
	ReplyMarkup ReplyMarkupClass
}

// InputBotInlineMessageMediaGeoTypeID is TL type id of InputBotInlineMessageMediaGeo.
const InputBotInlineMessageMediaGeoTypeID = 0x96929a85

// construct implements constructor of InputBotInlineMessageClass.
func (i InputBotInlineMessageMediaGeo) construct() InputBotInlineMessageClass { return &i }

// Ensuring interfaces in compile-time for InputBotInlineMessageMediaGeo.
var (
	_ bin.Encoder     = &InputBotInlineMessageMediaGeo{}
	_ bin.Decoder     = &InputBotInlineMessageMediaGeo{}
	_ bin.BareEncoder = &InputBotInlineMessageMediaGeo{}
	_ bin.BareDecoder = &InputBotInlineMessageMediaGeo{}

	_ InputBotInlineMessageClass = &InputBotInlineMessageMediaGeo{}
)

func (i *InputBotInlineMessageMediaGeo) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.Flags.Zero()) {
		return false
	}
	if !(i.GeoPoint == nil) {
		return false
	}
	if !(i.Heading == 0) {
		return false
	}
	if !(i.Period == 0) {
		return false
	}
	if !(i.ProximityNotificationRadius == 0) {
		return false
	}
	if !(i.ReplyMarkup == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputBotInlineMessageMediaGeo) String() string {
	if i == nil {
		return "InputBotInlineMessageMediaGeo(nil)"
	}
	type Alias InputBotInlineMessageMediaGeo
	return fmt.Sprintf("InputBotInlineMessageMediaGeo%+v", Alias(*i))
}

// FillFrom fills InputBotInlineMessageMediaGeo from given interface.
func (i *InputBotInlineMessageMediaGeo) FillFrom(from interface {
	GetGeoPoint() (value InputGeoPointClass)
	GetHeading() (value int, ok bool)
	GetPeriod() (value int, ok bool)
	GetProximityNotificationRadius() (value int, ok bool)
	GetReplyMarkup() (value ReplyMarkupClass, ok bool)
}) {
	i.GeoPoint = from.GetGeoPoint()
	if val, ok := from.GetHeading(); ok {
		i.Heading = val
	}

	if val, ok := from.GetPeriod(); ok {
		i.Period = val
	}

	if val, ok := from.GetProximityNotificationRadius(); ok {
		i.ProximityNotificationRadius = val
	}

	if val, ok := from.GetReplyMarkup(); ok {
		i.ReplyMarkup = val
	}

}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputBotInlineMessageMediaGeo) TypeID() uint32 {
	return InputBotInlineMessageMediaGeoTypeID
}

// TypeName returns name of type in TL schema.
func (*InputBotInlineMessageMediaGeo) TypeName() string {
	return "inputBotInlineMessageMediaGeo"
}

// TypeInfo returns info about TL type.
func (i *InputBotInlineMessageMediaGeo) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputBotInlineMessageMediaGeo",
		ID:   InputBotInlineMessageMediaGeoTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "GeoPoint",
			SchemaName: "geo_point",
		},
		{
			Name:       "Heading",
			SchemaName: "heading",
			Null:       !i.Flags.Has(0),
		},
		{
			Name:       "Period",
			SchemaName: "period",
			Null:       !i.Flags.Has(1),
		},
		{
			Name:       "ProximityNotificationRadius",
			SchemaName: "proximity_notification_radius",
			Null:       !i.Flags.Has(3),
		},
		{
			Name:       "ReplyMarkup",
			SchemaName: "reply_markup",
			Null:       !i.Flags.Has(2),
		},
	}
	return typ
}

// SetFlags sets flags for non-zero fields.
func (i *InputBotInlineMessageMediaGeo) SetFlags() {
	if !(i.Heading == 0) {
		i.Flags.Set(0)
	}
	if !(i.Period == 0) {
		i.Flags.Set(1)
	}
	if !(i.ProximityNotificationRadius == 0) {
		i.Flags.Set(3)
	}
	if !(i.ReplyMarkup == nil) {
		i.Flags.Set(2)
	}
}

// Encode implements bin.Encoder.
func (i *InputBotInlineMessageMediaGeo) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputBotInlineMessageMediaGeo#96929a85 as nil")
	}
	b.PutID(InputBotInlineMessageMediaGeoTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputBotInlineMessageMediaGeo) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputBotInlineMessageMediaGeo#96929a85 as nil")
	}
	i.SetFlags()
	if err := i.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputBotInlineMessageMediaGeo#96929a85: field flags: %w", err)
	}
	if i.GeoPoint == nil {
		return fmt.Errorf("unable to encode inputBotInlineMessageMediaGeo#96929a85: field geo_point is nil")
	}
	if err := i.GeoPoint.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputBotInlineMessageMediaGeo#96929a85: field geo_point: %w", err)
	}
	if i.Flags.Has(0) {
		b.PutInt(i.Heading)
	}
	if i.Flags.Has(1) {
		b.PutInt(i.Period)
	}
	if i.Flags.Has(3) {
		b.PutInt(i.ProximityNotificationRadius)
	}
	if i.Flags.Has(2) {
		if i.ReplyMarkup == nil {
			return fmt.Errorf("unable to encode inputBotInlineMessageMediaGeo#96929a85: field reply_markup is nil")
		}
		if err := i.ReplyMarkup.Encode(b); err != nil {
			return fmt.Errorf("unable to encode inputBotInlineMessageMediaGeo#96929a85: field reply_markup: %w", err)
		}
	}
	return nil
}

// Decode implements bin.Decoder.
func (i *InputBotInlineMessageMediaGeo) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputBotInlineMessageMediaGeo#96929a85 to nil")
	}
	if err := b.ConsumeID(InputBotInlineMessageMediaGeoTypeID); err != nil {
		return fmt.Errorf("unable to decode inputBotInlineMessageMediaGeo#96929a85: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputBotInlineMessageMediaGeo) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputBotInlineMessageMediaGeo#96929a85 to nil")
	}
	{
		if err := i.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputBotInlineMessageMediaGeo#96929a85: field flags: %w", err)
		}
	}
	{
		value, err := DecodeInputGeoPoint(b)
		if err != nil {
			return fmt.Errorf("unable to decode inputBotInlineMessageMediaGeo#96929a85: field geo_point: %w", err)
		}
		i.GeoPoint = value
	}
	if i.Flags.Has(0) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode inputBotInlineMessageMediaGeo#96929a85: field heading: %w", err)
		}
		i.Heading = value
	}
	if i.Flags.Has(1) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode inputBotInlineMessageMediaGeo#96929a85: field period: %w", err)
		}
		i.Period = value
	}
	if i.Flags.Has(3) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode inputBotInlineMessageMediaGeo#96929a85: field proximity_notification_radius: %w", err)
		}
		i.ProximityNotificationRadius = value
	}
	if i.Flags.Has(2) {
		value, err := DecodeReplyMarkup(b)
		if err != nil {
			return fmt.Errorf("unable to decode inputBotInlineMessageMediaGeo#96929a85: field reply_markup: %w", err)
		}
		i.ReplyMarkup = value
	}
	return nil
}

// GetGeoPoint returns value of GeoPoint field.
func (i *InputBotInlineMessageMediaGeo) GetGeoPoint() (value InputGeoPointClass) {
	if i == nil {
		return
	}
	return i.GeoPoint
}

// SetHeading sets value of Heading conditional field.
func (i *InputBotInlineMessageMediaGeo) SetHeading(value int) {
	i.Flags.Set(0)
	i.Heading = value
}

// GetHeading returns value of Heading conditional field and
// boolean which is true if field was set.
func (i *InputBotInlineMessageMediaGeo) GetHeading() (value int, ok bool) {
	if i == nil {
		return
	}
	if !i.Flags.Has(0) {
		return value, false
	}
	return i.Heading, true
}

// SetPeriod sets value of Period conditional field.
func (i *InputBotInlineMessageMediaGeo) SetPeriod(value int) {
	i.Flags.Set(1)
	i.Period = value
}

// GetPeriod returns value of Period conditional field and
// boolean which is true if field was set.
func (i *InputBotInlineMessageMediaGeo) GetPeriod() (value int, ok bool) {
	if i == nil {
		return
	}
	if !i.Flags.Has(1) {
		return value, false
	}
	return i.Period, true
}

// SetProximityNotificationRadius sets value of ProximityNotificationRadius conditional field.
func (i *InputBotInlineMessageMediaGeo) SetProximityNotificationRadius(value int) {
	i.Flags.Set(3)
	i.ProximityNotificationRadius = value
}

// GetProximityNotificationRadius returns value of ProximityNotificationRadius conditional field and
// boolean which is true if field was set.
func (i *InputBotInlineMessageMediaGeo) GetProximityNotificationRadius() (value int, ok bool) {
	if i == nil {
		return
	}
	if !i.Flags.Has(3) {
		return value, false
	}
	return i.ProximityNotificationRadius, true
}

// SetReplyMarkup sets value of ReplyMarkup conditional field.
func (i *InputBotInlineMessageMediaGeo) SetReplyMarkup(value ReplyMarkupClass) {
	i.Flags.Set(2)
	i.ReplyMarkup = value
}

// GetReplyMarkup returns value of ReplyMarkup conditional field and
// boolean which is true if field was set.
func (i *InputBotInlineMessageMediaGeo) GetReplyMarkup() (value ReplyMarkupClass, ok bool) {
	if i == nil {
		return
	}
	if !i.Flags.Has(2) {
		return value, false
	}
	return i.ReplyMarkup, true
}

// InputBotInlineMessageMediaVenue represents TL type `inputBotInlineMessageMediaVenue#417bbf11`.
// Venue
//
// See https://core.telegram.org/constructor/inputBotInlineMessageMediaVenue for reference.
type InputBotInlineMessageMediaVenue struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// Geolocation
	GeoPoint InputGeoPointClass
	// Venue name
	Title string
	// Address
	Address string
	// Venue provider: currently only "foursquare" and "gplaces" (Google Places) need to be
	// supported
	Provider string
	// Venue ID in the provider's database
	VenueID string
	// Venue type in the provider's database
	VenueType string
	// Inline keyboard
	//
	// Use SetReplyMarkup and GetReplyMarkup helpers.
	ReplyMarkup ReplyMarkupClass
}

// InputBotInlineMessageMediaVenueTypeID is TL type id of InputBotInlineMessageMediaVenue.
const InputBotInlineMessageMediaVenueTypeID = 0x417bbf11

// construct implements constructor of InputBotInlineMessageClass.
func (i InputBotInlineMessageMediaVenue) construct() InputBotInlineMessageClass { return &i }

// Ensuring interfaces in compile-time for InputBotInlineMessageMediaVenue.
var (
	_ bin.Encoder     = &InputBotInlineMessageMediaVenue{}
	_ bin.Decoder     = &InputBotInlineMessageMediaVenue{}
	_ bin.BareEncoder = &InputBotInlineMessageMediaVenue{}
	_ bin.BareDecoder = &InputBotInlineMessageMediaVenue{}

	_ InputBotInlineMessageClass = &InputBotInlineMessageMediaVenue{}
)

func (i *InputBotInlineMessageMediaVenue) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.Flags.Zero()) {
		return false
	}
	if !(i.GeoPoint == nil) {
		return false
	}
	if !(i.Title == "") {
		return false
	}
	if !(i.Address == "") {
		return false
	}
	if !(i.Provider == "") {
		return false
	}
	if !(i.VenueID == "") {
		return false
	}
	if !(i.VenueType == "") {
		return false
	}
	if !(i.ReplyMarkup == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputBotInlineMessageMediaVenue) String() string {
	if i == nil {
		return "InputBotInlineMessageMediaVenue(nil)"
	}
	type Alias InputBotInlineMessageMediaVenue
	return fmt.Sprintf("InputBotInlineMessageMediaVenue%+v", Alias(*i))
}

// FillFrom fills InputBotInlineMessageMediaVenue from given interface.
func (i *InputBotInlineMessageMediaVenue) FillFrom(from interface {
	GetGeoPoint() (value InputGeoPointClass)
	GetTitle() (value string)
	GetAddress() (value string)
	GetProvider() (value string)
	GetVenueID() (value string)
	GetVenueType() (value string)
	GetReplyMarkup() (value ReplyMarkupClass, ok bool)
}) {
	i.GeoPoint = from.GetGeoPoint()
	i.Title = from.GetTitle()
	i.Address = from.GetAddress()
	i.Provider = from.GetProvider()
	i.VenueID = from.GetVenueID()
	i.VenueType = from.GetVenueType()
	if val, ok := from.GetReplyMarkup(); ok {
		i.ReplyMarkup = val
	}

}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputBotInlineMessageMediaVenue) TypeID() uint32 {
	return InputBotInlineMessageMediaVenueTypeID
}

// TypeName returns name of type in TL schema.
func (*InputBotInlineMessageMediaVenue) TypeName() string {
	return "inputBotInlineMessageMediaVenue"
}

// TypeInfo returns info about TL type.
func (i *InputBotInlineMessageMediaVenue) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputBotInlineMessageMediaVenue",
		ID:   InputBotInlineMessageMediaVenueTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "GeoPoint",
			SchemaName: "geo_point",
		},
		{
			Name:       "Title",
			SchemaName: "title",
		},
		{
			Name:       "Address",
			SchemaName: "address",
		},
		{
			Name:       "Provider",
			SchemaName: "provider",
		},
		{
			Name:       "VenueID",
			SchemaName: "venue_id",
		},
		{
			Name:       "VenueType",
			SchemaName: "venue_type",
		},
		{
			Name:       "ReplyMarkup",
			SchemaName: "reply_markup",
			Null:       !i.Flags.Has(2),
		},
	}
	return typ
}

// SetFlags sets flags for non-zero fields.
func (i *InputBotInlineMessageMediaVenue) SetFlags() {
	if !(i.ReplyMarkup == nil) {
		i.Flags.Set(2)
	}
}

// Encode implements bin.Encoder.
func (i *InputBotInlineMessageMediaVenue) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputBotInlineMessageMediaVenue#417bbf11 as nil")
	}
	b.PutID(InputBotInlineMessageMediaVenueTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputBotInlineMessageMediaVenue) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputBotInlineMessageMediaVenue#417bbf11 as nil")
	}
	i.SetFlags()
	if err := i.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputBotInlineMessageMediaVenue#417bbf11: field flags: %w", err)
	}
	if i.GeoPoint == nil {
		return fmt.Errorf("unable to encode inputBotInlineMessageMediaVenue#417bbf11: field geo_point is nil")
	}
	if err := i.GeoPoint.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputBotInlineMessageMediaVenue#417bbf11: field geo_point: %w", err)
	}
	b.PutString(i.Title)
	b.PutString(i.Address)
	b.PutString(i.Provider)
	b.PutString(i.VenueID)
	b.PutString(i.VenueType)
	if i.Flags.Has(2) {
		if i.ReplyMarkup == nil {
			return fmt.Errorf("unable to encode inputBotInlineMessageMediaVenue#417bbf11: field reply_markup is nil")
		}
		if err := i.ReplyMarkup.Encode(b); err != nil {
			return fmt.Errorf("unable to encode inputBotInlineMessageMediaVenue#417bbf11: field reply_markup: %w", err)
		}
	}
	return nil
}

// Decode implements bin.Decoder.
func (i *InputBotInlineMessageMediaVenue) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputBotInlineMessageMediaVenue#417bbf11 to nil")
	}
	if err := b.ConsumeID(InputBotInlineMessageMediaVenueTypeID); err != nil {
		return fmt.Errorf("unable to decode inputBotInlineMessageMediaVenue#417bbf11: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputBotInlineMessageMediaVenue) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputBotInlineMessageMediaVenue#417bbf11 to nil")
	}
	{
		if err := i.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputBotInlineMessageMediaVenue#417bbf11: field flags: %w", err)
		}
	}
	{
		value, err := DecodeInputGeoPoint(b)
		if err != nil {
			return fmt.Errorf("unable to decode inputBotInlineMessageMediaVenue#417bbf11: field geo_point: %w", err)
		}
		i.GeoPoint = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputBotInlineMessageMediaVenue#417bbf11: field title: %w", err)
		}
		i.Title = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputBotInlineMessageMediaVenue#417bbf11: field address: %w", err)
		}
		i.Address = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputBotInlineMessageMediaVenue#417bbf11: field provider: %w", err)
		}
		i.Provider = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputBotInlineMessageMediaVenue#417bbf11: field venue_id: %w", err)
		}
		i.VenueID = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputBotInlineMessageMediaVenue#417bbf11: field venue_type: %w", err)
		}
		i.VenueType = value
	}
	if i.Flags.Has(2) {
		value, err := DecodeReplyMarkup(b)
		if err != nil {
			return fmt.Errorf("unable to decode inputBotInlineMessageMediaVenue#417bbf11: field reply_markup: %w", err)
		}
		i.ReplyMarkup = value
	}
	return nil
}

// GetGeoPoint returns value of GeoPoint field.
func (i *InputBotInlineMessageMediaVenue) GetGeoPoint() (value InputGeoPointClass) {
	if i == nil {
		return
	}
	return i.GeoPoint
}

// GetTitle returns value of Title field.
func (i *InputBotInlineMessageMediaVenue) GetTitle() (value string) {
	if i == nil {
		return
	}
	return i.Title
}

// GetAddress returns value of Address field.
func (i *InputBotInlineMessageMediaVenue) GetAddress() (value string) {
	if i == nil {
		return
	}
	return i.Address
}

// GetProvider returns value of Provider field.
func (i *InputBotInlineMessageMediaVenue) GetProvider() (value string) {
	if i == nil {
		return
	}
	return i.Provider
}

// GetVenueID returns value of VenueID field.
func (i *InputBotInlineMessageMediaVenue) GetVenueID() (value string) {
	if i == nil {
		return
	}
	return i.VenueID
}

// GetVenueType returns value of VenueType field.
func (i *InputBotInlineMessageMediaVenue) GetVenueType() (value string) {
	if i == nil {
		return
	}
	return i.VenueType
}

// SetReplyMarkup sets value of ReplyMarkup conditional field.
func (i *InputBotInlineMessageMediaVenue) SetReplyMarkup(value ReplyMarkupClass) {
	i.Flags.Set(2)
	i.ReplyMarkup = value
}

// GetReplyMarkup returns value of ReplyMarkup conditional field and
// boolean which is true if field was set.
func (i *InputBotInlineMessageMediaVenue) GetReplyMarkup() (value ReplyMarkupClass, ok bool) {
	if i == nil {
		return
	}
	if !i.Flags.Has(2) {
		return value, false
	}
	return i.ReplyMarkup, true
}

// InputBotInlineMessageMediaContact represents TL type `inputBotInlineMessageMediaContact#a6edbffd`.
// A contact
//
// See https://core.telegram.org/constructor/inputBotInlineMessageMediaContact for reference.
type InputBotInlineMessageMediaContact struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// Phone number
	PhoneNumber string
	// First name
	FirstName string
	// Last name
	LastName string
	// VCard info
	Vcard string
	// Inline keyboard
	//
	// Use SetReplyMarkup and GetReplyMarkup helpers.
	ReplyMarkup ReplyMarkupClass
}

// InputBotInlineMessageMediaContactTypeID is TL type id of InputBotInlineMessageMediaContact.
const InputBotInlineMessageMediaContactTypeID = 0xa6edbffd

// construct implements constructor of InputBotInlineMessageClass.
func (i InputBotInlineMessageMediaContact) construct() InputBotInlineMessageClass { return &i }

// Ensuring interfaces in compile-time for InputBotInlineMessageMediaContact.
var (
	_ bin.Encoder     = &InputBotInlineMessageMediaContact{}
	_ bin.Decoder     = &InputBotInlineMessageMediaContact{}
	_ bin.BareEncoder = &InputBotInlineMessageMediaContact{}
	_ bin.BareDecoder = &InputBotInlineMessageMediaContact{}

	_ InputBotInlineMessageClass = &InputBotInlineMessageMediaContact{}
)

func (i *InputBotInlineMessageMediaContact) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.Flags.Zero()) {
		return false
	}
	if !(i.PhoneNumber == "") {
		return false
	}
	if !(i.FirstName == "") {
		return false
	}
	if !(i.LastName == "") {
		return false
	}
	if !(i.Vcard == "") {
		return false
	}
	if !(i.ReplyMarkup == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputBotInlineMessageMediaContact) String() string {
	if i == nil {
		return "InputBotInlineMessageMediaContact(nil)"
	}
	type Alias InputBotInlineMessageMediaContact
	return fmt.Sprintf("InputBotInlineMessageMediaContact%+v", Alias(*i))
}

// FillFrom fills InputBotInlineMessageMediaContact from given interface.
func (i *InputBotInlineMessageMediaContact) FillFrom(from interface {
	GetPhoneNumber() (value string)
	GetFirstName() (value string)
	GetLastName() (value string)
	GetVcard() (value string)
	GetReplyMarkup() (value ReplyMarkupClass, ok bool)
}) {
	i.PhoneNumber = from.GetPhoneNumber()
	i.FirstName = from.GetFirstName()
	i.LastName = from.GetLastName()
	i.Vcard = from.GetVcard()
	if val, ok := from.GetReplyMarkup(); ok {
		i.ReplyMarkup = val
	}

}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputBotInlineMessageMediaContact) TypeID() uint32 {
	return InputBotInlineMessageMediaContactTypeID
}

// TypeName returns name of type in TL schema.
func (*InputBotInlineMessageMediaContact) TypeName() string {
	return "inputBotInlineMessageMediaContact"
}

// TypeInfo returns info about TL type.
func (i *InputBotInlineMessageMediaContact) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputBotInlineMessageMediaContact",
		ID:   InputBotInlineMessageMediaContactTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "PhoneNumber",
			SchemaName: "phone_number",
		},
		{
			Name:       "FirstName",
			SchemaName: "first_name",
		},
		{
			Name:       "LastName",
			SchemaName: "last_name",
		},
		{
			Name:       "Vcard",
			SchemaName: "vcard",
		},
		{
			Name:       "ReplyMarkup",
			SchemaName: "reply_markup",
			Null:       !i.Flags.Has(2),
		},
	}
	return typ
}

// SetFlags sets flags for non-zero fields.
func (i *InputBotInlineMessageMediaContact) SetFlags() {
	if !(i.ReplyMarkup == nil) {
		i.Flags.Set(2)
	}
}

// Encode implements bin.Encoder.
func (i *InputBotInlineMessageMediaContact) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputBotInlineMessageMediaContact#a6edbffd as nil")
	}
	b.PutID(InputBotInlineMessageMediaContactTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputBotInlineMessageMediaContact) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputBotInlineMessageMediaContact#a6edbffd as nil")
	}
	i.SetFlags()
	if err := i.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputBotInlineMessageMediaContact#a6edbffd: field flags: %w", err)
	}
	b.PutString(i.PhoneNumber)
	b.PutString(i.FirstName)
	b.PutString(i.LastName)
	b.PutString(i.Vcard)
	if i.Flags.Has(2) {
		if i.ReplyMarkup == nil {
			return fmt.Errorf("unable to encode inputBotInlineMessageMediaContact#a6edbffd: field reply_markup is nil")
		}
		if err := i.ReplyMarkup.Encode(b); err != nil {
			return fmt.Errorf("unable to encode inputBotInlineMessageMediaContact#a6edbffd: field reply_markup: %w", err)
		}
	}
	return nil
}

// Decode implements bin.Decoder.
func (i *InputBotInlineMessageMediaContact) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputBotInlineMessageMediaContact#a6edbffd to nil")
	}
	if err := b.ConsumeID(InputBotInlineMessageMediaContactTypeID); err != nil {
		return fmt.Errorf("unable to decode inputBotInlineMessageMediaContact#a6edbffd: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputBotInlineMessageMediaContact) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputBotInlineMessageMediaContact#a6edbffd to nil")
	}
	{
		if err := i.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputBotInlineMessageMediaContact#a6edbffd: field flags: %w", err)
		}
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputBotInlineMessageMediaContact#a6edbffd: field phone_number: %w", err)
		}
		i.PhoneNumber = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputBotInlineMessageMediaContact#a6edbffd: field first_name: %w", err)
		}
		i.FirstName = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputBotInlineMessageMediaContact#a6edbffd: field last_name: %w", err)
		}
		i.LastName = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputBotInlineMessageMediaContact#a6edbffd: field vcard: %w", err)
		}
		i.Vcard = value
	}
	if i.Flags.Has(2) {
		value, err := DecodeReplyMarkup(b)
		if err != nil {
			return fmt.Errorf("unable to decode inputBotInlineMessageMediaContact#a6edbffd: field reply_markup: %w", err)
		}
		i.ReplyMarkup = value
	}
	return nil
}

// GetPhoneNumber returns value of PhoneNumber field.
func (i *InputBotInlineMessageMediaContact) GetPhoneNumber() (value string) {
	if i == nil {
		return
	}
	return i.PhoneNumber
}

// GetFirstName returns value of FirstName field.
func (i *InputBotInlineMessageMediaContact) GetFirstName() (value string) {
	if i == nil {
		return
	}
	return i.FirstName
}

// GetLastName returns value of LastName field.
func (i *InputBotInlineMessageMediaContact) GetLastName() (value string) {
	if i == nil {
		return
	}
	return i.LastName
}

// GetVcard returns value of Vcard field.
func (i *InputBotInlineMessageMediaContact) GetVcard() (value string) {
	if i == nil {
		return
	}
	return i.Vcard
}

// SetReplyMarkup sets value of ReplyMarkup conditional field.
func (i *InputBotInlineMessageMediaContact) SetReplyMarkup(value ReplyMarkupClass) {
	i.Flags.Set(2)
	i.ReplyMarkup = value
}

// GetReplyMarkup returns value of ReplyMarkup conditional field and
// boolean which is true if field was set.
func (i *InputBotInlineMessageMediaContact) GetReplyMarkup() (value ReplyMarkupClass, ok bool) {
	if i == nil {
		return
	}
	if !i.Flags.Has(2) {
		return value, false
	}
	return i.ReplyMarkup, true
}

// InputBotInlineMessageGame represents TL type `inputBotInlineMessageGame#4b425864`.
// A game
//
// See https://core.telegram.org/constructor/inputBotInlineMessageGame for reference.
type InputBotInlineMessageGame struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// Inline keyboard
	//
	// Use SetReplyMarkup and GetReplyMarkup helpers.
	ReplyMarkup ReplyMarkupClass
}

// InputBotInlineMessageGameTypeID is TL type id of InputBotInlineMessageGame.
const InputBotInlineMessageGameTypeID = 0x4b425864

// construct implements constructor of InputBotInlineMessageClass.
func (i InputBotInlineMessageGame) construct() InputBotInlineMessageClass { return &i }

// Ensuring interfaces in compile-time for InputBotInlineMessageGame.
var (
	_ bin.Encoder     = &InputBotInlineMessageGame{}
	_ bin.Decoder     = &InputBotInlineMessageGame{}
	_ bin.BareEncoder = &InputBotInlineMessageGame{}
	_ bin.BareDecoder = &InputBotInlineMessageGame{}

	_ InputBotInlineMessageClass = &InputBotInlineMessageGame{}
)

func (i *InputBotInlineMessageGame) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.Flags.Zero()) {
		return false
	}
	if !(i.ReplyMarkup == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputBotInlineMessageGame) String() string {
	if i == nil {
		return "InputBotInlineMessageGame(nil)"
	}
	type Alias InputBotInlineMessageGame
	return fmt.Sprintf("InputBotInlineMessageGame%+v", Alias(*i))
}

// FillFrom fills InputBotInlineMessageGame from given interface.
func (i *InputBotInlineMessageGame) FillFrom(from interface {
	GetReplyMarkup() (value ReplyMarkupClass, ok bool)
}) {
	if val, ok := from.GetReplyMarkup(); ok {
		i.ReplyMarkup = val
	}

}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputBotInlineMessageGame) TypeID() uint32 {
	return InputBotInlineMessageGameTypeID
}

// TypeName returns name of type in TL schema.
func (*InputBotInlineMessageGame) TypeName() string {
	return "inputBotInlineMessageGame"
}

// TypeInfo returns info about TL type.
func (i *InputBotInlineMessageGame) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputBotInlineMessageGame",
		ID:   InputBotInlineMessageGameTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ReplyMarkup",
			SchemaName: "reply_markup",
			Null:       !i.Flags.Has(2),
		},
	}
	return typ
}

// SetFlags sets flags for non-zero fields.
func (i *InputBotInlineMessageGame) SetFlags() {
	if !(i.ReplyMarkup == nil) {
		i.Flags.Set(2)
	}
}

// Encode implements bin.Encoder.
func (i *InputBotInlineMessageGame) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputBotInlineMessageGame#4b425864 as nil")
	}
	b.PutID(InputBotInlineMessageGameTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputBotInlineMessageGame) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputBotInlineMessageGame#4b425864 as nil")
	}
	i.SetFlags()
	if err := i.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputBotInlineMessageGame#4b425864: field flags: %w", err)
	}
	if i.Flags.Has(2) {
		if i.ReplyMarkup == nil {
			return fmt.Errorf("unable to encode inputBotInlineMessageGame#4b425864: field reply_markup is nil")
		}
		if err := i.ReplyMarkup.Encode(b); err != nil {
			return fmt.Errorf("unable to encode inputBotInlineMessageGame#4b425864: field reply_markup: %w", err)
		}
	}
	return nil
}

// Decode implements bin.Decoder.
func (i *InputBotInlineMessageGame) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputBotInlineMessageGame#4b425864 to nil")
	}
	if err := b.ConsumeID(InputBotInlineMessageGameTypeID); err != nil {
		return fmt.Errorf("unable to decode inputBotInlineMessageGame#4b425864: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputBotInlineMessageGame) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputBotInlineMessageGame#4b425864 to nil")
	}
	{
		if err := i.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputBotInlineMessageGame#4b425864: field flags: %w", err)
		}
	}
	if i.Flags.Has(2) {
		value, err := DecodeReplyMarkup(b)
		if err != nil {
			return fmt.Errorf("unable to decode inputBotInlineMessageGame#4b425864: field reply_markup: %w", err)
		}
		i.ReplyMarkup = value
	}
	return nil
}

// SetReplyMarkup sets value of ReplyMarkup conditional field.
func (i *InputBotInlineMessageGame) SetReplyMarkup(value ReplyMarkupClass) {
	i.Flags.Set(2)
	i.ReplyMarkup = value
}

// GetReplyMarkup returns value of ReplyMarkup conditional field and
// boolean which is true if field was set.
func (i *InputBotInlineMessageGame) GetReplyMarkup() (value ReplyMarkupClass, ok bool) {
	if i == nil {
		return
	}
	if !i.Flags.Has(2) {
		return value, false
	}
	return i.ReplyMarkup, true
}

// InputBotInlineMessageMediaInvoice represents TL type `inputBotInlineMessageMediaInvoice#d7e78225`.
// An invoice
//
// See https://core.telegram.org/constructor/inputBotInlineMessageMediaInvoice for reference.
type InputBotInlineMessageMediaInvoice struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// Product name, 1-32 characters
	Title string
	// Product description, 1-255 characters
	Description string
	// Invoice photo
	//
	// Use SetPhoto and GetPhoto helpers.
	Photo InputWebDocument
	// The invoice
	Invoice Invoice
	// Bot-defined invoice payload, 1-128 bytes. This will not be displayed to the user, use
	// for your internal processes.
	Payload []byte
	// Payments provider token, obtained via Botfather¹
	//
	// Links:
	//  1) https://t.me/botfather
	Provider string
	// A JSON-serialized object for data about the invoice, which will be shared with the
	// payment provider. A detailed description of the required fields should be provided by
	// the payment provider.
	ProviderData DataJSON
	// Inline keyboard
	//
	// Use SetReplyMarkup and GetReplyMarkup helpers.
	ReplyMarkup ReplyMarkupClass
}

// InputBotInlineMessageMediaInvoiceTypeID is TL type id of InputBotInlineMessageMediaInvoice.
const InputBotInlineMessageMediaInvoiceTypeID = 0xd7e78225

// construct implements constructor of InputBotInlineMessageClass.
func (i InputBotInlineMessageMediaInvoice) construct() InputBotInlineMessageClass { return &i }

// Ensuring interfaces in compile-time for InputBotInlineMessageMediaInvoice.
var (
	_ bin.Encoder     = &InputBotInlineMessageMediaInvoice{}
	_ bin.Decoder     = &InputBotInlineMessageMediaInvoice{}
	_ bin.BareEncoder = &InputBotInlineMessageMediaInvoice{}
	_ bin.BareDecoder = &InputBotInlineMessageMediaInvoice{}

	_ InputBotInlineMessageClass = &InputBotInlineMessageMediaInvoice{}
)

func (i *InputBotInlineMessageMediaInvoice) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.Flags.Zero()) {
		return false
	}
	if !(i.Title == "") {
		return false
	}
	if !(i.Description == "") {
		return false
	}
	if !(i.Photo.Zero()) {
		return false
	}
	if !(i.Invoice.Zero()) {
		return false
	}
	if !(i.Payload == nil) {
		return false
	}
	if !(i.Provider == "") {
		return false
	}
	if !(i.ProviderData.Zero()) {
		return false
	}
	if !(i.ReplyMarkup == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputBotInlineMessageMediaInvoice) String() string {
	if i == nil {
		return "InputBotInlineMessageMediaInvoice(nil)"
	}
	type Alias InputBotInlineMessageMediaInvoice
	return fmt.Sprintf("InputBotInlineMessageMediaInvoice%+v", Alias(*i))
}

// FillFrom fills InputBotInlineMessageMediaInvoice from given interface.
func (i *InputBotInlineMessageMediaInvoice) FillFrom(from interface {
	GetTitle() (value string)
	GetDescription() (value string)
	GetPhoto() (value InputWebDocument, ok bool)
	GetInvoice() (value Invoice)
	GetPayload() (value []byte)
	GetProvider() (value string)
	GetProviderData() (value DataJSON)
	GetReplyMarkup() (value ReplyMarkupClass, ok bool)
}) {
	i.Title = from.GetTitle()
	i.Description = from.GetDescription()
	if val, ok := from.GetPhoto(); ok {
		i.Photo = val
	}

	i.Invoice = from.GetInvoice()
	i.Payload = from.GetPayload()
	i.Provider = from.GetProvider()
	i.ProviderData = from.GetProviderData()
	if val, ok := from.GetReplyMarkup(); ok {
		i.ReplyMarkup = val
	}

}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputBotInlineMessageMediaInvoice) TypeID() uint32 {
	return InputBotInlineMessageMediaInvoiceTypeID
}

// TypeName returns name of type in TL schema.
func (*InputBotInlineMessageMediaInvoice) TypeName() string {
	return "inputBotInlineMessageMediaInvoice"
}

// TypeInfo returns info about TL type.
func (i *InputBotInlineMessageMediaInvoice) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputBotInlineMessageMediaInvoice",
		ID:   InputBotInlineMessageMediaInvoiceTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Title",
			SchemaName: "title",
		},
		{
			Name:       "Description",
			SchemaName: "description",
		},
		{
			Name:       "Photo",
			SchemaName: "photo",
			Null:       !i.Flags.Has(0),
		},
		{
			Name:       "Invoice",
			SchemaName: "invoice",
		},
		{
			Name:       "Payload",
			SchemaName: "payload",
		},
		{
			Name:       "Provider",
			SchemaName: "provider",
		},
		{
			Name:       "ProviderData",
			SchemaName: "provider_data",
		},
		{
			Name:       "ReplyMarkup",
			SchemaName: "reply_markup",
			Null:       !i.Flags.Has(2),
		},
	}
	return typ
}

// SetFlags sets flags for non-zero fields.
func (i *InputBotInlineMessageMediaInvoice) SetFlags() {
	if !(i.Photo.Zero()) {
		i.Flags.Set(0)
	}
	if !(i.ReplyMarkup == nil) {
		i.Flags.Set(2)
	}
}

// Encode implements bin.Encoder.
func (i *InputBotInlineMessageMediaInvoice) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputBotInlineMessageMediaInvoice#d7e78225 as nil")
	}
	b.PutID(InputBotInlineMessageMediaInvoiceTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputBotInlineMessageMediaInvoice) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputBotInlineMessageMediaInvoice#d7e78225 as nil")
	}
	i.SetFlags()
	if err := i.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputBotInlineMessageMediaInvoice#d7e78225: field flags: %w", err)
	}
	b.PutString(i.Title)
	b.PutString(i.Description)
	if i.Flags.Has(0) {
		if err := i.Photo.Encode(b); err != nil {
			return fmt.Errorf("unable to encode inputBotInlineMessageMediaInvoice#d7e78225: field photo: %w", err)
		}
	}
	if err := i.Invoice.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputBotInlineMessageMediaInvoice#d7e78225: field invoice: %w", err)
	}
	b.PutBytes(i.Payload)
	b.PutString(i.Provider)
	if err := i.ProviderData.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputBotInlineMessageMediaInvoice#d7e78225: field provider_data: %w", err)
	}
	if i.Flags.Has(2) {
		if i.ReplyMarkup == nil {
			return fmt.Errorf("unable to encode inputBotInlineMessageMediaInvoice#d7e78225: field reply_markup is nil")
		}
		if err := i.ReplyMarkup.Encode(b); err != nil {
			return fmt.Errorf("unable to encode inputBotInlineMessageMediaInvoice#d7e78225: field reply_markup: %w", err)
		}
	}
	return nil
}

// Decode implements bin.Decoder.
func (i *InputBotInlineMessageMediaInvoice) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputBotInlineMessageMediaInvoice#d7e78225 to nil")
	}
	if err := b.ConsumeID(InputBotInlineMessageMediaInvoiceTypeID); err != nil {
		return fmt.Errorf("unable to decode inputBotInlineMessageMediaInvoice#d7e78225: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputBotInlineMessageMediaInvoice) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputBotInlineMessageMediaInvoice#d7e78225 to nil")
	}
	{
		if err := i.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputBotInlineMessageMediaInvoice#d7e78225: field flags: %w", err)
		}
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputBotInlineMessageMediaInvoice#d7e78225: field title: %w", err)
		}
		i.Title = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputBotInlineMessageMediaInvoice#d7e78225: field description: %w", err)
		}
		i.Description = value
	}
	if i.Flags.Has(0) {
		if err := i.Photo.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputBotInlineMessageMediaInvoice#d7e78225: field photo: %w", err)
		}
	}
	{
		if err := i.Invoice.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputBotInlineMessageMediaInvoice#d7e78225: field invoice: %w", err)
		}
	}
	{
		value, err := b.Bytes()
		if err != nil {
			return fmt.Errorf("unable to decode inputBotInlineMessageMediaInvoice#d7e78225: field payload: %w", err)
		}
		i.Payload = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputBotInlineMessageMediaInvoice#d7e78225: field provider: %w", err)
		}
		i.Provider = value
	}
	{
		if err := i.ProviderData.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputBotInlineMessageMediaInvoice#d7e78225: field provider_data: %w", err)
		}
	}
	if i.Flags.Has(2) {
		value, err := DecodeReplyMarkup(b)
		if err != nil {
			return fmt.Errorf("unable to decode inputBotInlineMessageMediaInvoice#d7e78225: field reply_markup: %w", err)
		}
		i.ReplyMarkup = value
	}
	return nil
}

// GetTitle returns value of Title field.
func (i *InputBotInlineMessageMediaInvoice) GetTitle() (value string) {
	if i == nil {
		return
	}
	return i.Title
}

// GetDescription returns value of Description field.
func (i *InputBotInlineMessageMediaInvoice) GetDescription() (value string) {
	if i == nil {
		return
	}
	return i.Description
}

// SetPhoto sets value of Photo conditional field.
func (i *InputBotInlineMessageMediaInvoice) SetPhoto(value InputWebDocument) {
	i.Flags.Set(0)
	i.Photo = value
}

// GetPhoto returns value of Photo conditional field and
// boolean which is true if field was set.
func (i *InputBotInlineMessageMediaInvoice) GetPhoto() (value InputWebDocument, ok bool) {
	if i == nil {
		return
	}
	if !i.Flags.Has(0) {
		return value, false
	}
	return i.Photo, true
}

// GetInvoice returns value of Invoice field.
func (i *InputBotInlineMessageMediaInvoice) GetInvoice() (value Invoice) {
	if i == nil {
		return
	}
	return i.Invoice
}

// GetPayload returns value of Payload field.
func (i *InputBotInlineMessageMediaInvoice) GetPayload() (value []byte) {
	if i == nil {
		return
	}
	return i.Payload
}

// GetProvider returns value of Provider field.
func (i *InputBotInlineMessageMediaInvoice) GetProvider() (value string) {
	if i == nil {
		return
	}
	return i.Provider
}

// GetProviderData returns value of ProviderData field.
func (i *InputBotInlineMessageMediaInvoice) GetProviderData() (value DataJSON) {
	if i == nil {
		return
	}
	return i.ProviderData
}

// SetReplyMarkup sets value of ReplyMarkup conditional field.
func (i *InputBotInlineMessageMediaInvoice) SetReplyMarkup(value ReplyMarkupClass) {
	i.Flags.Set(2)
	i.ReplyMarkup = value
}

// GetReplyMarkup returns value of ReplyMarkup conditional field and
// boolean which is true if field was set.
func (i *InputBotInlineMessageMediaInvoice) GetReplyMarkup() (value ReplyMarkupClass, ok bool) {
	if i == nil {
		return
	}
	if !i.Flags.Has(2) {
		return value, false
	}
	return i.ReplyMarkup, true
}

// InputBotInlineMessageMediaWebPage represents TL type `inputBotInlineMessageMediaWebPage#bddcc510`.
// Specifies options that will be used to generate the link preview for the message, or
// even a standalone link preview without an attached message.
//
// See https://core.telegram.org/constructor/inputBotInlineMessageMediaWebPage for reference.
type InputBotInlineMessageMediaWebPage struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// If set, any eventual webpage preview will be shown on top of the message instead of at
	// the bottom.
	InvertMedia bool
	// If set, specifies that a large media preview should be used.
	ForceLargeMedia bool
	// If set, specifies that a small media preview should be used.
	ForceSmallMedia bool
	// If not set, a WEBPAGE_NOT_FOUND RPC error will be emitted if a webpage preview cannot
	// be generated for the specified url; otherwise, no error will be emitted (unless the
	// provided message is also empty, in which case a MESSAGE_EMPTY will be emitted,
	// instead).
	Optional bool
	// The message, can be empty.
	Message string
	// Message entities for styled text¹
	//
	// Links:
	//  1) https://core.telegram.org/api/entities
	//
	// Use SetEntities and GetEntities helpers.
	Entities []MessageEntityClass
	// The URL to use for the link preview.
	URL string
	// Inline keyboard
	//
	// Use SetReplyMarkup and GetReplyMarkup helpers.
	ReplyMarkup ReplyMarkupClass
}

// InputBotInlineMessageMediaWebPageTypeID is TL type id of InputBotInlineMessageMediaWebPage.
const InputBotInlineMessageMediaWebPageTypeID = 0xbddcc510

// construct implements constructor of InputBotInlineMessageClass.
func (i InputBotInlineMessageMediaWebPage) construct() InputBotInlineMessageClass { return &i }

// Ensuring interfaces in compile-time for InputBotInlineMessageMediaWebPage.
var (
	_ bin.Encoder     = &InputBotInlineMessageMediaWebPage{}
	_ bin.Decoder     = &InputBotInlineMessageMediaWebPage{}
	_ bin.BareEncoder = &InputBotInlineMessageMediaWebPage{}
	_ bin.BareDecoder = &InputBotInlineMessageMediaWebPage{}

	_ InputBotInlineMessageClass = &InputBotInlineMessageMediaWebPage{}
)

func (i *InputBotInlineMessageMediaWebPage) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.Flags.Zero()) {
		return false
	}
	if !(i.InvertMedia == false) {
		return false
	}
	if !(i.ForceLargeMedia == false) {
		return false
	}
	if !(i.ForceSmallMedia == false) {
		return false
	}
	if !(i.Optional == false) {
		return false
	}
	if !(i.Message == "") {
		return false
	}
	if !(i.Entities == nil) {
		return false
	}
	if !(i.URL == "") {
		return false
	}
	if !(i.ReplyMarkup == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputBotInlineMessageMediaWebPage) String() string {
	if i == nil {
		return "InputBotInlineMessageMediaWebPage(nil)"
	}
	type Alias InputBotInlineMessageMediaWebPage
	return fmt.Sprintf("InputBotInlineMessageMediaWebPage%+v", Alias(*i))
}

// FillFrom fills InputBotInlineMessageMediaWebPage from given interface.
func (i *InputBotInlineMessageMediaWebPage) FillFrom(from interface {
	GetInvertMedia() (value bool)
	GetForceLargeMedia() (value bool)
	GetForceSmallMedia() (value bool)
	GetOptional() (value bool)
	GetMessage() (value string)
	GetEntities() (value []MessageEntityClass, ok bool)
	GetURL() (value string)
	GetReplyMarkup() (value ReplyMarkupClass, ok bool)
}) {
	i.InvertMedia = from.GetInvertMedia()
	i.ForceLargeMedia = from.GetForceLargeMedia()
	i.ForceSmallMedia = from.GetForceSmallMedia()
	i.Optional = from.GetOptional()
	i.Message = from.GetMessage()
	if val, ok := from.GetEntities(); ok {
		i.Entities = val
	}

	i.URL = from.GetURL()
	if val, ok := from.GetReplyMarkup(); ok {
		i.ReplyMarkup = val
	}

}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputBotInlineMessageMediaWebPage) TypeID() uint32 {
	return InputBotInlineMessageMediaWebPageTypeID
}

// TypeName returns name of type in TL schema.
func (*InputBotInlineMessageMediaWebPage) TypeName() string {
	return "inputBotInlineMessageMediaWebPage"
}

// TypeInfo returns info about TL type.
func (i *InputBotInlineMessageMediaWebPage) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputBotInlineMessageMediaWebPage",
		ID:   InputBotInlineMessageMediaWebPageTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "InvertMedia",
			SchemaName: "invert_media",
			Null:       !i.Flags.Has(3),
		},
		{
			Name:       "ForceLargeMedia",
			SchemaName: "force_large_media",
			Null:       !i.Flags.Has(4),
		},
		{
			Name:       "ForceSmallMedia",
			SchemaName: "force_small_media",
			Null:       !i.Flags.Has(5),
		},
		{
			Name:       "Optional",
			SchemaName: "optional",
			Null:       !i.Flags.Has(6),
		},
		{
			Name:       "Message",
			SchemaName: "message",
		},
		{
			Name:       "Entities",
			SchemaName: "entities",
			Null:       !i.Flags.Has(1),
		},
		{
			Name:       "URL",
			SchemaName: "url",
		},
		{
			Name:       "ReplyMarkup",
			SchemaName: "reply_markup",
			Null:       !i.Flags.Has(2),
		},
	}
	return typ
}

// SetFlags sets flags for non-zero fields.
func (i *InputBotInlineMessageMediaWebPage) SetFlags() {
	if !(i.InvertMedia == false) {
		i.Flags.Set(3)
	}
	if !(i.ForceLargeMedia == false) {
		i.Flags.Set(4)
	}
	if !(i.ForceSmallMedia == false) {
		i.Flags.Set(5)
	}
	if !(i.Optional == false) {
		i.Flags.Set(6)
	}
	if !(i.Entities == nil) {
		i.Flags.Set(1)
	}
	if !(i.ReplyMarkup == nil) {
		i.Flags.Set(2)
	}
}

// Encode implements bin.Encoder.
func (i *InputBotInlineMessageMediaWebPage) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputBotInlineMessageMediaWebPage#bddcc510 as nil")
	}
	b.PutID(InputBotInlineMessageMediaWebPageTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputBotInlineMessageMediaWebPage) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputBotInlineMessageMediaWebPage#bddcc510 as nil")
	}
	i.SetFlags()
	if err := i.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputBotInlineMessageMediaWebPage#bddcc510: field flags: %w", err)
	}
	b.PutString(i.Message)
	if i.Flags.Has(1) {
		b.PutVectorHeader(len(i.Entities))
		for idx, v := range i.Entities {
			if v == nil {
				return fmt.Errorf("unable to encode inputBotInlineMessageMediaWebPage#bddcc510: field entities element with index %d is nil", idx)
			}
			if err := v.Encode(b); err != nil {
				return fmt.Errorf("unable to encode inputBotInlineMessageMediaWebPage#bddcc510: field entities element with index %d: %w", idx, err)
			}
		}
	}
	b.PutString(i.URL)
	if i.Flags.Has(2) {
		if i.ReplyMarkup == nil {
			return fmt.Errorf("unable to encode inputBotInlineMessageMediaWebPage#bddcc510: field reply_markup is nil")
		}
		if err := i.ReplyMarkup.Encode(b); err != nil {
			return fmt.Errorf("unable to encode inputBotInlineMessageMediaWebPage#bddcc510: field reply_markup: %w", err)
		}
	}
	return nil
}

// Decode implements bin.Decoder.
func (i *InputBotInlineMessageMediaWebPage) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputBotInlineMessageMediaWebPage#bddcc510 to nil")
	}
	if err := b.ConsumeID(InputBotInlineMessageMediaWebPageTypeID); err != nil {
		return fmt.Errorf("unable to decode inputBotInlineMessageMediaWebPage#bddcc510: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputBotInlineMessageMediaWebPage) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputBotInlineMessageMediaWebPage#bddcc510 to nil")
	}
	{
		if err := i.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputBotInlineMessageMediaWebPage#bddcc510: field flags: %w", err)
		}
	}
	i.InvertMedia = i.Flags.Has(3)
	i.ForceLargeMedia = i.Flags.Has(4)
	i.ForceSmallMedia = i.Flags.Has(5)
	i.Optional = i.Flags.Has(6)
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputBotInlineMessageMediaWebPage#bddcc510: field message: %w", err)
		}
		i.Message = value
	}
	if i.Flags.Has(1) {
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode inputBotInlineMessageMediaWebPage#bddcc510: field entities: %w", err)
		}

		if headerLen > 0 {
			i.Entities = make([]MessageEntityClass, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := DecodeMessageEntity(b)
			if err != nil {
				return fmt.Errorf("unable to decode inputBotInlineMessageMediaWebPage#bddcc510: field entities: %w", err)
			}
			i.Entities = append(i.Entities, value)
		}
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputBotInlineMessageMediaWebPage#bddcc510: field url: %w", err)
		}
		i.URL = value
	}
	if i.Flags.Has(2) {
		value, err := DecodeReplyMarkup(b)
		if err != nil {
			return fmt.Errorf("unable to decode inputBotInlineMessageMediaWebPage#bddcc510: field reply_markup: %w", err)
		}
		i.ReplyMarkup = value
	}
	return nil
}

// SetInvertMedia sets value of InvertMedia conditional field.
func (i *InputBotInlineMessageMediaWebPage) SetInvertMedia(value bool) {
	if value {
		i.Flags.Set(3)
		i.InvertMedia = true
	} else {
		i.Flags.Unset(3)
		i.InvertMedia = false
	}
}

// GetInvertMedia returns value of InvertMedia conditional field.
func (i *InputBotInlineMessageMediaWebPage) GetInvertMedia() (value bool) {
	if i == nil {
		return
	}
	return i.Flags.Has(3)
}

// SetForceLargeMedia sets value of ForceLargeMedia conditional field.
func (i *InputBotInlineMessageMediaWebPage) SetForceLargeMedia(value bool) {
	if value {
		i.Flags.Set(4)
		i.ForceLargeMedia = true
	} else {
		i.Flags.Unset(4)
		i.ForceLargeMedia = false
	}
}

// GetForceLargeMedia returns value of ForceLargeMedia conditional field.
func (i *InputBotInlineMessageMediaWebPage) GetForceLargeMedia() (value bool) {
	if i == nil {
		return
	}
	return i.Flags.Has(4)
}

// SetForceSmallMedia sets value of ForceSmallMedia conditional field.
func (i *InputBotInlineMessageMediaWebPage) SetForceSmallMedia(value bool) {
	if value {
		i.Flags.Set(5)
		i.ForceSmallMedia = true
	} else {
		i.Flags.Unset(5)
		i.ForceSmallMedia = false
	}
}

// GetForceSmallMedia returns value of ForceSmallMedia conditional field.
func (i *InputBotInlineMessageMediaWebPage) GetForceSmallMedia() (value bool) {
	if i == nil {
		return
	}
	return i.Flags.Has(5)
}

// SetOptional sets value of Optional conditional field.
func (i *InputBotInlineMessageMediaWebPage) SetOptional(value bool) {
	if value {
		i.Flags.Set(6)
		i.Optional = true
	} else {
		i.Flags.Unset(6)
		i.Optional = false
	}
}

// GetOptional returns value of Optional conditional field.
func (i *InputBotInlineMessageMediaWebPage) GetOptional() (value bool) {
	if i == nil {
		return
	}
	return i.Flags.Has(6)
}

// GetMessage returns value of Message field.
func (i *InputBotInlineMessageMediaWebPage) GetMessage() (value string) {
	if i == nil {
		return
	}
	return i.Message
}

// SetEntities sets value of Entities conditional field.
func (i *InputBotInlineMessageMediaWebPage) SetEntities(value []MessageEntityClass) {
	i.Flags.Set(1)
	i.Entities = value
}

// GetEntities returns value of Entities conditional field and
// boolean which is true if field was set.
func (i *InputBotInlineMessageMediaWebPage) GetEntities() (value []MessageEntityClass, ok bool) {
	if i == nil {
		return
	}
	if !i.Flags.Has(1) {
		return value, false
	}
	return i.Entities, true
}

// GetURL returns value of URL field.
func (i *InputBotInlineMessageMediaWebPage) GetURL() (value string) {
	if i == nil {
		return
	}
	return i.URL
}

// SetReplyMarkup sets value of ReplyMarkup conditional field.
func (i *InputBotInlineMessageMediaWebPage) SetReplyMarkup(value ReplyMarkupClass) {
	i.Flags.Set(2)
	i.ReplyMarkup = value
}

// GetReplyMarkup returns value of ReplyMarkup conditional field and
// boolean which is true if field was set.
func (i *InputBotInlineMessageMediaWebPage) GetReplyMarkup() (value ReplyMarkupClass, ok bool) {
	if i == nil {
		return
	}
	if !i.Flags.Has(2) {
		return value, false
	}
	return i.ReplyMarkup, true
}

// MapEntities returns field Entities wrapped in MessageEntityClassArray helper.
func (i *InputBotInlineMessageMediaWebPage) MapEntities() (value MessageEntityClassArray, ok bool) {
	if !i.Flags.Has(1) {
		return value, false
	}
	return MessageEntityClassArray(i.Entities), true
}

// InputBotInlineMessageClassName is schema name of InputBotInlineMessageClass.
const InputBotInlineMessageClassName = "InputBotInlineMessage"

// InputBotInlineMessageClass represents InputBotInlineMessage generic type.
//
// See https://core.telegram.org/type/InputBotInlineMessage for reference.
//
// Example:
//
//	g, err := tg.DecodeInputBotInlineMessage(buf)
//	if err != nil {
//	    panic(err)
//	}
//	switch v := g.(type) {
//	case *tg.InputBotInlineMessageMediaAuto: // inputBotInlineMessageMediaAuto#3380c786
//	case *tg.InputBotInlineMessageText: // inputBotInlineMessageText#3dcd7a87
//	case *tg.InputBotInlineMessageMediaGeo: // inputBotInlineMessageMediaGeo#96929a85
//	case *tg.InputBotInlineMessageMediaVenue: // inputBotInlineMessageMediaVenue#417bbf11
//	case *tg.InputBotInlineMessageMediaContact: // inputBotInlineMessageMediaContact#a6edbffd
//	case *tg.InputBotInlineMessageGame: // inputBotInlineMessageGame#4b425864
//	case *tg.InputBotInlineMessageMediaInvoice: // inputBotInlineMessageMediaInvoice#d7e78225
//	case *tg.InputBotInlineMessageMediaWebPage: // inputBotInlineMessageMediaWebPage#bddcc510
//	default: panic(v)
//	}
type InputBotInlineMessageClass interface {
	bin.Encoder
	bin.Decoder
	bin.BareEncoder
	bin.BareDecoder
	construct() InputBotInlineMessageClass

	// TypeID returns type id in TL schema.
	//
	// See https://core.telegram.org/mtproto/TL-tl#remarks.
	TypeID() uint32
	// TypeName returns name of type in TL schema.
	TypeName() string
	// String implements fmt.Stringer.
	String() string
	// Zero returns true if current object has a zero value.
	Zero() bool

	// Inline keyboard
	GetReplyMarkup() (value ReplyMarkupClass, ok bool)
}

// DecodeInputBotInlineMessage implements binary de-serialization for InputBotInlineMessageClass.
func DecodeInputBotInlineMessage(buf *bin.Buffer) (InputBotInlineMessageClass, error) {
	id, err := buf.PeekID()
	if err != nil {
		return nil, err
	}
	switch id {
	case InputBotInlineMessageMediaAutoTypeID:
		// Decoding inputBotInlineMessageMediaAuto#3380c786.
		v := InputBotInlineMessageMediaAuto{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputBotInlineMessageClass: %w", err)
		}
		return &v, nil
	case InputBotInlineMessageTextTypeID:
		// Decoding inputBotInlineMessageText#3dcd7a87.
		v := InputBotInlineMessageText{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputBotInlineMessageClass: %w", err)
		}
		return &v, nil
	case InputBotInlineMessageMediaGeoTypeID:
		// Decoding inputBotInlineMessageMediaGeo#96929a85.
		v := InputBotInlineMessageMediaGeo{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputBotInlineMessageClass: %w", err)
		}
		return &v, nil
	case InputBotInlineMessageMediaVenueTypeID:
		// Decoding inputBotInlineMessageMediaVenue#417bbf11.
		v := InputBotInlineMessageMediaVenue{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputBotInlineMessageClass: %w", err)
		}
		return &v, nil
	case InputBotInlineMessageMediaContactTypeID:
		// Decoding inputBotInlineMessageMediaContact#a6edbffd.
		v := InputBotInlineMessageMediaContact{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputBotInlineMessageClass: %w", err)
		}
		return &v, nil
	case InputBotInlineMessageGameTypeID:
		// Decoding inputBotInlineMessageGame#4b425864.
		v := InputBotInlineMessageGame{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputBotInlineMessageClass: %w", err)
		}
		return &v, nil
	case InputBotInlineMessageMediaInvoiceTypeID:
		// Decoding inputBotInlineMessageMediaInvoice#d7e78225.
		v := InputBotInlineMessageMediaInvoice{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputBotInlineMessageClass: %w", err)
		}
		return &v, nil
	case InputBotInlineMessageMediaWebPageTypeID:
		// Decoding inputBotInlineMessageMediaWebPage#bddcc510.
		v := InputBotInlineMessageMediaWebPage{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputBotInlineMessageClass: %w", err)
		}
		return &v, nil
	default:
		return nil, fmt.Errorf("unable to decode InputBotInlineMessageClass: %w", bin.NewUnexpectedID(id))
	}
}

// InputBotInlineMessage boxes the InputBotInlineMessageClass providing a helper.
type InputBotInlineMessageBox struct {
	InputBotInlineMessage InputBotInlineMessageClass
}

// Decode implements bin.Decoder for InputBotInlineMessageBox.
func (b *InputBotInlineMessageBox) Decode(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("unable to decode InputBotInlineMessageBox to nil")
	}
	v, err := DecodeInputBotInlineMessage(buf)
	if err != nil {
		return fmt.Errorf("unable to decode boxed value: %w", err)
	}
	b.InputBotInlineMessage = v
	return nil
}

// Encode implements bin.Encode for InputBotInlineMessageBox.
func (b *InputBotInlineMessageBox) Encode(buf *bin.Buffer) error {
	if b == nil || b.InputBotInlineMessage == nil {
		return fmt.Errorf("unable to encode InputBotInlineMessageClass as nil")
	}
	return b.InputBotInlineMessage.Encode(buf)
}
