// Code generated by gotdgen, DO NOT EDIT.

package tg

import (
	"context"
	"errors"
	"fmt"
	"sort"
	"strings"

	"go.uber.org/multierr"

	"go.mau.fi/mautrix-telegram/pkg/gotd/bin"
	"go.mau.fi/mautrix-telegram/pkg/gotd/tdjson"
	"go.mau.fi/mautrix-telegram/pkg/gotd/tdp"
	"go.mau.fi/mautrix-telegram/pkg/gotd/tgerr"
)

// No-op definition for keeping imports.
var (
	_ = bin.Buffer{}
	_ = context.Background()
	_ = fmt.Stringer(nil)
	_ = strings.Builder{}
	_ = errors.Is
	_ = multierr.AppendInto
	_ = sort.Ints
	_ = tdp.Format
	_ = tgerr.Error{}
	_ = tdjson.Encoder{}
)

// TextEmpty represents TL type `textEmpty#dc3d824f`.
// Empty rich text element
//
// See https://core.telegram.org/constructor/textEmpty for reference.
type TextEmpty struct {
}

// TextEmptyTypeID is TL type id of TextEmpty.
const TextEmptyTypeID = 0xdc3d824f

// construct implements constructor of RichTextClass.
func (t TextEmpty) construct() RichTextClass { return &t }

// Ensuring interfaces in compile-time for TextEmpty.
var (
	_ bin.Encoder     = &TextEmpty{}
	_ bin.Decoder     = &TextEmpty{}
	_ bin.BareEncoder = &TextEmpty{}
	_ bin.BareDecoder = &TextEmpty{}

	_ RichTextClass = &TextEmpty{}
)

func (t *TextEmpty) Zero() bool {
	if t == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (t *TextEmpty) String() string {
	if t == nil {
		return "TextEmpty(nil)"
	}
	type Alias TextEmpty
	return fmt.Sprintf("TextEmpty%+v", Alias(*t))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*TextEmpty) TypeID() uint32 {
	return TextEmptyTypeID
}

// TypeName returns name of type in TL schema.
func (*TextEmpty) TypeName() string {
	return "textEmpty"
}

// TypeInfo returns info about TL type.
func (t *TextEmpty) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "textEmpty",
		ID:   TextEmptyTypeID,
	}
	if t == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (t *TextEmpty) Encode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textEmpty#dc3d824f as nil")
	}
	b.PutID(TextEmptyTypeID)
	return t.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (t *TextEmpty) EncodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textEmpty#dc3d824f as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (t *TextEmpty) Decode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textEmpty#dc3d824f to nil")
	}
	if err := b.ConsumeID(TextEmptyTypeID); err != nil {
		return fmt.Errorf("unable to decode textEmpty#dc3d824f: %w", err)
	}
	return t.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (t *TextEmpty) DecodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textEmpty#dc3d824f to nil")
	}
	return nil
}

// TextPlain represents TL type `textPlain#744694e0`.
// Plain text
//
// See https://core.telegram.org/constructor/textPlain for reference.
type TextPlain struct {
	// Text
	Text string
}

// TextPlainTypeID is TL type id of TextPlain.
const TextPlainTypeID = 0x744694e0

// construct implements constructor of RichTextClass.
func (t TextPlain) construct() RichTextClass { return &t }

// Ensuring interfaces in compile-time for TextPlain.
var (
	_ bin.Encoder     = &TextPlain{}
	_ bin.Decoder     = &TextPlain{}
	_ bin.BareEncoder = &TextPlain{}
	_ bin.BareDecoder = &TextPlain{}

	_ RichTextClass = &TextPlain{}
)

func (t *TextPlain) Zero() bool {
	if t == nil {
		return true
	}
	if !(t.Text == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (t *TextPlain) String() string {
	if t == nil {
		return "TextPlain(nil)"
	}
	type Alias TextPlain
	return fmt.Sprintf("TextPlain%+v", Alias(*t))
}

// FillFrom fills TextPlain from given interface.
func (t *TextPlain) FillFrom(from interface {
	GetText() (value string)
}) {
	t.Text = from.GetText()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*TextPlain) TypeID() uint32 {
	return TextPlainTypeID
}

// TypeName returns name of type in TL schema.
func (*TextPlain) TypeName() string {
	return "textPlain"
}

// TypeInfo returns info about TL type.
func (t *TextPlain) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "textPlain",
		ID:   TextPlainTypeID,
	}
	if t == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Text",
			SchemaName: "text",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (t *TextPlain) Encode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textPlain#744694e0 as nil")
	}
	b.PutID(TextPlainTypeID)
	return t.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (t *TextPlain) EncodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textPlain#744694e0 as nil")
	}
	b.PutString(t.Text)
	return nil
}

// Decode implements bin.Decoder.
func (t *TextPlain) Decode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textPlain#744694e0 to nil")
	}
	if err := b.ConsumeID(TextPlainTypeID); err != nil {
		return fmt.Errorf("unable to decode textPlain#744694e0: %w", err)
	}
	return t.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (t *TextPlain) DecodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textPlain#744694e0 to nil")
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode textPlain#744694e0: field text: %w", err)
		}
		t.Text = value
	}
	return nil
}

// GetText returns value of Text field.
func (t *TextPlain) GetText() (value string) {
	if t == nil {
		return
	}
	return t.Text
}

// TextBold represents TL type `textBold#6724abc4`.
// Bold text
//
// See https://core.telegram.org/constructor/textBold for reference.
type TextBold struct {
	// Text
	Text RichTextClass
}

// TextBoldTypeID is TL type id of TextBold.
const TextBoldTypeID = 0x6724abc4

// construct implements constructor of RichTextClass.
func (t TextBold) construct() RichTextClass { return &t }

// Ensuring interfaces in compile-time for TextBold.
var (
	_ bin.Encoder     = &TextBold{}
	_ bin.Decoder     = &TextBold{}
	_ bin.BareEncoder = &TextBold{}
	_ bin.BareDecoder = &TextBold{}

	_ RichTextClass = &TextBold{}
)

func (t *TextBold) Zero() bool {
	if t == nil {
		return true
	}
	if !(t.Text == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (t *TextBold) String() string {
	if t == nil {
		return "TextBold(nil)"
	}
	type Alias TextBold
	return fmt.Sprintf("TextBold%+v", Alias(*t))
}

// FillFrom fills TextBold from given interface.
func (t *TextBold) FillFrom(from interface {
	GetText() (value RichTextClass)
}) {
	t.Text = from.GetText()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*TextBold) TypeID() uint32 {
	return TextBoldTypeID
}

// TypeName returns name of type in TL schema.
func (*TextBold) TypeName() string {
	return "textBold"
}

// TypeInfo returns info about TL type.
func (t *TextBold) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "textBold",
		ID:   TextBoldTypeID,
	}
	if t == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Text",
			SchemaName: "text",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (t *TextBold) Encode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textBold#6724abc4 as nil")
	}
	b.PutID(TextBoldTypeID)
	return t.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (t *TextBold) EncodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textBold#6724abc4 as nil")
	}
	if t.Text == nil {
		return fmt.Errorf("unable to encode textBold#6724abc4: field text is nil")
	}
	if err := t.Text.Encode(b); err != nil {
		return fmt.Errorf("unable to encode textBold#6724abc4: field text: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (t *TextBold) Decode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textBold#6724abc4 to nil")
	}
	if err := b.ConsumeID(TextBoldTypeID); err != nil {
		return fmt.Errorf("unable to decode textBold#6724abc4: %w", err)
	}
	return t.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (t *TextBold) DecodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textBold#6724abc4 to nil")
	}
	{
		value, err := DecodeRichText(b)
		if err != nil {
			return fmt.Errorf("unable to decode textBold#6724abc4: field text: %w", err)
		}
		t.Text = value
	}
	return nil
}

// GetText returns value of Text field.
func (t *TextBold) GetText() (value RichTextClass) {
	if t == nil {
		return
	}
	return t.Text
}

// TextItalic represents TL type `textItalic#d912a59c`.
// Italic text
//
// See https://core.telegram.org/constructor/textItalic for reference.
type TextItalic struct {
	// Text
	Text RichTextClass
}

// TextItalicTypeID is TL type id of TextItalic.
const TextItalicTypeID = 0xd912a59c

// construct implements constructor of RichTextClass.
func (t TextItalic) construct() RichTextClass { return &t }

// Ensuring interfaces in compile-time for TextItalic.
var (
	_ bin.Encoder     = &TextItalic{}
	_ bin.Decoder     = &TextItalic{}
	_ bin.BareEncoder = &TextItalic{}
	_ bin.BareDecoder = &TextItalic{}

	_ RichTextClass = &TextItalic{}
)

func (t *TextItalic) Zero() bool {
	if t == nil {
		return true
	}
	if !(t.Text == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (t *TextItalic) String() string {
	if t == nil {
		return "TextItalic(nil)"
	}
	type Alias TextItalic
	return fmt.Sprintf("TextItalic%+v", Alias(*t))
}

// FillFrom fills TextItalic from given interface.
func (t *TextItalic) FillFrom(from interface {
	GetText() (value RichTextClass)
}) {
	t.Text = from.GetText()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*TextItalic) TypeID() uint32 {
	return TextItalicTypeID
}

// TypeName returns name of type in TL schema.
func (*TextItalic) TypeName() string {
	return "textItalic"
}

// TypeInfo returns info about TL type.
func (t *TextItalic) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "textItalic",
		ID:   TextItalicTypeID,
	}
	if t == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Text",
			SchemaName: "text",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (t *TextItalic) Encode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textItalic#d912a59c as nil")
	}
	b.PutID(TextItalicTypeID)
	return t.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (t *TextItalic) EncodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textItalic#d912a59c as nil")
	}
	if t.Text == nil {
		return fmt.Errorf("unable to encode textItalic#d912a59c: field text is nil")
	}
	if err := t.Text.Encode(b); err != nil {
		return fmt.Errorf("unable to encode textItalic#d912a59c: field text: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (t *TextItalic) Decode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textItalic#d912a59c to nil")
	}
	if err := b.ConsumeID(TextItalicTypeID); err != nil {
		return fmt.Errorf("unable to decode textItalic#d912a59c: %w", err)
	}
	return t.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (t *TextItalic) DecodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textItalic#d912a59c to nil")
	}
	{
		value, err := DecodeRichText(b)
		if err != nil {
			return fmt.Errorf("unable to decode textItalic#d912a59c: field text: %w", err)
		}
		t.Text = value
	}
	return nil
}

// GetText returns value of Text field.
func (t *TextItalic) GetText() (value RichTextClass) {
	if t == nil {
		return
	}
	return t.Text
}

// TextUnderline represents TL type `textUnderline#c12622c4`.
// Underlined text
//
// See https://core.telegram.org/constructor/textUnderline for reference.
type TextUnderline struct {
	// Text
	Text RichTextClass
}

// TextUnderlineTypeID is TL type id of TextUnderline.
const TextUnderlineTypeID = 0xc12622c4

// construct implements constructor of RichTextClass.
func (t TextUnderline) construct() RichTextClass { return &t }

// Ensuring interfaces in compile-time for TextUnderline.
var (
	_ bin.Encoder     = &TextUnderline{}
	_ bin.Decoder     = &TextUnderline{}
	_ bin.BareEncoder = &TextUnderline{}
	_ bin.BareDecoder = &TextUnderline{}

	_ RichTextClass = &TextUnderline{}
)

func (t *TextUnderline) Zero() bool {
	if t == nil {
		return true
	}
	if !(t.Text == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (t *TextUnderline) String() string {
	if t == nil {
		return "TextUnderline(nil)"
	}
	type Alias TextUnderline
	return fmt.Sprintf("TextUnderline%+v", Alias(*t))
}

// FillFrom fills TextUnderline from given interface.
func (t *TextUnderline) FillFrom(from interface {
	GetText() (value RichTextClass)
}) {
	t.Text = from.GetText()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*TextUnderline) TypeID() uint32 {
	return TextUnderlineTypeID
}

// TypeName returns name of type in TL schema.
func (*TextUnderline) TypeName() string {
	return "textUnderline"
}

// TypeInfo returns info about TL type.
func (t *TextUnderline) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "textUnderline",
		ID:   TextUnderlineTypeID,
	}
	if t == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Text",
			SchemaName: "text",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (t *TextUnderline) Encode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textUnderline#c12622c4 as nil")
	}
	b.PutID(TextUnderlineTypeID)
	return t.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (t *TextUnderline) EncodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textUnderline#c12622c4 as nil")
	}
	if t.Text == nil {
		return fmt.Errorf("unable to encode textUnderline#c12622c4: field text is nil")
	}
	if err := t.Text.Encode(b); err != nil {
		return fmt.Errorf("unable to encode textUnderline#c12622c4: field text: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (t *TextUnderline) Decode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textUnderline#c12622c4 to nil")
	}
	if err := b.ConsumeID(TextUnderlineTypeID); err != nil {
		return fmt.Errorf("unable to decode textUnderline#c12622c4: %w", err)
	}
	return t.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (t *TextUnderline) DecodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textUnderline#c12622c4 to nil")
	}
	{
		value, err := DecodeRichText(b)
		if err != nil {
			return fmt.Errorf("unable to decode textUnderline#c12622c4: field text: %w", err)
		}
		t.Text = value
	}
	return nil
}

// GetText returns value of Text field.
func (t *TextUnderline) GetText() (value RichTextClass) {
	if t == nil {
		return
	}
	return t.Text
}

// TextStrike represents TL type `textStrike#9bf8bb95`.
// Strikethrough text
//
// See https://core.telegram.org/constructor/textStrike for reference.
type TextStrike struct {
	// Text
	Text RichTextClass
}

// TextStrikeTypeID is TL type id of TextStrike.
const TextStrikeTypeID = 0x9bf8bb95

// construct implements constructor of RichTextClass.
func (t TextStrike) construct() RichTextClass { return &t }

// Ensuring interfaces in compile-time for TextStrike.
var (
	_ bin.Encoder     = &TextStrike{}
	_ bin.Decoder     = &TextStrike{}
	_ bin.BareEncoder = &TextStrike{}
	_ bin.BareDecoder = &TextStrike{}

	_ RichTextClass = &TextStrike{}
)

func (t *TextStrike) Zero() bool {
	if t == nil {
		return true
	}
	if !(t.Text == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (t *TextStrike) String() string {
	if t == nil {
		return "TextStrike(nil)"
	}
	type Alias TextStrike
	return fmt.Sprintf("TextStrike%+v", Alias(*t))
}

// FillFrom fills TextStrike from given interface.
func (t *TextStrike) FillFrom(from interface {
	GetText() (value RichTextClass)
}) {
	t.Text = from.GetText()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*TextStrike) TypeID() uint32 {
	return TextStrikeTypeID
}

// TypeName returns name of type in TL schema.
func (*TextStrike) TypeName() string {
	return "textStrike"
}

// TypeInfo returns info about TL type.
func (t *TextStrike) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "textStrike",
		ID:   TextStrikeTypeID,
	}
	if t == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Text",
			SchemaName: "text",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (t *TextStrike) Encode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textStrike#9bf8bb95 as nil")
	}
	b.PutID(TextStrikeTypeID)
	return t.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (t *TextStrike) EncodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textStrike#9bf8bb95 as nil")
	}
	if t.Text == nil {
		return fmt.Errorf("unable to encode textStrike#9bf8bb95: field text is nil")
	}
	if err := t.Text.Encode(b); err != nil {
		return fmt.Errorf("unable to encode textStrike#9bf8bb95: field text: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (t *TextStrike) Decode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textStrike#9bf8bb95 to nil")
	}
	if err := b.ConsumeID(TextStrikeTypeID); err != nil {
		return fmt.Errorf("unable to decode textStrike#9bf8bb95: %w", err)
	}
	return t.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (t *TextStrike) DecodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textStrike#9bf8bb95 to nil")
	}
	{
		value, err := DecodeRichText(b)
		if err != nil {
			return fmt.Errorf("unable to decode textStrike#9bf8bb95: field text: %w", err)
		}
		t.Text = value
	}
	return nil
}

// GetText returns value of Text field.
func (t *TextStrike) GetText() (value RichTextClass) {
	if t == nil {
		return
	}
	return t.Text
}

// TextFixed represents TL type `textFixed#6c3f19b9`.
// fixed-width rich text
//
// See https://core.telegram.org/constructor/textFixed for reference.
type TextFixed struct {
	// Text
	Text RichTextClass
}

// TextFixedTypeID is TL type id of TextFixed.
const TextFixedTypeID = 0x6c3f19b9

// construct implements constructor of RichTextClass.
func (t TextFixed) construct() RichTextClass { return &t }

// Ensuring interfaces in compile-time for TextFixed.
var (
	_ bin.Encoder     = &TextFixed{}
	_ bin.Decoder     = &TextFixed{}
	_ bin.BareEncoder = &TextFixed{}
	_ bin.BareDecoder = &TextFixed{}

	_ RichTextClass = &TextFixed{}
)

func (t *TextFixed) Zero() bool {
	if t == nil {
		return true
	}
	if !(t.Text == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (t *TextFixed) String() string {
	if t == nil {
		return "TextFixed(nil)"
	}
	type Alias TextFixed
	return fmt.Sprintf("TextFixed%+v", Alias(*t))
}

// FillFrom fills TextFixed from given interface.
func (t *TextFixed) FillFrom(from interface {
	GetText() (value RichTextClass)
}) {
	t.Text = from.GetText()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*TextFixed) TypeID() uint32 {
	return TextFixedTypeID
}

// TypeName returns name of type in TL schema.
func (*TextFixed) TypeName() string {
	return "textFixed"
}

// TypeInfo returns info about TL type.
func (t *TextFixed) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "textFixed",
		ID:   TextFixedTypeID,
	}
	if t == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Text",
			SchemaName: "text",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (t *TextFixed) Encode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textFixed#6c3f19b9 as nil")
	}
	b.PutID(TextFixedTypeID)
	return t.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (t *TextFixed) EncodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textFixed#6c3f19b9 as nil")
	}
	if t.Text == nil {
		return fmt.Errorf("unable to encode textFixed#6c3f19b9: field text is nil")
	}
	if err := t.Text.Encode(b); err != nil {
		return fmt.Errorf("unable to encode textFixed#6c3f19b9: field text: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (t *TextFixed) Decode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textFixed#6c3f19b9 to nil")
	}
	if err := b.ConsumeID(TextFixedTypeID); err != nil {
		return fmt.Errorf("unable to decode textFixed#6c3f19b9: %w", err)
	}
	return t.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (t *TextFixed) DecodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textFixed#6c3f19b9 to nil")
	}
	{
		value, err := DecodeRichText(b)
		if err != nil {
			return fmt.Errorf("unable to decode textFixed#6c3f19b9: field text: %w", err)
		}
		t.Text = value
	}
	return nil
}

// GetText returns value of Text field.
func (t *TextFixed) GetText() (value RichTextClass) {
	if t == nil {
		return
	}
	return t.Text
}

// TextURL represents TL type `textUrl#3c2884c1`.
// Link
//
// See https://core.telegram.org/constructor/textUrl for reference.
type TextURL struct {
	// Text of link
	Text RichTextClass
	// Webpage HTTP URL
	URL string
	// If a preview was already generated for the page, the page ID
	WebpageID int64
}

// TextURLTypeID is TL type id of TextURL.
const TextURLTypeID = 0x3c2884c1

// construct implements constructor of RichTextClass.
func (t TextURL) construct() RichTextClass { return &t }

// Ensuring interfaces in compile-time for TextURL.
var (
	_ bin.Encoder     = &TextURL{}
	_ bin.Decoder     = &TextURL{}
	_ bin.BareEncoder = &TextURL{}
	_ bin.BareDecoder = &TextURL{}

	_ RichTextClass = &TextURL{}
)

func (t *TextURL) Zero() bool {
	if t == nil {
		return true
	}
	if !(t.Text == nil) {
		return false
	}
	if !(t.URL == "") {
		return false
	}
	if !(t.WebpageID == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (t *TextURL) String() string {
	if t == nil {
		return "TextURL(nil)"
	}
	type Alias TextURL
	return fmt.Sprintf("TextURL%+v", Alias(*t))
}

// FillFrom fills TextURL from given interface.
func (t *TextURL) FillFrom(from interface {
	GetText() (value RichTextClass)
	GetURL() (value string)
	GetWebpageID() (value int64)
}) {
	t.Text = from.GetText()
	t.URL = from.GetURL()
	t.WebpageID = from.GetWebpageID()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*TextURL) TypeID() uint32 {
	return TextURLTypeID
}

// TypeName returns name of type in TL schema.
func (*TextURL) TypeName() string {
	return "textUrl"
}

// TypeInfo returns info about TL type.
func (t *TextURL) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "textUrl",
		ID:   TextURLTypeID,
	}
	if t == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Text",
			SchemaName: "text",
		},
		{
			Name:       "URL",
			SchemaName: "url",
		},
		{
			Name:       "WebpageID",
			SchemaName: "webpage_id",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (t *TextURL) Encode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textUrl#3c2884c1 as nil")
	}
	b.PutID(TextURLTypeID)
	return t.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (t *TextURL) EncodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textUrl#3c2884c1 as nil")
	}
	if t.Text == nil {
		return fmt.Errorf("unable to encode textUrl#3c2884c1: field text is nil")
	}
	if err := t.Text.Encode(b); err != nil {
		return fmt.Errorf("unable to encode textUrl#3c2884c1: field text: %w", err)
	}
	b.PutString(t.URL)
	b.PutLong(t.WebpageID)
	return nil
}

// Decode implements bin.Decoder.
func (t *TextURL) Decode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textUrl#3c2884c1 to nil")
	}
	if err := b.ConsumeID(TextURLTypeID); err != nil {
		return fmt.Errorf("unable to decode textUrl#3c2884c1: %w", err)
	}
	return t.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (t *TextURL) DecodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textUrl#3c2884c1 to nil")
	}
	{
		value, err := DecodeRichText(b)
		if err != nil {
			return fmt.Errorf("unable to decode textUrl#3c2884c1: field text: %w", err)
		}
		t.Text = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode textUrl#3c2884c1: field url: %w", err)
		}
		t.URL = value
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode textUrl#3c2884c1: field webpage_id: %w", err)
		}
		t.WebpageID = value
	}
	return nil
}

// GetText returns value of Text field.
func (t *TextURL) GetText() (value RichTextClass) {
	if t == nil {
		return
	}
	return t.Text
}

// GetURL returns value of URL field.
func (t *TextURL) GetURL() (value string) {
	if t == nil {
		return
	}
	return t.URL
}

// GetWebpageID returns value of WebpageID field.
func (t *TextURL) GetWebpageID() (value int64) {
	if t == nil {
		return
	}
	return t.WebpageID
}

// TextEmail represents TL type `textEmail#de5a0dd6`.
// Rich text email link
//
// See https://core.telegram.org/constructor/textEmail for reference.
type TextEmail struct {
	// Link text
	Text RichTextClass
	// Email address
	Email string
}

// TextEmailTypeID is TL type id of TextEmail.
const TextEmailTypeID = 0xde5a0dd6

// construct implements constructor of RichTextClass.
func (t TextEmail) construct() RichTextClass { return &t }

// Ensuring interfaces in compile-time for TextEmail.
var (
	_ bin.Encoder     = &TextEmail{}
	_ bin.Decoder     = &TextEmail{}
	_ bin.BareEncoder = &TextEmail{}
	_ bin.BareDecoder = &TextEmail{}

	_ RichTextClass = &TextEmail{}
)

func (t *TextEmail) Zero() bool {
	if t == nil {
		return true
	}
	if !(t.Text == nil) {
		return false
	}
	if !(t.Email == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (t *TextEmail) String() string {
	if t == nil {
		return "TextEmail(nil)"
	}
	type Alias TextEmail
	return fmt.Sprintf("TextEmail%+v", Alias(*t))
}

// FillFrom fills TextEmail from given interface.
func (t *TextEmail) FillFrom(from interface {
	GetText() (value RichTextClass)
	GetEmail() (value string)
}) {
	t.Text = from.GetText()
	t.Email = from.GetEmail()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*TextEmail) TypeID() uint32 {
	return TextEmailTypeID
}

// TypeName returns name of type in TL schema.
func (*TextEmail) TypeName() string {
	return "textEmail"
}

// TypeInfo returns info about TL type.
func (t *TextEmail) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "textEmail",
		ID:   TextEmailTypeID,
	}
	if t == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Text",
			SchemaName: "text",
		},
		{
			Name:       "Email",
			SchemaName: "email",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (t *TextEmail) Encode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textEmail#de5a0dd6 as nil")
	}
	b.PutID(TextEmailTypeID)
	return t.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (t *TextEmail) EncodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textEmail#de5a0dd6 as nil")
	}
	if t.Text == nil {
		return fmt.Errorf("unable to encode textEmail#de5a0dd6: field text is nil")
	}
	if err := t.Text.Encode(b); err != nil {
		return fmt.Errorf("unable to encode textEmail#de5a0dd6: field text: %w", err)
	}
	b.PutString(t.Email)
	return nil
}

// Decode implements bin.Decoder.
func (t *TextEmail) Decode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textEmail#de5a0dd6 to nil")
	}
	if err := b.ConsumeID(TextEmailTypeID); err != nil {
		return fmt.Errorf("unable to decode textEmail#de5a0dd6: %w", err)
	}
	return t.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (t *TextEmail) DecodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textEmail#de5a0dd6 to nil")
	}
	{
		value, err := DecodeRichText(b)
		if err != nil {
			return fmt.Errorf("unable to decode textEmail#de5a0dd6: field text: %w", err)
		}
		t.Text = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode textEmail#de5a0dd6: field email: %w", err)
		}
		t.Email = value
	}
	return nil
}

// GetText returns value of Text field.
func (t *TextEmail) GetText() (value RichTextClass) {
	if t == nil {
		return
	}
	return t.Text
}

// GetEmail returns value of Email field.
func (t *TextEmail) GetEmail() (value string) {
	if t == nil {
		return
	}
	return t.Email
}

// TextConcat represents TL type `textConcat#7e6260d7`.
// Concatenation of rich texts
//
// See https://core.telegram.org/constructor/textConcat for reference.
type TextConcat struct {
	// Concatenated rich texts
	Texts []RichTextClass
}

// TextConcatTypeID is TL type id of TextConcat.
const TextConcatTypeID = 0x7e6260d7

// construct implements constructor of RichTextClass.
func (t TextConcat) construct() RichTextClass { return &t }

// Ensuring interfaces in compile-time for TextConcat.
var (
	_ bin.Encoder     = &TextConcat{}
	_ bin.Decoder     = &TextConcat{}
	_ bin.BareEncoder = &TextConcat{}
	_ bin.BareDecoder = &TextConcat{}

	_ RichTextClass = &TextConcat{}
)

func (t *TextConcat) Zero() bool {
	if t == nil {
		return true
	}
	if !(t.Texts == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (t *TextConcat) String() string {
	if t == nil {
		return "TextConcat(nil)"
	}
	type Alias TextConcat
	return fmt.Sprintf("TextConcat%+v", Alias(*t))
}

// FillFrom fills TextConcat from given interface.
func (t *TextConcat) FillFrom(from interface {
	GetTexts() (value []RichTextClass)
}) {
	t.Texts = from.GetTexts()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*TextConcat) TypeID() uint32 {
	return TextConcatTypeID
}

// TypeName returns name of type in TL schema.
func (*TextConcat) TypeName() string {
	return "textConcat"
}

// TypeInfo returns info about TL type.
func (t *TextConcat) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "textConcat",
		ID:   TextConcatTypeID,
	}
	if t == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Texts",
			SchemaName: "texts",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (t *TextConcat) Encode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textConcat#7e6260d7 as nil")
	}
	b.PutID(TextConcatTypeID)
	return t.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (t *TextConcat) EncodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textConcat#7e6260d7 as nil")
	}
	b.PutVectorHeader(len(t.Texts))
	for idx, v := range t.Texts {
		if v == nil {
			return fmt.Errorf("unable to encode textConcat#7e6260d7: field texts element with index %d is nil", idx)
		}
		if err := v.Encode(b); err != nil {
			return fmt.Errorf("unable to encode textConcat#7e6260d7: field texts element with index %d: %w", idx, err)
		}
	}
	return nil
}

// Decode implements bin.Decoder.
func (t *TextConcat) Decode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textConcat#7e6260d7 to nil")
	}
	if err := b.ConsumeID(TextConcatTypeID); err != nil {
		return fmt.Errorf("unable to decode textConcat#7e6260d7: %w", err)
	}
	return t.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (t *TextConcat) DecodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textConcat#7e6260d7 to nil")
	}
	{
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode textConcat#7e6260d7: field texts: %w", err)
		}

		if headerLen > 0 {
			t.Texts = make([]RichTextClass, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := DecodeRichText(b)
			if err != nil {
				return fmt.Errorf("unable to decode textConcat#7e6260d7: field texts: %w", err)
			}
			t.Texts = append(t.Texts, value)
		}
	}
	return nil
}

// GetTexts returns value of Texts field.
func (t *TextConcat) GetTexts() (value []RichTextClass) {
	if t == nil {
		return
	}
	return t.Texts
}

// MapTexts returns field Texts wrapped in RichTextClassArray helper.
func (t *TextConcat) MapTexts() (value RichTextClassArray) {
	return RichTextClassArray(t.Texts)
}

// TextSubscript represents TL type `textSubscript#ed6a8504`.
// Subscript text
//
// See https://core.telegram.org/constructor/textSubscript for reference.
type TextSubscript struct {
	// Text
	Text RichTextClass
}

// TextSubscriptTypeID is TL type id of TextSubscript.
const TextSubscriptTypeID = 0xed6a8504

// construct implements constructor of RichTextClass.
func (t TextSubscript) construct() RichTextClass { return &t }

// Ensuring interfaces in compile-time for TextSubscript.
var (
	_ bin.Encoder     = &TextSubscript{}
	_ bin.Decoder     = &TextSubscript{}
	_ bin.BareEncoder = &TextSubscript{}
	_ bin.BareDecoder = &TextSubscript{}

	_ RichTextClass = &TextSubscript{}
)

func (t *TextSubscript) Zero() bool {
	if t == nil {
		return true
	}
	if !(t.Text == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (t *TextSubscript) String() string {
	if t == nil {
		return "TextSubscript(nil)"
	}
	type Alias TextSubscript
	return fmt.Sprintf("TextSubscript%+v", Alias(*t))
}

// FillFrom fills TextSubscript from given interface.
func (t *TextSubscript) FillFrom(from interface {
	GetText() (value RichTextClass)
}) {
	t.Text = from.GetText()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*TextSubscript) TypeID() uint32 {
	return TextSubscriptTypeID
}

// TypeName returns name of type in TL schema.
func (*TextSubscript) TypeName() string {
	return "textSubscript"
}

// TypeInfo returns info about TL type.
func (t *TextSubscript) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "textSubscript",
		ID:   TextSubscriptTypeID,
	}
	if t == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Text",
			SchemaName: "text",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (t *TextSubscript) Encode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textSubscript#ed6a8504 as nil")
	}
	b.PutID(TextSubscriptTypeID)
	return t.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (t *TextSubscript) EncodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textSubscript#ed6a8504 as nil")
	}
	if t.Text == nil {
		return fmt.Errorf("unable to encode textSubscript#ed6a8504: field text is nil")
	}
	if err := t.Text.Encode(b); err != nil {
		return fmt.Errorf("unable to encode textSubscript#ed6a8504: field text: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (t *TextSubscript) Decode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textSubscript#ed6a8504 to nil")
	}
	if err := b.ConsumeID(TextSubscriptTypeID); err != nil {
		return fmt.Errorf("unable to decode textSubscript#ed6a8504: %w", err)
	}
	return t.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (t *TextSubscript) DecodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textSubscript#ed6a8504 to nil")
	}
	{
		value, err := DecodeRichText(b)
		if err != nil {
			return fmt.Errorf("unable to decode textSubscript#ed6a8504: field text: %w", err)
		}
		t.Text = value
	}
	return nil
}

// GetText returns value of Text field.
func (t *TextSubscript) GetText() (value RichTextClass) {
	if t == nil {
		return
	}
	return t.Text
}

// TextSuperscript represents TL type `textSuperscript#c7fb5e01`.
// Superscript text
//
// See https://core.telegram.org/constructor/textSuperscript for reference.
type TextSuperscript struct {
	// Text
	Text RichTextClass
}

// TextSuperscriptTypeID is TL type id of TextSuperscript.
const TextSuperscriptTypeID = 0xc7fb5e01

// construct implements constructor of RichTextClass.
func (t TextSuperscript) construct() RichTextClass { return &t }

// Ensuring interfaces in compile-time for TextSuperscript.
var (
	_ bin.Encoder     = &TextSuperscript{}
	_ bin.Decoder     = &TextSuperscript{}
	_ bin.BareEncoder = &TextSuperscript{}
	_ bin.BareDecoder = &TextSuperscript{}

	_ RichTextClass = &TextSuperscript{}
)

func (t *TextSuperscript) Zero() bool {
	if t == nil {
		return true
	}
	if !(t.Text == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (t *TextSuperscript) String() string {
	if t == nil {
		return "TextSuperscript(nil)"
	}
	type Alias TextSuperscript
	return fmt.Sprintf("TextSuperscript%+v", Alias(*t))
}

// FillFrom fills TextSuperscript from given interface.
func (t *TextSuperscript) FillFrom(from interface {
	GetText() (value RichTextClass)
}) {
	t.Text = from.GetText()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*TextSuperscript) TypeID() uint32 {
	return TextSuperscriptTypeID
}

// TypeName returns name of type in TL schema.
func (*TextSuperscript) TypeName() string {
	return "textSuperscript"
}

// TypeInfo returns info about TL type.
func (t *TextSuperscript) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "textSuperscript",
		ID:   TextSuperscriptTypeID,
	}
	if t == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Text",
			SchemaName: "text",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (t *TextSuperscript) Encode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textSuperscript#c7fb5e01 as nil")
	}
	b.PutID(TextSuperscriptTypeID)
	return t.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (t *TextSuperscript) EncodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textSuperscript#c7fb5e01 as nil")
	}
	if t.Text == nil {
		return fmt.Errorf("unable to encode textSuperscript#c7fb5e01: field text is nil")
	}
	if err := t.Text.Encode(b); err != nil {
		return fmt.Errorf("unable to encode textSuperscript#c7fb5e01: field text: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (t *TextSuperscript) Decode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textSuperscript#c7fb5e01 to nil")
	}
	if err := b.ConsumeID(TextSuperscriptTypeID); err != nil {
		return fmt.Errorf("unable to decode textSuperscript#c7fb5e01: %w", err)
	}
	return t.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (t *TextSuperscript) DecodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textSuperscript#c7fb5e01 to nil")
	}
	{
		value, err := DecodeRichText(b)
		if err != nil {
			return fmt.Errorf("unable to decode textSuperscript#c7fb5e01: field text: %w", err)
		}
		t.Text = value
	}
	return nil
}

// GetText returns value of Text field.
func (t *TextSuperscript) GetText() (value RichTextClass) {
	if t == nil {
		return
	}
	return t.Text
}

// TextMarked represents TL type `textMarked#34b8621`.
// Highlighted text
//
// See https://core.telegram.org/constructor/textMarked for reference.
type TextMarked struct {
	// Text
	Text RichTextClass
}

// TextMarkedTypeID is TL type id of TextMarked.
const TextMarkedTypeID = 0x34b8621

// construct implements constructor of RichTextClass.
func (t TextMarked) construct() RichTextClass { return &t }

// Ensuring interfaces in compile-time for TextMarked.
var (
	_ bin.Encoder     = &TextMarked{}
	_ bin.Decoder     = &TextMarked{}
	_ bin.BareEncoder = &TextMarked{}
	_ bin.BareDecoder = &TextMarked{}

	_ RichTextClass = &TextMarked{}
)

func (t *TextMarked) Zero() bool {
	if t == nil {
		return true
	}
	if !(t.Text == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (t *TextMarked) String() string {
	if t == nil {
		return "TextMarked(nil)"
	}
	type Alias TextMarked
	return fmt.Sprintf("TextMarked%+v", Alias(*t))
}

// FillFrom fills TextMarked from given interface.
func (t *TextMarked) FillFrom(from interface {
	GetText() (value RichTextClass)
}) {
	t.Text = from.GetText()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*TextMarked) TypeID() uint32 {
	return TextMarkedTypeID
}

// TypeName returns name of type in TL schema.
func (*TextMarked) TypeName() string {
	return "textMarked"
}

// TypeInfo returns info about TL type.
func (t *TextMarked) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "textMarked",
		ID:   TextMarkedTypeID,
	}
	if t == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Text",
			SchemaName: "text",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (t *TextMarked) Encode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textMarked#34b8621 as nil")
	}
	b.PutID(TextMarkedTypeID)
	return t.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (t *TextMarked) EncodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textMarked#34b8621 as nil")
	}
	if t.Text == nil {
		return fmt.Errorf("unable to encode textMarked#34b8621: field text is nil")
	}
	if err := t.Text.Encode(b); err != nil {
		return fmt.Errorf("unable to encode textMarked#34b8621: field text: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (t *TextMarked) Decode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textMarked#34b8621 to nil")
	}
	if err := b.ConsumeID(TextMarkedTypeID); err != nil {
		return fmt.Errorf("unable to decode textMarked#34b8621: %w", err)
	}
	return t.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (t *TextMarked) DecodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textMarked#34b8621 to nil")
	}
	{
		value, err := DecodeRichText(b)
		if err != nil {
			return fmt.Errorf("unable to decode textMarked#34b8621: field text: %w", err)
		}
		t.Text = value
	}
	return nil
}

// GetText returns value of Text field.
func (t *TextMarked) GetText() (value RichTextClass) {
	if t == nil {
		return
	}
	return t.Text
}

// TextPhone represents TL type `textPhone#1ccb966a`.
// Rich text linked to a phone number
//
// See https://core.telegram.org/constructor/textPhone for reference.
type TextPhone struct {
	// Text
	Text RichTextClass
	// Phone number
	Phone string
}

// TextPhoneTypeID is TL type id of TextPhone.
const TextPhoneTypeID = 0x1ccb966a

// construct implements constructor of RichTextClass.
func (t TextPhone) construct() RichTextClass { return &t }

// Ensuring interfaces in compile-time for TextPhone.
var (
	_ bin.Encoder     = &TextPhone{}
	_ bin.Decoder     = &TextPhone{}
	_ bin.BareEncoder = &TextPhone{}
	_ bin.BareDecoder = &TextPhone{}

	_ RichTextClass = &TextPhone{}
)

func (t *TextPhone) Zero() bool {
	if t == nil {
		return true
	}
	if !(t.Text == nil) {
		return false
	}
	if !(t.Phone == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (t *TextPhone) String() string {
	if t == nil {
		return "TextPhone(nil)"
	}
	type Alias TextPhone
	return fmt.Sprintf("TextPhone%+v", Alias(*t))
}

// FillFrom fills TextPhone from given interface.
func (t *TextPhone) FillFrom(from interface {
	GetText() (value RichTextClass)
	GetPhone() (value string)
}) {
	t.Text = from.GetText()
	t.Phone = from.GetPhone()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*TextPhone) TypeID() uint32 {
	return TextPhoneTypeID
}

// TypeName returns name of type in TL schema.
func (*TextPhone) TypeName() string {
	return "textPhone"
}

// TypeInfo returns info about TL type.
func (t *TextPhone) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "textPhone",
		ID:   TextPhoneTypeID,
	}
	if t == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Text",
			SchemaName: "text",
		},
		{
			Name:       "Phone",
			SchemaName: "phone",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (t *TextPhone) Encode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textPhone#1ccb966a as nil")
	}
	b.PutID(TextPhoneTypeID)
	return t.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (t *TextPhone) EncodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textPhone#1ccb966a as nil")
	}
	if t.Text == nil {
		return fmt.Errorf("unable to encode textPhone#1ccb966a: field text is nil")
	}
	if err := t.Text.Encode(b); err != nil {
		return fmt.Errorf("unable to encode textPhone#1ccb966a: field text: %w", err)
	}
	b.PutString(t.Phone)
	return nil
}

// Decode implements bin.Decoder.
func (t *TextPhone) Decode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textPhone#1ccb966a to nil")
	}
	if err := b.ConsumeID(TextPhoneTypeID); err != nil {
		return fmt.Errorf("unable to decode textPhone#1ccb966a: %w", err)
	}
	return t.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (t *TextPhone) DecodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textPhone#1ccb966a to nil")
	}
	{
		value, err := DecodeRichText(b)
		if err != nil {
			return fmt.Errorf("unable to decode textPhone#1ccb966a: field text: %w", err)
		}
		t.Text = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode textPhone#1ccb966a: field phone: %w", err)
		}
		t.Phone = value
	}
	return nil
}

// GetText returns value of Text field.
func (t *TextPhone) GetText() (value RichTextClass) {
	if t == nil {
		return
	}
	return t.Text
}

// GetPhone returns value of Phone field.
func (t *TextPhone) GetPhone() (value string) {
	if t == nil {
		return
	}
	return t.Phone
}

// TextImage represents TL type `textImage#81ccf4f`.
// Inline image
//
// See https://core.telegram.org/constructor/textImage for reference.
type TextImage struct {
	// Document ID
	DocumentID int64
	// Width
	W int
	// Height
	H int
}

// TextImageTypeID is TL type id of TextImage.
const TextImageTypeID = 0x81ccf4f

// construct implements constructor of RichTextClass.
func (t TextImage) construct() RichTextClass { return &t }

// Ensuring interfaces in compile-time for TextImage.
var (
	_ bin.Encoder     = &TextImage{}
	_ bin.Decoder     = &TextImage{}
	_ bin.BareEncoder = &TextImage{}
	_ bin.BareDecoder = &TextImage{}

	_ RichTextClass = &TextImage{}
)

func (t *TextImage) Zero() bool {
	if t == nil {
		return true
	}
	if !(t.DocumentID == 0) {
		return false
	}
	if !(t.W == 0) {
		return false
	}
	if !(t.H == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (t *TextImage) String() string {
	if t == nil {
		return "TextImage(nil)"
	}
	type Alias TextImage
	return fmt.Sprintf("TextImage%+v", Alias(*t))
}

// FillFrom fills TextImage from given interface.
func (t *TextImage) FillFrom(from interface {
	GetDocumentID() (value int64)
	GetW() (value int)
	GetH() (value int)
}) {
	t.DocumentID = from.GetDocumentID()
	t.W = from.GetW()
	t.H = from.GetH()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*TextImage) TypeID() uint32 {
	return TextImageTypeID
}

// TypeName returns name of type in TL schema.
func (*TextImage) TypeName() string {
	return "textImage"
}

// TypeInfo returns info about TL type.
func (t *TextImage) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "textImage",
		ID:   TextImageTypeID,
	}
	if t == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "DocumentID",
			SchemaName: "document_id",
		},
		{
			Name:       "W",
			SchemaName: "w",
		},
		{
			Name:       "H",
			SchemaName: "h",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (t *TextImage) Encode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textImage#81ccf4f as nil")
	}
	b.PutID(TextImageTypeID)
	return t.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (t *TextImage) EncodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textImage#81ccf4f as nil")
	}
	b.PutLong(t.DocumentID)
	b.PutInt(t.W)
	b.PutInt(t.H)
	return nil
}

// Decode implements bin.Decoder.
func (t *TextImage) Decode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textImage#81ccf4f to nil")
	}
	if err := b.ConsumeID(TextImageTypeID); err != nil {
		return fmt.Errorf("unable to decode textImage#81ccf4f: %w", err)
	}
	return t.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (t *TextImage) DecodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textImage#81ccf4f to nil")
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode textImage#81ccf4f: field document_id: %w", err)
		}
		t.DocumentID = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode textImage#81ccf4f: field w: %w", err)
		}
		t.W = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode textImage#81ccf4f: field h: %w", err)
		}
		t.H = value
	}
	return nil
}

// GetDocumentID returns value of DocumentID field.
func (t *TextImage) GetDocumentID() (value int64) {
	if t == nil {
		return
	}
	return t.DocumentID
}

// GetW returns value of W field.
func (t *TextImage) GetW() (value int) {
	if t == nil {
		return
	}
	return t.W
}

// GetH returns value of H field.
func (t *TextImage) GetH() (value int) {
	if t == nil {
		return
	}
	return t.H
}

// TextAnchor represents TL type `textAnchor#35553762`.
// Text linking to another section of the page
//
// See https://core.telegram.org/constructor/textAnchor for reference.
type TextAnchor struct {
	// Text
	Text RichTextClass
	// Section name
	Name string
}

// TextAnchorTypeID is TL type id of TextAnchor.
const TextAnchorTypeID = 0x35553762

// construct implements constructor of RichTextClass.
func (t TextAnchor) construct() RichTextClass { return &t }

// Ensuring interfaces in compile-time for TextAnchor.
var (
	_ bin.Encoder     = &TextAnchor{}
	_ bin.Decoder     = &TextAnchor{}
	_ bin.BareEncoder = &TextAnchor{}
	_ bin.BareDecoder = &TextAnchor{}

	_ RichTextClass = &TextAnchor{}
)

func (t *TextAnchor) Zero() bool {
	if t == nil {
		return true
	}
	if !(t.Text == nil) {
		return false
	}
	if !(t.Name == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (t *TextAnchor) String() string {
	if t == nil {
		return "TextAnchor(nil)"
	}
	type Alias TextAnchor
	return fmt.Sprintf("TextAnchor%+v", Alias(*t))
}

// FillFrom fills TextAnchor from given interface.
func (t *TextAnchor) FillFrom(from interface {
	GetText() (value RichTextClass)
	GetName() (value string)
}) {
	t.Text = from.GetText()
	t.Name = from.GetName()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*TextAnchor) TypeID() uint32 {
	return TextAnchorTypeID
}

// TypeName returns name of type in TL schema.
func (*TextAnchor) TypeName() string {
	return "textAnchor"
}

// TypeInfo returns info about TL type.
func (t *TextAnchor) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "textAnchor",
		ID:   TextAnchorTypeID,
	}
	if t == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Text",
			SchemaName: "text",
		},
		{
			Name:       "Name",
			SchemaName: "name",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (t *TextAnchor) Encode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textAnchor#35553762 as nil")
	}
	b.PutID(TextAnchorTypeID)
	return t.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (t *TextAnchor) EncodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textAnchor#35553762 as nil")
	}
	if t.Text == nil {
		return fmt.Errorf("unable to encode textAnchor#35553762: field text is nil")
	}
	if err := t.Text.Encode(b); err != nil {
		return fmt.Errorf("unable to encode textAnchor#35553762: field text: %w", err)
	}
	b.PutString(t.Name)
	return nil
}

// Decode implements bin.Decoder.
func (t *TextAnchor) Decode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textAnchor#35553762 to nil")
	}
	if err := b.ConsumeID(TextAnchorTypeID); err != nil {
		return fmt.Errorf("unable to decode textAnchor#35553762: %w", err)
	}
	return t.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (t *TextAnchor) DecodeBare(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textAnchor#35553762 to nil")
	}
	{
		value, err := DecodeRichText(b)
		if err != nil {
			return fmt.Errorf("unable to decode textAnchor#35553762: field text: %w", err)
		}
		t.Text = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode textAnchor#35553762: field name: %w", err)
		}
		t.Name = value
	}
	return nil
}

// GetText returns value of Text field.
func (t *TextAnchor) GetText() (value RichTextClass) {
	if t == nil {
		return
	}
	return t.Text
}

// GetName returns value of Name field.
func (t *TextAnchor) GetName() (value string) {
	if t == nil {
		return
	}
	return t.Name
}

// RichTextClassName is schema name of RichTextClass.
const RichTextClassName = "RichText"

// RichTextClass represents RichText generic type.
//
// See https://core.telegram.org/type/RichText for reference.
//
// Example:
//
//	g, err := tg.DecodeRichText(buf)
//	if err != nil {
//	    panic(err)
//	}
//	switch v := g.(type) {
//	case *tg.TextEmpty: // textEmpty#dc3d824f
//	case *tg.TextPlain: // textPlain#744694e0
//	case *tg.TextBold: // textBold#6724abc4
//	case *tg.TextItalic: // textItalic#d912a59c
//	case *tg.TextUnderline: // textUnderline#c12622c4
//	case *tg.TextStrike: // textStrike#9bf8bb95
//	case *tg.TextFixed: // textFixed#6c3f19b9
//	case *tg.TextURL: // textUrl#3c2884c1
//	case *tg.TextEmail: // textEmail#de5a0dd6
//	case *tg.TextConcat: // textConcat#7e6260d7
//	case *tg.TextSubscript: // textSubscript#ed6a8504
//	case *tg.TextSuperscript: // textSuperscript#c7fb5e01
//	case *tg.TextMarked: // textMarked#34b8621
//	case *tg.TextPhone: // textPhone#1ccb966a
//	case *tg.TextImage: // textImage#81ccf4f
//	case *tg.TextAnchor: // textAnchor#35553762
//	default: panic(v)
//	}
type RichTextClass interface {
	bin.Encoder
	bin.Decoder
	bin.BareEncoder
	bin.BareDecoder
	construct() RichTextClass

	// TypeID returns type id in TL schema.
	//
	// See https://core.telegram.org/mtproto/TL-tl#remarks.
	TypeID() uint32
	// TypeName returns name of type in TL schema.
	TypeName() string
	// String implements fmt.Stringer.
	String() string
	// Zero returns true if current object has a zero value.
	Zero() bool
}

// DecodeRichText implements binary de-serialization for RichTextClass.
func DecodeRichText(buf *bin.Buffer) (RichTextClass, error) {
	id, err := buf.PeekID()
	if err != nil {
		return nil, err
	}
	switch id {
	case TextEmptyTypeID:
		// Decoding textEmpty#dc3d824f.
		v := TextEmpty{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode RichTextClass: %w", err)
		}
		return &v, nil
	case TextPlainTypeID:
		// Decoding textPlain#744694e0.
		v := TextPlain{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode RichTextClass: %w", err)
		}
		return &v, nil
	case TextBoldTypeID:
		// Decoding textBold#6724abc4.
		v := TextBold{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode RichTextClass: %w", err)
		}
		return &v, nil
	case TextItalicTypeID:
		// Decoding textItalic#d912a59c.
		v := TextItalic{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode RichTextClass: %w", err)
		}
		return &v, nil
	case TextUnderlineTypeID:
		// Decoding textUnderline#c12622c4.
		v := TextUnderline{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode RichTextClass: %w", err)
		}
		return &v, nil
	case TextStrikeTypeID:
		// Decoding textStrike#9bf8bb95.
		v := TextStrike{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode RichTextClass: %w", err)
		}
		return &v, nil
	case TextFixedTypeID:
		// Decoding textFixed#6c3f19b9.
		v := TextFixed{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode RichTextClass: %w", err)
		}
		return &v, nil
	case TextURLTypeID:
		// Decoding textUrl#3c2884c1.
		v := TextURL{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode RichTextClass: %w", err)
		}
		return &v, nil
	case TextEmailTypeID:
		// Decoding textEmail#de5a0dd6.
		v := TextEmail{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode RichTextClass: %w", err)
		}
		return &v, nil
	case TextConcatTypeID:
		// Decoding textConcat#7e6260d7.
		v := TextConcat{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode RichTextClass: %w", err)
		}
		return &v, nil
	case TextSubscriptTypeID:
		// Decoding textSubscript#ed6a8504.
		v := TextSubscript{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode RichTextClass: %w", err)
		}
		return &v, nil
	case TextSuperscriptTypeID:
		// Decoding textSuperscript#c7fb5e01.
		v := TextSuperscript{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode RichTextClass: %w", err)
		}
		return &v, nil
	case TextMarkedTypeID:
		// Decoding textMarked#34b8621.
		v := TextMarked{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode RichTextClass: %w", err)
		}
		return &v, nil
	case TextPhoneTypeID:
		// Decoding textPhone#1ccb966a.
		v := TextPhone{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode RichTextClass: %w", err)
		}
		return &v, nil
	case TextImageTypeID:
		// Decoding textImage#81ccf4f.
		v := TextImage{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode RichTextClass: %w", err)
		}
		return &v, nil
	case TextAnchorTypeID:
		// Decoding textAnchor#35553762.
		v := TextAnchor{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode RichTextClass: %w", err)
		}
		return &v, nil
	default:
		return nil, fmt.Errorf("unable to decode RichTextClass: %w", bin.NewUnexpectedID(id))
	}
}

// RichText boxes the RichTextClass providing a helper.
type RichTextBox struct {
	RichText RichTextClass
}

// Decode implements bin.Decoder for RichTextBox.
func (b *RichTextBox) Decode(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("unable to decode RichTextBox to nil")
	}
	v, err := DecodeRichText(buf)
	if err != nil {
		return fmt.Errorf("unable to decode boxed value: %w", err)
	}
	b.RichText = v
	return nil
}

// Encode implements bin.Encode for RichTextBox.
func (b *RichTextBox) Encode(buf *bin.Buffer) error {
	if b == nil || b.RichText == nil {
		return fmt.Errorf("unable to encode RichTextClass as nil")
	}
	return b.RichText.Encode(buf)
}
