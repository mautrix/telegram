//go:build !no_gotd_slices
// +build !no_gotd_slices

// Code generated by gotdgen, DO NOT EDIT.

package tg

import (
	"context"
	"errors"
	"fmt"
	"sort"
	"strings"

	"go.uber.org/multierr"

	"go.mau.fi/mautrix-telegram/pkg/gotd/bin"
	"go.mau.fi/mautrix-telegram/pkg/gotd/tdjson"
	"go.mau.fi/mautrix-telegram/pkg/gotd/tdp"
	"go.mau.fi/mautrix-telegram/pkg/gotd/tgerr"
)

// No-op definition for keeping imports.
var (
	_ = bin.Buffer{}
	_ = context.Background()
	_ = fmt.Stringer(nil)
	_ = strings.Builder{}
	_ = errors.Is
	_ = multierr.AppendInto
	_ = sort.Ints
	_ = tdp.Format
	_ = tgerr.Error{}
	_ = tdjson.Encoder{}
)

// InputPrivacyRuleClassArray is adapter for slice of InputPrivacyRuleClass.
type InputPrivacyRuleClassArray []InputPrivacyRuleClass

// Sort sorts slice of InputPrivacyRuleClass.
func (s InputPrivacyRuleClassArray) Sort(less func(a, b InputPrivacyRuleClass) bool) InputPrivacyRuleClassArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of InputPrivacyRuleClass.
func (s InputPrivacyRuleClassArray) SortStable(less func(a, b InputPrivacyRuleClass) bool) InputPrivacyRuleClassArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of InputPrivacyRuleClass.
func (s InputPrivacyRuleClassArray) Retain(keep func(x InputPrivacyRuleClass) bool) InputPrivacyRuleClassArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s InputPrivacyRuleClassArray) First() (v InputPrivacyRuleClass, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s InputPrivacyRuleClassArray) Last() (v InputPrivacyRuleClass, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *InputPrivacyRuleClassArray) PopFirst() (v InputPrivacyRuleClass, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero InputPrivacyRuleClass
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *InputPrivacyRuleClassArray) Pop() (v InputPrivacyRuleClass, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// AsInputPrivacyValueAllowUsers returns copy with only InputPrivacyValueAllowUsers constructors.
func (s InputPrivacyRuleClassArray) AsInputPrivacyValueAllowUsers() (to InputPrivacyValueAllowUsersArray) {
	for _, elem := range s {
		value, ok := elem.(*InputPrivacyValueAllowUsers)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsInputPrivacyValueDisallowUsers returns copy with only InputPrivacyValueDisallowUsers constructors.
func (s InputPrivacyRuleClassArray) AsInputPrivacyValueDisallowUsers() (to InputPrivacyValueDisallowUsersArray) {
	for _, elem := range s {
		value, ok := elem.(*InputPrivacyValueDisallowUsers)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsInputPrivacyValueAllowChatParticipants returns copy with only InputPrivacyValueAllowChatParticipants constructors.
func (s InputPrivacyRuleClassArray) AsInputPrivacyValueAllowChatParticipants() (to InputPrivacyValueAllowChatParticipantsArray) {
	for _, elem := range s {
		value, ok := elem.(*InputPrivacyValueAllowChatParticipants)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsInputPrivacyValueDisallowChatParticipants returns copy with only InputPrivacyValueDisallowChatParticipants constructors.
func (s InputPrivacyRuleClassArray) AsInputPrivacyValueDisallowChatParticipants() (to InputPrivacyValueDisallowChatParticipantsArray) {
	for _, elem := range s {
		value, ok := elem.(*InputPrivacyValueDisallowChatParticipants)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// InputPrivacyValueAllowUsersArray is adapter for slice of InputPrivacyValueAllowUsers.
type InputPrivacyValueAllowUsersArray []InputPrivacyValueAllowUsers

// Sort sorts slice of InputPrivacyValueAllowUsers.
func (s InputPrivacyValueAllowUsersArray) Sort(less func(a, b InputPrivacyValueAllowUsers) bool) InputPrivacyValueAllowUsersArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of InputPrivacyValueAllowUsers.
func (s InputPrivacyValueAllowUsersArray) SortStable(less func(a, b InputPrivacyValueAllowUsers) bool) InputPrivacyValueAllowUsersArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of InputPrivacyValueAllowUsers.
func (s InputPrivacyValueAllowUsersArray) Retain(keep func(x InputPrivacyValueAllowUsers) bool) InputPrivacyValueAllowUsersArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s InputPrivacyValueAllowUsersArray) First() (v InputPrivacyValueAllowUsers, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s InputPrivacyValueAllowUsersArray) Last() (v InputPrivacyValueAllowUsers, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *InputPrivacyValueAllowUsersArray) PopFirst() (v InputPrivacyValueAllowUsers, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero InputPrivacyValueAllowUsers
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *InputPrivacyValueAllowUsersArray) Pop() (v InputPrivacyValueAllowUsers, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// InputPrivacyValueDisallowUsersArray is adapter for slice of InputPrivacyValueDisallowUsers.
type InputPrivacyValueDisallowUsersArray []InputPrivacyValueDisallowUsers

// Sort sorts slice of InputPrivacyValueDisallowUsers.
func (s InputPrivacyValueDisallowUsersArray) Sort(less func(a, b InputPrivacyValueDisallowUsers) bool) InputPrivacyValueDisallowUsersArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of InputPrivacyValueDisallowUsers.
func (s InputPrivacyValueDisallowUsersArray) SortStable(less func(a, b InputPrivacyValueDisallowUsers) bool) InputPrivacyValueDisallowUsersArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of InputPrivacyValueDisallowUsers.
func (s InputPrivacyValueDisallowUsersArray) Retain(keep func(x InputPrivacyValueDisallowUsers) bool) InputPrivacyValueDisallowUsersArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s InputPrivacyValueDisallowUsersArray) First() (v InputPrivacyValueDisallowUsers, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s InputPrivacyValueDisallowUsersArray) Last() (v InputPrivacyValueDisallowUsers, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *InputPrivacyValueDisallowUsersArray) PopFirst() (v InputPrivacyValueDisallowUsers, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero InputPrivacyValueDisallowUsers
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *InputPrivacyValueDisallowUsersArray) Pop() (v InputPrivacyValueDisallowUsers, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// InputPrivacyValueAllowChatParticipantsArray is adapter for slice of InputPrivacyValueAllowChatParticipants.
type InputPrivacyValueAllowChatParticipantsArray []InputPrivacyValueAllowChatParticipants

// Sort sorts slice of InputPrivacyValueAllowChatParticipants.
func (s InputPrivacyValueAllowChatParticipantsArray) Sort(less func(a, b InputPrivacyValueAllowChatParticipants) bool) InputPrivacyValueAllowChatParticipantsArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of InputPrivacyValueAllowChatParticipants.
func (s InputPrivacyValueAllowChatParticipantsArray) SortStable(less func(a, b InputPrivacyValueAllowChatParticipants) bool) InputPrivacyValueAllowChatParticipantsArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of InputPrivacyValueAllowChatParticipants.
func (s InputPrivacyValueAllowChatParticipantsArray) Retain(keep func(x InputPrivacyValueAllowChatParticipants) bool) InputPrivacyValueAllowChatParticipantsArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s InputPrivacyValueAllowChatParticipantsArray) First() (v InputPrivacyValueAllowChatParticipants, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s InputPrivacyValueAllowChatParticipantsArray) Last() (v InputPrivacyValueAllowChatParticipants, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *InputPrivacyValueAllowChatParticipantsArray) PopFirst() (v InputPrivacyValueAllowChatParticipants, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero InputPrivacyValueAllowChatParticipants
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *InputPrivacyValueAllowChatParticipantsArray) Pop() (v InputPrivacyValueAllowChatParticipants, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// InputPrivacyValueDisallowChatParticipantsArray is adapter for slice of InputPrivacyValueDisallowChatParticipants.
type InputPrivacyValueDisallowChatParticipantsArray []InputPrivacyValueDisallowChatParticipants

// Sort sorts slice of InputPrivacyValueDisallowChatParticipants.
func (s InputPrivacyValueDisallowChatParticipantsArray) Sort(less func(a, b InputPrivacyValueDisallowChatParticipants) bool) InputPrivacyValueDisallowChatParticipantsArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of InputPrivacyValueDisallowChatParticipants.
func (s InputPrivacyValueDisallowChatParticipantsArray) SortStable(less func(a, b InputPrivacyValueDisallowChatParticipants) bool) InputPrivacyValueDisallowChatParticipantsArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of InputPrivacyValueDisallowChatParticipants.
func (s InputPrivacyValueDisallowChatParticipantsArray) Retain(keep func(x InputPrivacyValueDisallowChatParticipants) bool) InputPrivacyValueDisallowChatParticipantsArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s InputPrivacyValueDisallowChatParticipantsArray) First() (v InputPrivacyValueDisallowChatParticipants, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s InputPrivacyValueDisallowChatParticipantsArray) Last() (v InputPrivacyValueDisallowChatParticipants, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *InputPrivacyValueDisallowChatParticipantsArray) PopFirst() (v InputPrivacyValueDisallowChatParticipants, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero InputPrivacyValueDisallowChatParticipants
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *InputPrivacyValueDisallowChatParticipantsArray) Pop() (v InputPrivacyValueDisallowChatParticipants, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}
