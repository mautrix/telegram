//go:build !no_gotd_slices
// +build !no_gotd_slices

// Code generated by gotdgen, DO NOT EDIT.

package tg

import (
	"context"
	"errors"
	"fmt"
	"sort"
	"strings"

	"go.uber.org/multierr"

	"go.mau.fi/mautrix-telegram/pkg/gotd/bin"
	"go.mau.fi/mautrix-telegram/pkg/gotd/tdjson"
	"go.mau.fi/mautrix-telegram/pkg/gotd/tdp"
	"go.mau.fi/mautrix-telegram/pkg/gotd/tgerr"
)

// No-op definition for keeping imports.
var (
	_ = bin.Buffer{}
	_ = context.Background()
	_ = fmt.Stringer(nil)
	_ = strings.Builder{}
	_ = errors.Is
	_ = multierr.AppendInto
	_ = sort.Ints
	_ = tdp.Format
	_ = tgerr.Error{}
	_ = tdjson.Encoder{}
)

// MessageEntityClassArray is adapter for slice of MessageEntityClass.
type MessageEntityClassArray []MessageEntityClass

// Sort sorts slice of MessageEntityClass.
func (s MessageEntityClassArray) Sort(less func(a, b MessageEntityClass) bool) MessageEntityClassArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of MessageEntityClass.
func (s MessageEntityClassArray) SortStable(less func(a, b MessageEntityClass) bool) MessageEntityClassArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of MessageEntityClass.
func (s MessageEntityClassArray) Retain(keep func(x MessageEntityClass) bool) MessageEntityClassArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s MessageEntityClassArray) First() (v MessageEntityClass, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s MessageEntityClassArray) Last() (v MessageEntityClass, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *MessageEntityClassArray) PopFirst() (v MessageEntityClass, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero MessageEntityClass
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *MessageEntityClassArray) Pop() (v MessageEntityClass, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// AsMessageEntityUnknown returns copy with only MessageEntityUnknown constructors.
func (s MessageEntityClassArray) AsMessageEntityUnknown() (to MessageEntityUnknownArray) {
	for _, elem := range s {
		value, ok := elem.(*MessageEntityUnknown)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsMessageEntityMention returns copy with only MessageEntityMention constructors.
func (s MessageEntityClassArray) AsMessageEntityMention() (to MessageEntityMentionArray) {
	for _, elem := range s {
		value, ok := elem.(*MessageEntityMention)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsMessageEntityHashtag returns copy with only MessageEntityHashtag constructors.
func (s MessageEntityClassArray) AsMessageEntityHashtag() (to MessageEntityHashtagArray) {
	for _, elem := range s {
		value, ok := elem.(*MessageEntityHashtag)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsMessageEntityBotCommand returns copy with only MessageEntityBotCommand constructors.
func (s MessageEntityClassArray) AsMessageEntityBotCommand() (to MessageEntityBotCommandArray) {
	for _, elem := range s {
		value, ok := elem.(*MessageEntityBotCommand)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsMessageEntityURL returns copy with only MessageEntityURL constructors.
func (s MessageEntityClassArray) AsMessageEntityURL() (to MessageEntityURLArray) {
	for _, elem := range s {
		value, ok := elem.(*MessageEntityURL)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsMessageEntityEmail returns copy with only MessageEntityEmail constructors.
func (s MessageEntityClassArray) AsMessageEntityEmail() (to MessageEntityEmailArray) {
	for _, elem := range s {
		value, ok := elem.(*MessageEntityEmail)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsMessageEntityBold returns copy with only MessageEntityBold constructors.
func (s MessageEntityClassArray) AsMessageEntityBold() (to MessageEntityBoldArray) {
	for _, elem := range s {
		value, ok := elem.(*MessageEntityBold)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsMessageEntityItalic returns copy with only MessageEntityItalic constructors.
func (s MessageEntityClassArray) AsMessageEntityItalic() (to MessageEntityItalicArray) {
	for _, elem := range s {
		value, ok := elem.(*MessageEntityItalic)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsMessageEntityCode returns copy with only MessageEntityCode constructors.
func (s MessageEntityClassArray) AsMessageEntityCode() (to MessageEntityCodeArray) {
	for _, elem := range s {
		value, ok := elem.(*MessageEntityCode)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsMessageEntityPre returns copy with only MessageEntityPre constructors.
func (s MessageEntityClassArray) AsMessageEntityPre() (to MessageEntityPreArray) {
	for _, elem := range s {
		value, ok := elem.(*MessageEntityPre)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsMessageEntityTextURL returns copy with only MessageEntityTextURL constructors.
func (s MessageEntityClassArray) AsMessageEntityTextURL() (to MessageEntityTextURLArray) {
	for _, elem := range s {
		value, ok := elem.(*MessageEntityTextURL)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsMessageEntityMentionName returns copy with only MessageEntityMentionName constructors.
func (s MessageEntityClassArray) AsMessageEntityMentionName() (to MessageEntityMentionNameArray) {
	for _, elem := range s {
		value, ok := elem.(*MessageEntityMentionName)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsInputMessageEntityMentionName returns copy with only InputMessageEntityMentionName constructors.
func (s MessageEntityClassArray) AsInputMessageEntityMentionName() (to InputMessageEntityMentionNameArray) {
	for _, elem := range s {
		value, ok := elem.(*InputMessageEntityMentionName)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsMessageEntityPhone returns copy with only MessageEntityPhone constructors.
func (s MessageEntityClassArray) AsMessageEntityPhone() (to MessageEntityPhoneArray) {
	for _, elem := range s {
		value, ok := elem.(*MessageEntityPhone)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsMessageEntityCashtag returns copy with only MessageEntityCashtag constructors.
func (s MessageEntityClassArray) AsMessageEntityCashtag() (to MessageEntityCashtagArray) {
	for _, elem := range s {
		value, ok := elem.(*MessageEntityCashtag)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsMessageEntityUnderline returns copy with only MessageEntityUnderline constructors.
func (s MessageEntityClassArray) AsMessageEntityUnderline() (to MessageEntityUnderlineArray) {
	for _, elem := range s {
		value, ok := elem.(*MessageEntityUnderline)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsMessageEntityStrike returns copy with only MessageEntityStrike constructors.
func (s MessageEntityClassArray) AsMessageEntityStrike() (to MessageEntityStrikeArray) {
	for _, elem := range s {
		value, ok := elem.(*MessageEntityStrike)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsMessageEntityBankCard returns copy with only MessageEntityBankCard constructors.
func (s MessageEntityClassArray) AsMessageEntityBankCard() (to MessageEntityBankCardArray) {
	for _, elem := range s {
		value, ok := elem.(*MessageEntityBankCard)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsMessageEntitySpoiler returns copy with only MessageEntitySpoiler constructors.
func (s MessageEntityClassArray) AsMessageEntitySpoiler() (to MessageEntitySpoilerArray) {
	for _, elem := range s {
		value, ok := elem.(*MessageEntitySpoiler)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsMessageEntityCustomEmoji returns copy with only MessageEntityCustomEmoji constructors.
func (s MessageEntityClassArray) AsMessageEntityCustomEmoji() (to MessageEntityCustomEmojiArray) {
	for _, elem := range s {
		value, ok := elem.(*MessageEntityCustomEmoji)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsMessageEntityBlockquote returns copy with only MessageEntityBlockquote constructors.
func (s MessageEntityClassArray) AsMessageEntityBlockquote() (to MessageEntityBlockquoteArray) {
	for _, elem := range s {
		value, ok := elem.(*MessageEntityBlockquote)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// MessageEntityUnknownArray is adapter for slice of MessageEntityUnknown.
type MessageEntityUnknownArray []MessageEntityUnknown

// Sort sorts slice of MessageEntityUnknown.
func (s MessageEntityUnknownArray) Sort(less func(a, b MessageEntityUnknown) bool) MessageEntityUnknownArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of MessageEntityUnknown.
func (s MessageEntityUnknownArray) SortStable(less func(a, b MessageEntityUnknown) bool) MessageEntityUnknownArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of MessageEntityUnknown.
func (s MessageEntityUnknownArray) Retain(keep func(x MessageEntityUnknown) bool) MessageEntityUnknownArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s MessageEntityUnknownArray) First() (v MessageEntityUnknown, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s MessageEntityUnknownArray) Last() (v MessageEntityUnknown, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *MessageEntityUnknownArray) PopFirst() (v MessageEntityUnknown, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero MessageEntityUnknown
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *MessageEntityUnknownArray) Pop() (v MessageEntityUnknown, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// MessageEntityMentionArray is adapter for slice of MessageEntityMention.
type MessageEntityMentionArray []MessageEntityMention

// Sort sorts slice of MessageEntityMention.
func (s MessageEntityMentionArray) Sort(less func(a, b MessageEntityMention) bool) MessageEntityMentionArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of MessageEntityMention.
func (s MessageEntityMentionArray) SortStable(less func(a, b MessageEntityMention) bool) MessageEntityMentionArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of MessageEntityMention.
func (s MessageEntityMentionArray) Retain(keep func(x MessageEntityMention) bool) MessageEntityMentionArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s MessageEntityMentionArray) First() (v MessageEntityMention, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s MessageEntityMentionArray) Last() (v MessageEntityMention, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *MessageEntityMentionArray) PopFirst() (v MessageEntityMention, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero MessageEntityMention
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *MessageEntityMentionArray) Pop() (v MessageEntityMention, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// MessageEntityHashtagArray is adapter for slice of MessageEntityHashtag.
type MessageEntityHashtagArray []MessageEntityHashtag

// Sort sorts slice of MessageEntityHashtag.
func (s MessageEntityHashtagArray) Sort(less func(a, b MessageEntityHashtag) bool) MessageEntityHashtagArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of MessageEntityHashtag.
func (s MessageEntityHashtagArray) SortStable(less func(a, b MessageEntityHashtag) bool) MessageEntityHashtagArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of MessageEntityHashtag.
func (s MessageEntityHashtagArray) Retain(keep func(x MessageEntityHashtag) bool) MessageEntityHashtagArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s MessageEntityHashtagArray) First() (v MessageEntityHashtag, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s MessageEntityHashtagArray) Last() (v MessageEntityHashtag, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *MessageEntityHashtagArray) PopFirst() (v MessageEntityHashtag, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero MessageEntityHashtag
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *MessageEntityHashtagArray) Pop() (v MessageEntityHashtag, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// MessageEntityBotCommandArray is adapter for slice of MessageEntityBotCommand.
type MessageEntityBotCommandArray []MessageEntityBotCommand

// Sort sorts slice of MessageEntityBotCommand.
func (s MessageEntityBotCommandArray) Sort(less func(a, b MessageEntityBotCommand) bool) MessageEntityBotCommandArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of MessageEntityBotCommand.
func (s MessageEntityBotCommandArray) SortStable(less func(a, b MessageEntityBotCommand) bool) MessageEntityBotCommandArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of MessageEntityBotCommand.
func (s MessageEntityBotCommandArray) Retain(keep func(x MessageEntityBotCommand) bool) MessageEntityBotCommandArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s MessageEntityBotCommandArray) First() (v MessageEntityBotCommand, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s MessageEntityBotCommandArray) Last() (v MessageEntityBotCommand, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *MessageEntityBotCommandArray) PopFirst() (v MessageEntityBotCommand, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero MessageEntityBotCommand
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *MessageEntityBotCommandArray) Pop() (v MessageEntityBotCommand, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// MessageEntityURLArray is adapter for slice of MessageEntityURL.
type MessageEntityURLArray []MessageEntityURL

// Sort sorts slice of MessageEntityURL.
func (s MessageEntityURLArray) Sort(less func(a, b MessageEntityURL) bool) MessageEntityURLArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of MessageEntityURL.
func (s MessageEntityURLArray) SortStable(less func(a, b MessageEntityURL) bool) MessageEntityURLArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of MessageEntityURL.
func (s MessageEntityURLArray) Retain(keep func(x MessageEntityURL) bool) MessageEntityURLArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s MessageEntityURLArray) First() (v MessageEntityURL, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s MessageEntityURLArray) Last() (v MessageEntityURL, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *MessageEntityURLArray) PopFirst() (v MessageEntityURL, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero MessageEntityURL
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *MessageEntityURLArray) Pop() (v MessageEntityURL, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// MessageEntityEmailArray is adapter for slice of MessageEntityEmail.
type MessageEntityEmailArray []MessageEntityEmail

// Sort sorts slice of MessageEntityEmail.
func (s MessageEntityEmailArray) Sort(less func(a, b MessageEntityEmail) bool) MessageEntityEmailArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of MessageEntityEmail.
func (s MessageEntityEmailArray) SortStable(less func(a, b MessageEntityEmail) bool) MessageEntityEmailArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of MessageEntityEmail.
func (s MessageEntityEmailArray) Retain(keep func(x MessageEntityEmail) bool) MessageEntityEmailArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s MessageEntityEmailArray) First() (v MessageEntityEmail, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s MessageEntityEmailArray) Last() (v MessageEntityEmail, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *MessageEntityEmailArray) PopFirst() (v MessageEntityEmail, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero MessageEntityEmail
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *MessageEntityEmailArray) Pop() (v MessageEntityEmail, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// MessageEntityBoldArray is adapter for slice of MessageEntityBold.
type MessageEntityBoldArray []MessageEntityBold

// Sort sorts slice of MessageEntityBold.
func (s MessageEntityBoldArray) Sort(less func(a, b MessageEntityBold) bool) MessageEntityBoldArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of MessageEntityBold.
func (s MessageEntityBoldArray) SortStable(less func(a, b MessageEntityBold) bool) MessageEntityBoldArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of MessageEntityBold.
func (s MessageEntityBoldArray) Retain(keep func(x MessageEntityBold) bool) MessageEntityBoldArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s MessageEntityBoldArray) First() (v MessageEntityBold, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s MessageEntityBoldArray) Last() (v MessageEntityBold, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *MessageEntityBoldArray) PopFirst() (v MessageEntityBold, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero MessageEntityBold
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *MessageEntityBoldArray) Pop() (v MessageEntityBold, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// MessageEntityItalicArray is adapter for slice of MessageEntityItalic.
type MessageEntityItalicArray []MessageEntityItalic

// Sort sorts slice of MessageEntityItalic.
func (s MessageEntityItalicArray) Sort(less func(a, b MessageEntityItalic) bool) MessageEntityItalicArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of MessageEntityItalic.
func (s MessageEntityItalicArray) SortStable(less func(a, b MessageEntityItalic) bool) MessageEntityItalicArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of MessageEntityItalic.
func (s MessageEntityItalicArray) Retain(keep func(x MessageEntityItalic) bool) MessageEntityItalicArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s MessageEntityItalicArray) First() (v MessageEntityItalic, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s MessageEntityItalicArray) Last() (v MessageEntityItalic, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *MessageEntityItalicArray) PopFirst() (v MessageEntityItalic, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero MessageEntityItalic
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *MessageEntityItalicArray) Pop() (v MessageEntityItalic, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// MessageEntityCodeArray is adapter for slice of MessageEntityCode.
type MessageEntityCodeArray []MessageEntityCode

// Sort sorts slice of MessageEntityCode.
func (s MessageEntityCodeArray) Sort(less func(a, b MessageEntityCode) bool) MessageEntityCodeArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of MessageEntityCode.
func (s MessageEntityCodeArray) SortStable(less func(a, b MessageEntityCode) bool) MessageEntityCodeArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of MessageEntityCode.
func (s MessageEntityCodeArray) Retain(keep func(x MessageEntityCode) bool) MessageEntityCodeArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s MessageEntityCodeArray) First() (v MessageEntityCode, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s MessageEntityCodeArray) Last() (v MessageEntityCode, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *MessageEntityCodeArray) PopFirst() (v MessageEntityCode, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero MessageEntityCode
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *MessageEntityCodeArray) Pop() (v MessageEntityCode, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// MessageEntityPreArray is adapter for slice of MessageEntityPre.
type MessageEntityPreArray []MessageEntityPre

// Sort sorts slice of MessageEntityPre.
func (s MessageEntityPreArray) Sort(less func(a, b MessageEntityPre) bool) MessageEntityPreArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of MessageEntityPre.
func (s MessageEntityPreArray) SortStable(less func(a, b MessageEntityPre) bool) MessageEntityPreArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of MessageEntityPre.
func (s MessageEntityPreArray) Retain(keep func(x MessageEntityPre) bool) MessageEntityPreArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s MessageEntityPreArray) First() (v MessageEntityPre, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s MessageEntityPreArray) Last() (v MessageEntityPre, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *MessageEntityPreArray) PopFirst() (v MessageEntityPre, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero MessageEntityPre
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *MessageEntityPreArray) Pop() (v MessageEntityPre, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// MessageEntityTextURLArray is adapter for slice of MessageEntityTextURL.
type MessageEntityTextURLArray []MessageEntityTextURL

// Sort sorts slice of MessageEntityTextURL.
func (s MessageEntityTextURLArray) Sort(less func(a, b MessageEntityTextURL) bool) MessageEntityTextURLArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of MessageEntityTextURL.
func (s MessageEntityTextURLArray) SortStable(less func(a, b MessageEntityTextURL) bool) MessageEntityTextURLArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of MessageEntityTextURL.
func (s MessageEntityTextURLArray) Retain(keep func(x MessageEntityTextURL) bool) MessageEntityTextURLArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s MessageEntityTextURLArray) First() (v MessageEntityTextURL, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s MessageEntityTextURLArray) Last() (v MessageEntityTextURL, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *MessageEntityTextURLArray) PopFirst() (v MessageEntityTextURL, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero MessageEntityTextURL
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *MessageEntityTextURLArray) Pop() (v MessageEntityTextURL, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// MessageEntityMentionNameArray is adapter for slice of MessageEntityMentionName.
type MessageEntityMentionNameArray []MessageEntityMentionName

// Sort sorts slice of MessageEntityMentionName.
func (s MessageEntityMentionNameArray) Sort(less func(a, b MessageEntityMentionName) bool) MessageEntityMentionNameArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of MessageEntityMentionName.
func (s MessageEntityMentionNameArray) SortStable(less func(a, b MessageEntityMentionName) bool) MessageEntityMentionNameArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of MessageEntityMentionName.
func (s MessageEntityMentionNameArray) Retain(keep func(x MessageEntityMentionName) bool) MessageEntityMentionNameArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s MessageEntityMentionNameArray) First() (v MessageEntityMentionName, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s MessageEntityMentionNameArray) Last() (v MessageEntityMentionName, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *MessageEntityMentionNameArray) PopFirst() (v MessageEntityMentionName, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero MessageEntityMentionName
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *MessageEntityMentionNameArray) Pop() (v MessageEntityMentionName, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// InputMessageEntityMentionNameArray is adapter for slice of InputMessageEntityMentionName.
type InputMessageEntityMentionNameArray []InputMessageEntityMentionName

// Sort sorts slice of InputMessageEntityMentionName.
func (s InputMessageEntityMentionNameArray) Sort(less func(a, b InputMessageEntityMentionName) bool) InputMessageEntityMentionNameArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of InputMessageEntityMentionName.
func (s InputMessageEntityMentionNameArray) SortStable(less func(a, b InputMessageEntityMentionName) bool) InputMessageEntityMentionNameArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of InputMessageEntityMentionName.
func (s InputMessageEntityMentionNameArray) Retain(keep func(x InputMessageEntityMentionName) bool) InputMessageEntityMentionNameArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s InputMessageEntityMentionNameArray) First() (v InputMessageEntityMentionName, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s InputMessageEntityMentionNameArray) Last() (v InputMessageEntityMentionName, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *InputMessageEntityMentionNameArray) PopFirst() (v InputMessageEntityMentionName, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero InputMessageEntityMentionName
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *InputMessageEntityMentionNameArray) Pop() (v InputMessageEntityMentionName, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// MessageEntityPhoneArray is adapter for slice of MessageEntityPhone.
type MessageEntityPhoneArray []MessageEntityPhone

// Sort sorts slice of MessageEntityPhone.
func (s MessageEntityPhoneArray) Sort(less func(a, b MessageEntityPhone) bool) MessageEntityPhoneArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of MessageEntityPhone.
func (s MessageEntityPhoneArray) SortStable(less func(a, b MessageEntityPhone) bool) MessageEntityPhoneArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of MessageEntityPhone.
func (s MessageEntityPhoneArray) Retain(keep func(x MessageEntityPhone) bool) MessageEntityPhoneArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s MessageEntityPhoneArray) First() (v MessageEntityPhone, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s MessageEntityPhoneArray) Last() (v MessageEntityPhone, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *MessageEntityPhoneArray) PopFirst() (v MessageEntityPhone, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero MessageEntityPhone
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *MessageEntityPhoneArray) Pop() (v MessageEntityPhone, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// MessageEntityCashtagArray is adapter for slice of MessageEntityCashtag.
type MessageEntityCashtagArray []MessageEntityCashtag

// Sort sorts slice of MessageEntityCashtag.
func (s MessageEntityCashtagArray) Sort(less func(a, b MessageEntityCashtag) bool) MessageEntityCashtagArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of MessageEntityCashtag.
func (s MessageEntityCashtagArray) SortStable(less func(a, b MessageEntityCashtag) bool) MessageEntityCashtagArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of MessageEntityCashtag.
func (s MessageEntityCashtagArray) Retain(keep func(x MessageEntityCashtag) bool) MessageEntityCashtagArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s MessageEntityCashtagArray) First() (v MessageEntityCashtag, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s MessageEntityCashtagArray) Last() (v MessageEntityCashtag, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *MessageEntityCashtagArray) PopFirst() (v MessageEntityCashtag, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero MessageEntityCashtag
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *MessageEntityCashtagArray) Pop() (v MessageEntityCashtag, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// MessageEntityUnderlineArray is adapter for slice of MessageEntityUnderline.
type MessageEntityUnderlineArray []MessageEntityUnderline

// Sort sorts slice of MessageEntityUnderline.
func (s MessageEntityUnderlineArray) Sort(less func(a, b MessageEntityUnderline) bool) MessageEntityUnderlineArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of MessageEntityUnderline.
func (s MessageEntityUnderlineArray) SortStable(less func(a, b MessageEntityUnderline) bool) MessageEntityUnderlineArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of MessageEntityUnderline.
func (s MessageEntityUnderlineArray) Retain(keep func(x MessageEntityUnderline) bool) MessageEntityUnderlineArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s MessageEntityUnderlineArray) First() (v MessageEntityUnderline, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s MessageEntityUnderlineArray) Last() (v MessageEntityUnderline, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *MessageEntityUnderlineArray) PopFirst() (v MessageEntityUnderline, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero MessageEntityUnderline
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *MessageEntityUnderlineArray) Pop() (v MessageEntityUnderline, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// MessageEntityStrikeArray is adapter for slice of MessageEntityStrike.
type MessageEntityStrikeArray []MessageEntityStrike

// Sort sorts slice of MessageEntityStrike.
func (s MessageEntityStrikeArray) Sort(less func(a, b MessageEntityStrike) bool) MessageEntityStrikeArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of MessageEntityStrike.
func (s MessageEntityStrikeArray) SortStable(less func(a, b MessageEntityStrike) bool) MessageEntityStrikeArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of MessageEntityStrike.
func (s MessageEntityStrikeArray) Retain(keep func(x MessageEntityStrike) bool) MessageEntityStrikeArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s MessageEntityStrikeArray) First() (v MessageEntityStrike, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s MessageEntityStrikeArray) Last() (v MessageEntityStrike, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *MessageEntityStrikeArray) PopFirst() (v MessageEntityStrike, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero MessageEntityStrike
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *MessageEntityStrikeArray) Pop() (v MessageEntityStrike, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// MessageEntityBankCardArray is adapter for slice of MessageEntityBankCard.
type MessageEntityBankCardArray []MessageEntityBankCard

// Sort sorts slice of MessageEntityBankCard.
func (s MessageEntityBankCardArray) Sort(less func(a, b MessageEntityBankCard) bool) MessageEntityBankCardArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of MessageEntityBankCard.
func (s MessageEntityBankCardArray) SortStable(less func(a, b MessageEntityBankCard) bool) MessageEntityBankCardArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of MessageEntityBankCard.
func (s MessageEntityBankCardArray) Retain(keep func(x MessageEntityBankCard) bool) MessageEntityBankCardArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s MessageEntityBankCardArray) First() (v MessageEntityBankCard, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s MessageEntityBankCardArray) Last() (v MessageEntityBankCard, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *MessageEntityBankCardArray) PopFirst() (v MessageEntityBankCard, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero MessageEntityBankCard
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *MessageEntityBankCardArray) Pop() (v MessageEntityBankCard, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// MessageEntitySpoilerArray is adapter for slice of MessageEntitySpoiler.
type MessageEntitySpoilerArray []MessageEntitySpoiler

// Sort sorts slice of MessageEntitySpoiler.
func (s MessageEntitySpoilerArray) Sort(less func(a, b MessageEntitySpoiler) bool) MessageEntitySpoilerArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of MessageEntitySpoiler.
func (s MessageEntitySpoilerArray) SortStable(less func(a, b MessageEntitySpoiler) bool) MessageEntitySpoilerArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of MessageEntitySpoiler.
func (s MessageEntitySpoilerArray) Retain(keep func(x MessageEntitySpoiler) bool) MessageEntitySpoilerArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s MessageEntitySpoilerArray) First() (v MessageEntitySpoiler, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s MessageEntitySpoilerArray) Last() (v MessageEntitySpoiler, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *MessageEntitySpoilerArray) PopFirst() (v MessageEntitySpoiler, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero MessageEntitySpoiler
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *MessageEntitySpoilerArray) Pop() (v MessageEntitySpoiler, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// MessageEntityCustomEmojiArray is adapter for slice of MessageEntityCustomEmoji.
type MessageEntityCustomEmojiArray []MessageEntityCustomEmoji

// Sort sorts slice of MessageEntityCustomEmoji.
func (s MessageEntityCustomEmojiArray) Sort(less func(a, b MessageEntityCustomEmoji) bool) MessageEntityCustomEmojiArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of MessageEntityCustomEmoji.
func (s MessageEntityCustomEmojiArray) SortStable(less func(a, b MessageEntityCustomEmoji) bool) MessageEntityCustomEmojiArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of MessageEntityCustomEmoji.
func (s MessageEntityCustomEmojiArray) Retain(keep func(x MessageEntityCustomEmoji) bool) MessageEntityCustomEmojiArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s MessageEntityCustomEmojiArray) First() (v MessageEntityCustomEmoji, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s MessageEntityCustomEmojiArray) Last() (v MessageEntityCustomEmoji, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *MessageEntityCustomEmojiArray) PopFirst() (v MessageEntityCustomEmoji, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero MessageEntityCustomEmoji
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *MessageEntityCustomEmojiArray) Pop() (v MessageEntityCustomEmoji, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// MessageEntityBlockquoteArray is adapter for slice of MessageEntityBlockquote.
type MessageEntityBlockquoteArray []MessageEntityBlockquote

// Sort sorts slice of MessageEntityBlockquote.
func (s MessageEntityBlockquoteArray) Sort(less func(a, b MessageEntityBlockquote) bool) MessageEntityBlockquoteArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of MessageEntityBlockquote.
func (s MessageEntityBlockquoteArray) SortStable(less func(a, b MessageEntityBlockquote) bool) MessageEntityBlockquoteArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of MessageEntityBlockquote.
func (s MessageEntityBlockquoteArray) Retain(keep func(x MessageEntityBlockquote) bool) MessageEntityBlockquoteArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s MessageEntityBlockquoteArray) First() (v MessageEntityBlockquote, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s MessageEntityBlockquoteArray) Last() (v MessageEntityBlockquote, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *MessageEntityBlockquoteArray) PopFirst() (v MessageEntityBlockquote, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero MessageEntityBlockquote
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *MessageEntityBlockquoteArray) Pop() (v MessageEntityBlockquote, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}
