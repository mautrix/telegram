// Code generated by gotdgen, DO NOT EDIT.

package tg

import (
	"context"
	"errors"
	"fmt"
	"sort"
	"strings"

	"go.uber.org/multierr"

	"go.mau.fi/mautrix-telegram/pkg/gotd/bin"
	"go.mau.fi/mautrix-telegram/pkg/gotd/tdjson"
	"go.mau.fi/mautrix-telegram/pkg/gotd/tdp"
	"go.mau.fi/mautrix-telegram/pkg/gotd/tgerr"
)

// No-op definition for keeping imports.
var (
	_ = bin.Buffer{}
	_ = context.Background()
	_ = fmt.Stringer(nil)
	_ = strings.Builder{}
	_ = errors.Is
	_ = multierr.AppendInto
	_ = sort.Ints
	_ = tdp.Format
	_ = tgerr.Error{}
	_ = tdjson.Encoder{}
)

// MessageMediaEmpty represents TL type `messageMediaEmpty#3ded6320`.
// Empty constructor.
//
// See https://core.telegram.org/constructor/messageMediaEmpty for reference.
type MessageMediaEmpty struct {
}

// MessageMediaEmptyTypeID is TL type id of MessageMediaEmpty.
const MessageMediaEmptyTypeID = 0x3ded6320

// construct implements constructor of MessageMediaClass.
func (m MessageMediaEmpty) construct() MessageMediaClass { return &m }

// Ensuring interfaces in compile-time for MessageMediaEmpty.
var (
	_ bin.Encoder     = &MessageMediaEmpty{}
	_ bin.Decoder     = &MessageMediaEmpty{}
	_ bin.BareEncoder = &MessageMediaEmpty{}
	_ bin.BareDecoder = &MessageMediaEmpty{}

	_ MessageMediaClass = &MessageMediaEmpty{}
)

func (m *MessageMediaEmpty) Zero() bool {
	if m == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageMediaEmpty) String() string {
	if m == nil {
		return "MessageMediaEmpty(nil)"
	}
	type Alias MessageMediaEmpty
	return fmt.Sprintf("MessageMediaEmpty%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageMediaEmpty) TypeID() uint32 {
	return MessageMediaEmptyTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageMediaEmpty) TypeName() string {
	return "messageMediaEmpty"
}

// TypeInfo returns info about TL type.
func (m *MessageMediaEmpty) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageMediaEmpty",
		ID:   MessageMediaEmptyTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageMediaEmpty) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageMediaEmpty#3ded6320 as nil")
	}
	b.PutID(MessageMediaEmptyTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageMediaEmpty) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageMediaEmpty#3ded6320 as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageMediaEmpty) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageMediaEmpty#3ded6320 to nil")
	}
	if err := b.ConsumeID(MessageMediaEmptyTypeID); err != nil {
		return fmt.Errorf("unable to decode messageMediaEmpty#3ded6320: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageMediaEmpty) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageMediaEmpty#3ded6320 to nil")
	}
	return nil
}

// MessageMediaPhoto represents TL type `messageMediaPhoto#695150d7`.
// Attached photo.
//
// See https://core.telegram.org/constructor/messageMediaPhoto for reference.
type MessageMediaPhoto struct {
	// Flags, see TL conditional fieldsÂ¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// Whether this media should be hidden behind a spoiler warning
	Spoiler bool
	// Photo
	//
	// Use SetPhoto and GetPhoto helpers.
	Photo PhotoClass
	// Time to live in seconds of self-destructing photo
	//
	// Use SetTTLSeconds and GetTTLSeconds helpers.
	TTLSeconds int
}

// MessageMediaPhotoTypeID is TL type id of MessageMediaPhoto.
const MessageMediaPhotoTypeID = 0x695150d7

// construct implements constructor of MessageMediaClass.
func (m MessageMediaPhoto) construct() MessageMediaClass { return &m }

// Ensuring interfaces in compile-time for MessageMediaPhoto.
var (
	_ bin.Encoder     = &MessageMediaPhoto{}
	_ bin.Decoder     = &MessageMediaPhoto{}
	_ bin.BareEncoder = &MessageMediaPhoto{}
	_ bin.BareDecoder = &MessageMediaPhoto{}

	_ MessageMediaClass = &MessageMediaPhoto{}
)

func (m *MessageMediaPhoto) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.Flags.Zero()) {
		return false
	}
	if !(m.Spoiler == false) {
		return false
	}
	if !(m.Photo == nil) {
		return false
	}
	if !(m.TTLSeconds == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageMediaPhoto) String() string {
	if m == nil {
		return "MessageMediaPhoto(nil)"
	}
	type Alias MessageMediaPhoto
	return fmt.Sprintf("MessageMediaPhoto%+v", Alias(*m))
}

// FillFrom fills MessageMediaPhoto from given interface.
func (m *MessageMediaPhoto) FillFrom(from interface {
	GetSpoiler() (value bool)
	GetPhoto() (value PhotoClass, ok bool)
	GetTTLSeconds() (value int, ok bool)
}) {
	m.Spoiler = from.GetSpoiler()
	if val, ok := from.GetPhoto(); ok {
		m.Photo = val
	}

	if val, ok := from.GetTTLSeconds(); ok {
		m.TTLSeconds = val
	}

}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageMediaPhoto) TypeID() uint32 {
	return MessageMediaPhotoTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageMediaPhoto) TypeName() string {
	return "messageMediaPhoto"
}

// TypeInfo returns info about TL type.
func (m *MessageMediaPhoto) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageMediaPhoto",
		ID:   MessageMediaPhotoTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Spoiler",
			SchemaName: "spoiler",
			Null:       !m.Flags.Has(3),
		},
		{
			Name:       "Photo",
			SchemaName: "photo",
			Null:       !m.Flags.Has(0),
		},
		{
			Name:       "TTLSeconds",
			SchemaName: "ttl_seconds",
			Null:       !m.Flags.Has(2),
		},
	}
	return typ
}

// SetFlags sets flags for non-zero fields.
func (m *MessageMediaPhoto) SetFlags() {
	if !(m.Spoiler == false) {
		m.Flags.Set(3)
	}
	if !(m.Photo == nil) {
		m.Flags.Set(0)
	}
	if !(m.TTLSeconds == 0) {
		m.Flags.Set(2)
	}
}

// Encode implements bin.Encoder.
func (m *MessageMediaPhoto) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageMediaPhoto#695150d7 as nil")
	}
	b.PutID(MessageMediaPhotoTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageMediaPhoto) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageMediaPhoto#695150d7 as nil")
	}
	m.SetFlags()
	if err := m.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageMediaPhoto#695150d7: field flags: %w", err)
	}
	if m.Flags.Has(0) {
		if m.Photo == nil {
			return fmt.Errorf("unable to encode messageMediaPhoto#695150d7: field photo is nil")
		}
		if err := m.Photo.Encode(b); err != nil {
			return fmt.Errorf("unable to encode messageMediaPhoto#695150d7: field photo: %w", err)
		}
	}
	if m.Flags.Has(2) {
		b.PutInt(m.TTLSeconds)
	}
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageMediaPhoto) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageMediaPhoto#695150d7 to nil")
	}
	if err := b.ConsumeID(MessageMediaPhotoTypeID); err != nil {
		return fmt.Errorf("unable to decode messageMediaPhoto#695150d7: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageMediaPhoto) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageMediaPhoto#695150d7 to nil")
	}
	{
		if err := m.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messageMediaPhoto#695150d7: field flags: %w", err)
		}
	}
	m.Spoiler = m.Flags.Has(3)
	if m.Flags.Has(0) {
		value, err := DecodePhoto(b)
		if err != nil {
			return fmt.Errorf("unable to decode messageMediaPhoto#695150d7: field photo: %w", err)
		}
		m.Photo = value
	}
	if m.Flags.Has(2) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode messageMediaPhoto#695150d7: field ttl_seconds: %w", err)
		}
		m.TTLSeconds = value
	}
	return nil
}

// SetSpoiler sets value of Spoiler conditional field.
func (m *MessageMediaPhoto) SetSpoiler(value bool) {
	if value {
		m.Flags.Set(3)
		m.Spoiler = true
	} else {
		m.Flags.Unset(3)
		m.Spoiler = false
	}
}

// GetSpoiler returns value of Spoiler conditional field.
func (m *MessageMediaPhoto) GetSpoiler() (value bool) {
	if m == nil {
		return
	}
	return m.Flags.Has(3)
}

// SetPhoto sets value of Photo conditional field.
func (m *MessageMediaPhoto) SetPhoto(value PhotoClass) {
	m.Flags.Set(0)
	m.Photo = value
}

// GetPhoto returns value of Photo conditional field and
// boolean which is true if field was set.
func (m *MessageMediaPhoto) GetPhoto() (value PhotoClass, ok bool) {
	if m == nil {
		return
	}
	if !m.Flags.Has(0) {
		return value, false
	}
	return m.Photo, true
}

// SetTTLSeconds sets value of TTLSeconds conditional field.
func (m *MessageMediaPhoto) SetTTLSeconds(value int) {
	m.Flags.Set(2)
	m.TTLSeconds = value
}

// GetTTLSeconds returns value of TTLSeconds conditional field and
// boolean which is true if field was set.
func (m *MessageMediaPhoto) GetTTLSeconds() (value int, ok bool) {
	if m == nil {
		return
	}
	if !m.Flags.Has(2) {
		return value, false
	}
	return m.TTLSeconds, true
}

// MessageMediaGeo represents TL type `messageMediaGeo#56e0d474`.
// Attached map.
//
// See https://core.telegram.org/constructor/messageMediaGeo for reference.
type MessageMediaGeo struct {
	// GeoPoint
	Geo GeoPointClass
}

// MessageMediaGeoTypeID is TL type id of MessageMediaGeo.
const MessageMediaGeoTypeID = 0x56e0d474

// construct implements constructor of MessageMediaClass.
func (m MessageMediaGeo) construct() MessageMediaClass { return &m }

// Ensuring interfaces in compile-time for MessageMediaGeo.
var (
	_ bin.Encoder     = &MessageMediaGeo{}
	_ bin.Decoder     = &MessageMediaGeo{}
	_ bin.BareEncoder = &MessageMediaGeo{}
	_ bin.BareDecoder = &MessageMediaGeo{}

	_ MessageMediaClass = &MessageMediaGeo{}
)

func (m *MessageMediaGeo) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.Geo == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageMediaGeo) String() string {
	if m == nil {
		return "MessageMediaGeo(nil)"
	}
	type Alias MessageMediaGeo
	return fmt.Sprintf("MessageMediaGeo%+v", Alias(*m))
}

// FillFrom fills MessageMediaGeo from given interface.
func (m *MessageMediaGeo) FillFrom(from interface {
	GetGeo() (value GeoPointClass)
}) {
	m.Geo = from.GetGeo()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageMediaGeo) TypeID() uint32 {
	return MessageMediaGeoTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageMediaGeo) TypeName() string {
	return "messageMediaGeo"
}

// TypeInfo returns info about TL type.
func (m *MessageMediaGeo) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageMediaGeo",
		ID:   MessageMediaGeoTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Geo",
			SchemaName: "geo",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageMediaGeo) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageMediaGeo#56e0d474 as nil")
	}
	b.PutID(MessageMediaGeoTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageMediaGeo) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageMediaGeo#56e0d474 as nil")
	}
	if m.Geo == nil {
		return fmt.Errorf("unable to encode messageMediaGeo#56e0d474: field geo is nil")
	}
	if err := m.Geo.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageMediaGeo#56e0d474: field geo: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageMediaGeo) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageMediaGeo#56e0d474 to nil")
	}
	if err := b.ConsumeID(MessageMediaGeoTypeID); err != nil {
		return fmt.Errorf("unable to decode messageMediaGeo#56e0d474: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageMediaGeo) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageMediaGeo#56e0d474 to nil")
	}
	{
		value, err := DecodeGeoPoint(b)
		if err != nil {
			return fmt.Errorf("unable to decode messageMediaGeo#56e0d474: field geo: %w", err)
		}
		m.Geo = value
	}
	return nil
}

// GetGeo returns value of Geo field.
func (m *MessageMediaGeo) GetGeo() (value GeoPointClass) {
	if m == nil {
		return
	}
	return m.Geo
}

// MessageMediaContact represents TL type `messageMediaContact#70322949`.
// Attached contact.
//
// See https://core.telegram.org/constructor/messageMediaContact for reference.
type MessageMediaContact struct {
	// Phone number
	PhoneNumber string
	// Contact's first name
	FirstName string
	// Contact's last name
	LastName string
	// VCARD of contact
	Vcard string
	// User identifier or 0, if the user with the given phone number is not registered
	UserID int64
}

// MessageMediaContactTypeID is TL type id of MessageMediaContact.
const MessageMediaContactTypeID = 0x70322949

// construct implements constructor of MessageMediaClass.
func (m MessageMediaContact) construct() MessageMediaClass { return &m }

// Ensuring interfaces in compile-time for MessageMediaContact.
var (
	_ bin.Encoder     = &MessageMediaContact{}
	_ bin.Decoder     = &MessageMediaContact{}
	_ bin.BareEncoder = &MessageMediaContact{}
	_ bin.BareDecoder = &MessageMediaContact{}

	_ MessageMediaClass = &MessageMediaContact{}
)

func (m *MessageMediaContact) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.PhoneNumber == "") {
		return false
	}
	if !(m.FirstName == "") {
		return false
	}
	if !(m.LastName == "") {
		return false
	}
	if !(m.Vcard == "") {
		return false
	}
	if !(m.UserID == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageMediaContact) String() string {
	if m == nil {
		return "MessageMediaContact(nil)"
	}
	type Alias MessageMediaContact
	return fmt.Sprintf("MessageMediaContact%+v", Alias(*m))
}

// FillFrom fills MessageMediaContact from given interface.
func (m *MessageMediaContact) FillFrom(from interface {
	GetPhoneNumber() (value string)
	GetFirstName() (value string)
	GetLastName() (value string)
	GetVcard() (value string)
	GetUserID() (value int64)
}) {
	m.PhoneNumber = from.GetPhoneNumber()
	m.FirstName = from.GetFirstName()
	m.LastName = from.GetLastName()
	m.Vcard = from.GetVcard()
	m.UserID = from.GetUserID()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageMediaContact) TypeID() uint32 {
	return MessageMediaContactTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageMediaContact) TypeName() string {
	return "messageMediaContact"
}

// TypeInfo returns info about TL type.
func (m *MessageMediaContact) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageMediaContact",
		ID:   MessageMediaContactTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "PhoneNumber",
			SchemaName: "phone_number",
		},
		{
			Name:       "FirstName",
			SchemaName: "first_name",
		},
		{
			Name:       "LastName",
			SchemaName: "last_name",
		},
		{
			Name:       "Vcard",
			SchemaName: "vcard",
		},
		{
			Name:       "UserID",
			SchemaName: "user_id",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageMediaContact) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageMediaContact#70322949 as nil")
	}
	b.PutID(MessageMediaContactTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageMediaContact) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageMediaContact#70322949 as nil")
	}
	b.PutString(m.PhoneNumber)
	b.PutString(m.FirstName)
	b.PutString(m.LastName)
	b.PutString(m.Vcard)
	b.PutLong(m.UserID)
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageMediaContact) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageMediaContact#70322949 to nil")
	}
	if err := b.ConsumeID(MessageMediaContactTypeID); err != nil {
		return fmt.Errorf("unable to decode messageMediaContact#70322949: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageMediaContact) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageMediaContact#70322949 to nil")
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode messageMediaContact#70322949: field phone_number: %w", err)
		}
		m.PhoneNumber = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode messageMediaContact#70322949: field first_name: %w", err)
		}
		m.FirstName = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode messageMediaContact#70322949: field last_name: %w", err)
		}
		m.LastName = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode messageMediaContact#70322949: field vcard: %w", err)
		}
		m.Vcard = value
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode messageMediaContact#70322949: field user_id: %w", err)
		}
		m.UserID = value
	}
	return nil
}

// GetPhoneNumber returns value of PhoneNumber field.
func (m *MessageMediaContact) GetPhoneNumber() (value string) {
	if m == nil {
		return
	}
	return m.PhoneNumber
}

// GetFirstName returns value of FirstName field.
func (m *MessageMediaContact) GetFirstName() (value string) {
	if m == nil {
		return
	}
	return m.FirstName
}

// GetLastName returns value of LastName field.
func (m *MessageMediaContact) GetLastName() (value string) {
	if m == nil {
		return
	}
	return m.LastName
}

// GetVcard returns value of Vcard field.
func (m *MessageMediaContact) GetVcard() (value string) {
	if m == nil {
		return
	}
	return m.Vcard
}

// GetUserID returns value of UserID field.
func (m *MessageMediaContact) GetUserID() (value int64) {
	if m == nil {
		return
	}
	return m.UserID
}

// MessageMediaUnsupported represents TL type `messageMediaUnsupported#9f84f49e`.
// Current version of the client does not support this media type.
//
// See https://core.telegram.org/constructor/messageMediaUnsupported for reference.
type MessageMediaUnsupported struct {
}

// MessageMediaUnsupportedTypeID is TL type id of MessageMediaUnsupported.
const MessageMediaUnsupportedTypeID = 0x9f84f49e

// construct implements constructor of MessageMediaClass.
func (m MessageMediaUnsupported) construct() MessageMediaClass { return &m }

// Ensuring interfaces in compile-time for MessageMediaUnsupported.
var (
	_ bin.Encoder     = &MessageMediaUnsupported{}
	_ bin.Decoder     = &MessageMediaUnsupported{}
	_ bin.BareEncoder = &MessageMediaUnsupported{}
	_ bin.BareDecoder = &MessageMediaUnsupported{}

	_ MessageMediaClass = &MessageMediaUnsupported{}
)

func (m *MessageMediaUnsupported) Zero() bool {
	if m == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageMediaUnsupported) String() string {
	if m == nil {
		return "MessageMediaUnsupported(nil)"
	}
	type Alias MessageMediaUnsupported
	return fmt.Sprintf("MessageMediaUnsupported%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageMediaUnsupported) TypeID() uint32 {
	return MessageMediaUnsupportedTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageMediaUnsupported) TypeName() string {
	return "messageMediaUnsupported"
}

// TypeInfo returns info about TL type.
func (m *MessageMediaUnsupported) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageMediaUnsupported",
		ID:   MessageMediaUnsupportedTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageMediaUnsupported) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageMediaUnsupported#9f84f49e as nil")
	}
	b.PutID(MessageMediaUnsupportedTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageMediaUnsupported) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageMediaUnsupported#9f84f49e as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageMediaUnsupported) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageMediaUnsupported#9f84f49e to nil")
	}
	if err := b.ConsumeID(MessageMediaUnsupportedTypeID); err != nil {
		return fmt.Errorf("unable to decode messageMediaUnsupported#9f84f49e: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageMediaUnsupported) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageMediaUnsupported#9f84f49e to nil")
	}
	return nil
}

// MessageMediaDocument represents TL type `messageMediaDocument#52d8ccd9`.
// Document (video, audio, voice, sticker, any media type except photo)
//
// See https://core.telegram.org/constructor/messageMediaDocument for reference.
type MessageMediaDocument struct {
	// Flags, see TL conditional fieldsÂ¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// Whether this is a normal sticker, if not set this is a premium sticker and a premium
	// sticker animation must be played.
	Nopremium bool
	// Whether this media should be hidden behind a spoiler warning
	Spoiler bool
	// Whether this is a video.
	Video bool
	// Whether this is a round video.
	Round bool
	// Whether this is a voice message.
	Voice bool
	// Attached document
	//
	// Use SetDocument and GetDocument helpers.
	Document DocumentClass
	// Videos only, contains alternative qualities of the video.
	//
	// Use SetAltDocuments and GetAltDocuments helpers.
	AltDocuments []DocumentClass
	// VideoCover field of MessageMediaDocument.
	//
	// Use SetVideoCover and GetVideoCover helpers.
	VideoCover PhotoClass
	// VideoTimestamp field of MessageMediaDocument.
	//
	// Use SetVideoTimestamp and GetVideoTimestamp helpers.
	VideoTimestamp int
	// Time to live of self-destructing document
	//
	// Use SetTTLSeconds and GetTTLSeconds helpers.
	TTLSeconds int
}

// MessageMediaDocumentTypeID is TL type id of MessageMediaDocument.
const MessageMediaDocumentTypeID = 0x52d8ccd9

// construct implements constructor of MessageMediaClass.
func (m MessageMediaDocument) construct() MessageMediaClass { return &m }

// Ensuring interfaces in compile-time for MessageMediaDocument.
var (
	_ bin.Encoder     = &MessageMediaDocument{}
	_ bin.Decoder     = &MessageMediaDocument{}
	_ bin.BareEncoder = &MessageMediaDocument{}
	_ bin.BareDecoder = &MessageMediaDocument{}

	_ MessageMediaClass = &MessageMediaDocument{}
)

func (m *MessageMediaDocument) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.Flags.Zero()) {
		return false
	}
	if !(m.Nopremium == false) {
		return false
	}
	if !(m.Spoiler == false) {
		return false
	}
	if !(m.Video == false) {
		return false
	}
	if !(m.Round == false) {
		return false
	}
	if !(m.Voice == false) {
		return false
	}
	if !(m.Document == nil) {
		return false
	}
	if !(m.AltDocuments == nil) {
		return false
	}
	if !(m.VideoCover == nil) {
		return false
	}
	if !(m.VideoTimestamp == 0) {
		return false
	}
	if !(m.TTLSeconds == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageMediaDocument) String() string {
	if m == nil {
		return "MessageMediaDocument(nil)"
	}
	type Alias MessageMediaDocument
	return fmt.Sprintf("MessageMediaDocument%+v", Alias(*m))
}

// FillFrom fills MessageMediaDocument from given interface.
func (m *MessageMediaDocument) FillFrom(from interface {
	GetNopremium() (value bool)
	GetSpoiler() (value bool)
	GetVideo() (value bool)
	GetRound() (value bool)
	GetVoice() (value bool)
	GetDocument() (value DocumentClass, ok bool)
	GetAltDocuments() (value []DocumentClass, ok bool)
	GetVideoCover() (value PhotoClass, ok bool)
	GetVideoTimestamp() (value int, ok bool)
	GetTTLSeconds() (value int, ok bool)
}) {
	m.Nopremium = from.GetNopremium()
	m.Spoiler = from.GetSpoiler()
	m.Video = from.GetVideo()
	m.Round = from.GetRound()
	m.Voice = from.GetVoice()
	if val, ok := from.GetDocument(); ok {
		m.Document = val
	}

	if val, ok := from.GetAltDocuments(); ok {
		m.AltDocuments = val
	}

	if val, ok := from.GetVideoCover(); ok {
		m.VideoCover = val
	}

	if val, ok := from.GetVideoTimestamp(); ok {
		m.VideoTimestamp = val
	}

	if val, ok := from.GetTTLSeconds(); ok {
		m.TTLSeconds = val
	}

}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageMediaDocument) TypeID() uint32 {
	return MessageMediaDocumentTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageMediaDocument) TypeName() string {
	return "messageMediaDocument"
}

// TypeInfo returns info about TL type.
func (m *MessageMediaDocument) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageMediaDocument",
		ID:   MessageMediaDocumentTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Nopremium",
			SchemaName: "nopremium",
			Null:       !m.Flags.Has(3),
		},
		{
			Name:       "Spoiler",
			SchemaName: "spoiler",
			Null:       !m.Flags.Has(4),
		},
		{
			Name:       "Video",
			SchemaName: "video",
			Null:       !m.Flags.Has(6),
		},
		{
			Name:       "Round",
			SchemaName: "round",
			Null:       !m.Flags.Has(7),
		},
		{
			Name:       "Voice",
			SchemaName: "voice",
			Null:       !m.Flags.Has(8),
		},
		{
			Name:       "Document",
			SchemaName: "document",
			Null:       !m.Flags.Has(0),
		},
		{
			Name:       "AltDocuments",
			SchemaName: "alt_documents",
			Null:       !m.Flags.Has(5),
		},
		{
			Name:       "VideoCover",
			SchemaName: "video_cover",
			Null:       !m.Flags.Has(9),
		},
		{
			Name:       "VideoTimestamp",
			SchemaName: "video_timestamp",
			Null:       !m.Flags.Has(10),
		},
		{
			Name:       "TTLSeconds",
			SchemaName: "ttl_seconds",
			Null:       !m.Flags.Has(2),
		},
	}
	return typ
}

// SetFlags sets flags for non-zero fields.
func (m *MessageMediaDocument) SetFlags() {
	if !(m.Nopremium == false) {
		m.Flags.Set(3)
	}
	if !(m.Spoiler == false) {
		m.Flags.Set(4)
	}
	if !(m.Video == false) {
		m.Flags.Set(6)
	}
	if !(m.Round == false) {
		m.Flags.Set(7)
	}
	if !(m.Voice == false) {
		m.Flags.Set(8)
	}
	if !(m.Document == nil) {
		m.Flags.Set(0)
	}
	if !(m.AltDocuments == nil) {
		m.Flags.Set(5)
	}
	if !(m.VideoCover == nil) {
		m.Flags.Set(9)
	}
	if !(m.VideoTimestamp == 0) {
		m.Flags.Set(10)
	}
	if !(m.TTLSeconds == 0) {
		m.Flags.Set(2)
	}
}

// Encode implements bin.Encoder.
func (m *MessageMediaDocument) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageMediaDocument#52d8ccd9 as nil")
	}
	b.PutID(MessageMediaDocumentTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageMediaDocument) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageMediaDocument#52d8ccd9 as nil")
	}
	m.SetFlags()
	if err := m.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageMediaDocument#52d8ccd9: field flags: %w", err)
	}
	if m.Flags.Has(0) {
		if m.Document == nil {
			return fmt.Errorf("unable to encode messageMediaDocument#52d8ccd9: field document is nil")
		}
		if err := m.Document.Encode(b); err != nil {
			return fmt.Errorf("unable to encode messageMediaDocument#52d8ccd9: field document: %w", err)
		}
	}
	if m.Flags.Has(5) {
		b.PutVectorHeader(len(m.AltDocuments))
		for idx, v := range m.AltDocuments {
			if v == nil {
				return fmt.Errorf("unable to encode messageMediaDocument#52d8ccd9: field alt_documents element with index %d is nil", idx)
			}
			if err := v.Encode(b); err != nil {
				return fmt.Errorf("unable to encode messageMediaDocument#52d8ccd9: field alt_documents element with index %d: %w", idx, err)
			}
		}
	}
	if m.Flags.Has(9) {
		if m.VideoCover == nil {
			return fmt.Errorf("unable to encode messageMediaDocument#52d8ccd9: field video_cover is nil")
		}
		if err := m.VideoCover.Encode(b); err != nil {
			return fmt.Errorf("unable to encode messageMediaDocument#52d8ccd9: field video_cover: %w", err)
		}
	}
	if m.Flags.Has(10) {
		b.PutInt(m.VideoTimestamp)
	}
	if m.Flags.Has(2) {
		b.PutInt(m.TTLSeconds)
	}
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageMediaDocument) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageMediaDocument#52d8ccd9 to nil")
	}
	if err := b.ConsumeID(MessageMediaDocumentTypeID); err != nil {
		return fmt.Errorf("unable to decode messageMediaDocument#52d8ccd9: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageMediaDocument) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageMediaDocument#52d8ccd9 to nil")
	}
	{
		if err := m.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messageMediaDocument#52d8ccd9: field flags: %w", err)
		}
	}
	m.Nopremium = m.Flags.Has(3)
	m.Spoiler = m.Flags.Has(4)
	m.Video = m.Flags.Has(6)
	m.Round = m.Flags.Has(7)
	m.Voice = m.Flags.Has(8)
	if m.Flags.Has(0) {
		value, err := DecodeDocument(b)
		if err != nil {
			return fmt.Errorf("unable to decode messageMediaDocument#52d8ccd9: field document: %w", err)
		}
		m.Document = value
	}
	if m.Flags.Has(5) {
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode messageMediaDocument#52d8ccd9: field alt_documents: %w", err)
		}

		if headerLen > 0 {
			m.AltDocuments = make([]DocumentClass, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := DecodeDocument(b)
			if err != nil {
				return fmt.Errorf("unable to decode messageMediaDocument#52d8ccd9: field alt_documents: %w", err)
			}
			m.AltDocuments = append(m.AltDocuments, value)
		}
	}
	if m.Flags.Has(9) {
		value, err := DecodePhoto(b)
		if err != nil {
			return fmt.Errorf("unable to decode messageMediaDocument#52d8ccd9: field video_cover: %w", err)
		}
		m.VideoCover = value
	}
	if m.Flags.Has(10) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode messageMediaDocument#52d8ccd9: field video_timestamp: %w", err)
		}
		m.VideoTimestamp = value
	}
	if m.Flags.Has(2) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode messageMediaDocument#52d8ccd9: field ttl_seconds: %w", err)
		}
		m.TTLSeconds = value
	}
	return nil
}

// SetNopremium sets value of Nopremium conditional field.
func (m *MessageMediaDocument) SetNopremium(value bool) {
	if value {
		m.Flags.Set(3)
		m.Nopremium = true
	} else {
		m.Flags.Unset(3)
		m.Nopremium = false
	}
}

// GetNopremium returns value of Nopremium conditional field.
func (m *MessageMediaDocument) GetNopremium() (value bool) {
	if m == nil {
		return
	}
	return m.Flags.Has(3)
}

// SetSpoiler sets value of Spoiler conditional field.
func (m *MessageMediaDocument) SetSpoiler(value bool) {
	if value {
		m.Flags.Set(4)
		m.Spoiler = true
	} else {
		m.Flags.Unset(4)
		m.Spoiler = false
	}
}

// GetSpoiler returns value of Spoiler conditional field.
func (m *MessageMediaDocument) GetSpoiler() (value bool) {
	if m == nil {
		return
	}
	return m.Flags.Has(4)
}

// SetVideo sets value of Video conditional field.
func (m *MessageMediaDocument) SetVideo(value bool) {
	if value {
		m.Flags.Set(6)
		m.Video = true
	} else {
		m.Flags.Unset(6)
		m.Video = false
	}
}

// GetVideo returns value of Video conditional field.
func (m *MessageMediaDocument) GetVideo() (value bool) {
	if m == nil {
		return
	}
	return m.Flags.Has(6)
}

// SetRound sets value of Round conditional field.
func (m *MessageMediaDocument) SetRound(value bool) {
	if value {
		m.Flags.Set(7)
		m.Round = true
	} else {
		m.Flags.Unset(7)
		m.Round = false
	}
}

// GetRound returns value of Round conditional field.
func (m *MessageMediaDocument) GetRound() (value bool) {
	if m == nil {
		return
	}
	return m.Flags.Has(7)
}

// SetVoice sets value of Voice conditional field.
func (m *MessageMediaDocument) SetVoice(value bool) {
	if value {
		m.Flags.Set(8)
		m.Voice = true
	} else {
		m.Flags.Unset(8)
		m.Voice = false
	}
}

// GetVoice returns value of Voice conditional field.
func (m *MessageMediaDocument) GetVoice() (value bool) {
	if m == nil {
		return
	}
	return m.Flags.Has(8)
}

// SetDocument sets value of Document conditional field.
func (m *MessageMediaDocument) SetDocument(value DocumentClass) {
	m.Flags.Set(0)
	m.Document = value
}

// GetDocument returns value of Document conditional field and
// boolean which is true if field was set.
func (m *MessageMediaDocument) GetDocument() (value DocumentClass, ok bool) {
	if m == nil {
		return
	}
	if !m.Flags.Has(0) {
		return value, false
	}
	return m.Document, true
}

// SetAltDocuments sets value of AltDocuments conditional field.
func (m *MessageMediaDocument) SetAltDocuments(value []DocumentClass) {
	m.Flags.Set(5)
	m.AltDocuments = value
}

// GetAltDocuments returns value of AltDocuments conditional field and
// boolean which is true if field was set.
func (m *MessageMediaDocument) GetAltDocuments() (value []DocumentClass, ok bool) {
	if m == nil {
		return
	}
	if !m.Flags.Has(5) {
		return value, false
	}
	return m.AltDocuments, true
}

// SetVideoCover sets value of VideoCover conditional field.
func (m *MessageMediaDocument) SetVideoCover(value PhotoClass) {
	m.Flags.Set(9)
	m.VideoCover = value
}

// GetVideoCover returns value of VideoCover conditional field and
// boolean which is true if field was set.
func (m *MessageMediaDocument) GetVideoCover() (value PhotoClass, ok bool) {
	if m == nil {
		return
	}
	if !m.Flags.Has(9) {
		return value, false
	}
	return m.VideoCover, true
}

// SetVideoTimestamp sets value of VideoTimestamp conditional field.
func (m *MessageMediaDocument) SetVideoTimestamp(value int) {
	m.Flags.Set(10)
	m.VideoTimestamp = value
}

// GetVideoTimestamp returns value of VideoTimestamp conditional field and
// boolean which is true if field was set.
func (m *MessageMediaDocument) GetVideoTimestamp() (value int, ok bool) {
	if m == nil {
		return
	}
	if !m.Flags.Has(10) {
		return value, false
	}
	return m.VideoTimestamp, true
}

// SetTTLSeconds sets value of TTLSeconds conditional field.
func (m *MessageMediaDocument) SetTTLSeconds(value int) {
	m.Flags.Set(2)
	m.TTLSeconds = value
}

// GetTTLSeconds returns value of TTLSeconds conditional field and
// boolean which is true if field was set.
func (m *MessageMediaDocument) GetTTLSeconds() (value int, ok bool) {
	if m == nil {
		return
	}
	if !m.Flags.Has(2) {
		return value, false
	}
	return m.TTLSeconds, true
}

// MapAltDocuments returns field AltDocuments wrapped in DocumentClassArray helper.
func (m *MessageMediaDocument) MapAltDocuments() (value DocumentClassArray, ok bool) {
	if !m.Flags.Has(5) {
		return value, false
	}
	return DocumentClassArray(m.AltDocuments), true
}

// MessageMediaWebPage represents TL type `messageMediaWebPage#ddf10c3b`.
// Preview of webpage
//
// See https://core.telegram.org/constructor/messageMediaWebPage for reference.
type MessageMediaWebPage struct {
	// Flags, see TL conditional fieldsÂ¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// If set, specifies that a large media preview should be used.
	ForceLargeMedia bool
	// If set, specifies that a small media preview should be used.
	ForceSmallMedia bool
	// If set, indicates that the URL used for the webpage preview was specified manually
	// using inputMediaWebPageÂ¹, and may not be related to any of the URLs specified in the
	// message.
	//
	// Links:
	//  1) https://core.telegram.org/constructor/inputMediaWebPage
	Manual bool
	// If set, the webpage can be opened directly without user confirmation; otherwise, user
	// confirmation is required, showing the exact URL that will be opened.
	Safe bool
	// Webpage preview
	Webpage WebPageClass
}

// MessageMediaWebPageTypeID is TL type id of MessageMediaWebPage.
const MessageMediaWebPageTypeID = 0xddf10c3b

// construct implements constructor of MessageMediaClass.
func (m MessageMediaWebPage) construct() MessageMediaClass { return &m }

// Ensuring interfaces in compile-time for MessageMediaWebPage.
var (
	_ bin.Encoder     = &MessageMediaWebPage{}
	_ bin.Decoder     = &MessageMediaWebPage{}
	_ bin.BareEncoder = &MessageMediaWebPage{}
	_ bin.BareDecoder = &MessageMediaWebPage{}

	_ MessageMediaClass = &MessageMediaWebPage{}
)

func (m *MessageMediaWebPage) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.Flags.Zero()) {
		return false
	}
	if !(m.ForceLargeMedia == false) {
		return false
	}
	if !(m.ForceSmallMedia == false) {
		return false
	}
	if !(m.Manual == false) {
		return false
	}
	if !(m.Safe == false) {
		return false
	}
	if !(m.Webpage == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageMediaWebPage) String() string {
	if m == nil {
		return "MessageMediaWebPage(nil)"
	}
	type Alias MessageMediaWebPage
	return fmt.Sprintf("MessageMediaWebPage%+v", Alias(*m))
}

// FillFrom fills MessageMediaWebPage from given interface.
func (m *MessageMediaWebPage) FillFrom(from interface {
	GetForceLargeMedia() (value bool)
	GetForceSmallMedia() (value bool)
	GetManual() (value bool)
	GetSafe() (value bool)
	GetWebpage() (value WebPageClass)
}) {
	m.ForceLargeMedia = from.GetForceLargeMedia()
	m.ForceSmallMedia = from.GetForceSmallMedia()
	m.Manual = from.GetManual()
	m.Safe = from.GetSafe()
	m.Webpage = from.GetWebpage()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageMediaWebPage) TypeID() uint32 {
	return MessageMediaWebPageTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageMediaWebPage) TypeName() string {
	return "messageMediaWebPage"
}

// TypeInfo returns info about TL type.
func (m *MessageMediaWebPage) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageMediaWebPage",
		ID:   MessageMediaWebPageTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ForceLargeMedia",
			SchemaName: "force_large_media",
			Null:       !m.Flags.Has(0),
		},
		{
			Name:       "ForceSmallMedia",
			SchemaName: "force_small_media",
			Null:       !m.Flags.Has(1),
		},
		{
			Name:       "Manual",
			SchemaName: "manual",
			Null:       !m.Flags.Has(3),
		},
		{
			Name:       "Safe",
			SchemaName: "safe",
			Null:       !m.Flags.Has(4),
		},
		{
			Name:       "Webpage",
			SchemaName: "webpage",
		},
	}
	return typ
}

// SetFlags sets flags for non-zero fields.
func (m *MessageMediaWebPage) SetFlags() {
	if !(m.ForceLargeMedia == false) {
		m.Flags.Set(0)
	}
	if !(m.ForceSmallMedia == false) {
		m.Flags.Set(1)
	}
	if !(m.Manual == false) {
		m.Flags.Set(3)
	}
	if !(m.Safe == false) {
		m.Flags.Set(4)
	}
}

// Encode implements bin.Encoder.
func (m *MessageMediaWebPage) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageMediaWebPage#ddf10c3b as nil")
	}
	b.PutID(MessageMediaWebPageTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageMediaWebPage) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageMediaWebPage#ddf10c3b as nil")
	}
	m.SetFlags()
	if err := m.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageMediaWebPage#ddf10c3b: field flags: %w", err)
	}
	if m.Webpage == nil {
		return fmt.Errorf("unable to encode messageMediaWebPage#ddf10c3b: field webpage is nil")
	}
	if err := m.Webpage.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageMediaWebPage#ddf10c3b: field webpage: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageMediaWebPage) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageMediaWebPage#ddf10c3b to nil")
	}
	if err := b.ConsumeID(MessageMediaWebPageTypeID); err != nil {
		return fmt.Errorf("unable to decode messageMediaWebPage#ddf10c3b: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageMediaWebPage) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageMediaWebPage#ddf10c3b to nil")
	}
	{
		if err := m.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messageMediaWebPage#ddf10c3b: field flags: %w", err)
		}
	}
	m.ForceLargeMedia = m.Flags.Has(0)
	m.ForceSmallMedia = m.Flags.Has(1)
	m.Manual = m.Flags.Has(3)
	m.Safe = m.Flags.Has(4)
	{
		value, err := DecodeWebPage(b)
		if err != nil {
			return fmt.Errorf("unable to decode messageMediaWebPage#ddf10c3b: field webpage: %w", err)
		}
		m.Webpage = value
	}
	return nil
}

// SetForceLargeMedia sets value of ForceLargeMedia conditional field.
func (m *MessageMediaWebPage) SetForceLargeMedia(value bool) {
	if value {
		m.Flags.Set(0)
		m.ForceLargeMedia = true
	} else {
		m.Flags.Unset(0)
		m.ForceLargeMedia = false
	}
}

// GetForceLargeMedia returns value of ForceLargeMedia conditional field.
func (m *MessageMediaWebPage) GetForceLargeMedia() (value bool) {
	if m == nil {
		return
	}
	return m.Flags.Has(0)
}

// SetForceSmallMedia sets value of ForceSmallMedia conditional field.
func (m *MessageMediaWebPage) SetForceSmallMedia(value bool) {
	if value {
		m.Flags.Set(1)
		m.ForceSmallMedia = true
	} else {
		m.Flags.Unset(1)
		m.ForceSmallMedia = false
	}
}

// GetForceSmallMedia returns value of ForceSmallMedia conditional field.
func (m *MessageMediaWebPage) GetForceSmallMedia() (value bool) {
	if m == nil {
		return
	}
	return m.Flags.Has(1)
}

// SetManual sets value of Manual conditional field.
func (m *MessageMediaWebPage) SetManual(value bool) {
	if value {
		m.Flags.Set(3)
		m.Manual = true
	} else {
		m.Flags.Unset(3)
		m.Manual = false
	}
}

// GetManual returns value of Manual conditional field.
func (m *MessageMediaWebPage) GetManual() (value bool) {
	if m == nil {
		return
	}
	return m.Flags.Has(3)
}

// SetSafe sets value of Safe conditional field.
func (m *MessageMediaWebPage) SetSafe(value bool) {
	if value {
		m.Flags.Set(4)
		m.Safe = true
	} else {
		m.Flags.Unset(4)
		m.Safe = false
	}
}

// GetSafe returns value of Safe conditional field.
func (m *MessageMediaWebPage) GetSafe() (value bool) {
	if m == nil {
		return
	}
	return m.Flags.Has(4)
}

// GetWebpage returns value of Webpage field.
func (m *MessageMediaWebPage) GetWebpage() (value WebPageClass) {
	if m == nil {
		return
	}
	return m.Webpage
}

// MessageMediaVenue represents TL type `messageMediaVenue#2ec0533f`.
// Venue
//
// See https://core.telegram.org/constructor/messageMediaVenue for reference.
type MessageMediaVenue struct {
	// Geolocation of venue
	Geo GeoPointClass
	// Venue name
	Title string
	// Address
	Address string
	// Venue provider: currently only "foursquare" and "gplaces" (Google Places) need to be
	// supported
	Provider string
	// Venue ID in the provider's database
	VenueID string
	// Venue type in the provider's database
	VenueType string
}

// MessageMediaVenueTypeID is TL type id of MessageMediaVenue.
const MessageMediaVenueTypeID = 0x2ec0533f

// construct implements constructor of MessageMediaClass.
func (m MessageMediaVenue) construct() MessageMediaClass { return &m }

// Ensuring interfaces in compile-time for MessageMediaVenue.
var (
	_ bin.Encoder     = &MessageMediaVenue{}
	_ bin.Decoder     = &MessageMediaVenue{}
	_ bin.BareEncoder = &MessageMediaVenue{}
	_ bin.BareDecoder = &MessageMediaVenue{}

	_ MessageMediaClass = &MessageMediaVenue{}
)

func (m *MessageMediaVenue) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.Geo == nil) {
		return false
	}
	if !(m.Title == "") {
		return false
	}
	if !(m.Address == "") {
		return false
	}
	if !(m.Provider == "") {
		return false
	}
	if !(m.VenueID == "") {
		return false
	}
	if !(m.VenueType == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageMediaVenue) String() string {
	if m == nil {
		return "MessageMediaVenue(nil)"
	}
	type Alias MessageMediaVenue
	return fmt.Sprintf("MessageMediaVenue%+v", Alias(*m))
}

// FillFrom fills MessageMediaVenue from given interface.
func (m *MessageMediaVenue) FillFrom(from interface {
	GetGeo() (value GeoPointClass)
	GetTitle() (value string)
	GetAddress() (value string)
	GetProvider() (value string)
	GetVenueID() (value string)
	GetVenueType() (value string)
}) {
	m.Geo = from.GetGeo()
	m.Title = from.GetTitle()
	m.Address = from.GetAddress()
	m.Provider = from.GetProvider()
	m.VenueID = from.GetVenueID()
	m.VenueType = from.GetVenueType()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageMediaVenue) TypeID() uint32 {
	return MessageMediaVenueTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageMediaVenue) TypeName() string {
	return "messageMediaVenue"
}

// TypeInfo returns info about TL type.
func (m *MessageMediaVenue) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageMediaVenue",
		ID:   MessageMediaVenueTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Geo",
			SchemaName: "geo",
		},
		{
			Name:       "Title",
			SchemaName: "title",
		},
		{
			Name:       "Address",
			SchemaName: "address",
		},
		{
			Name:       "Provider",
			SchemaName: "provider",
		},
		{
			Name:       "VenueID",
			SchemaName: "venue_id",
		},
		{
			Name:       "VenueType",
			SchemaName: "venue_type",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageMediaVenue) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageMediaVenue#2ec0533f as nil")
	}
	b.PutID(MessageMediaVenueTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageMediaVenue) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageMediaVenue#2ec0533f as nil")
	}
	if m.Geo == nil {
		return fmt.Errorf("unable to encode messageMediaVenue#2ec0533f: field geo is nil")
	}
	if err := m.Geo.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageMediaVenue#2ec0533f: field geo: %w", err)
	}
	b.PutString(m.Title)
	b.PutString(m.Address)
	b.PutString(m.Provider)
	b.PutString(m.VenueID)
	b.PutString(m.VenueType)
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageMediaVenue) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageMediaVenue#2ec0533f to nil")
	}
	if err := b.ConsumeID(MessageMediaVenueTypeID); err != nil {
		return fmt.Errorf("unable to decode messageMediaVenue#2ec0533f: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageMediaVenue) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageMediaVenue#2ec0533f to nil")
	}
	{
		value, err := DecodeGeoPoint(b)
		if err != nil {
			return fmt.Errorf("unable to decode messageMediaVenue#2ec0533f: field geo: %w", err)
		}
		m.Geo = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode messageMediaVenue#2ec0533f: field title: %w", err)
		}
		m.Title = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode messageMediaVenue#2ec0533f: field address: %w", err)
		}
		m.Address = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode messageMediaVenue#2ec0533f: field provider: %w", err)
		}
		m.Provider = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode messageMediaVenue#2ec0533f: field venue_id: %w", err)
		}
		m.VenueID = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode messageMediaVenue#2ec0533f: field venue_type: %w", err)
		}
		m.VenueType = value
	}
	return nil
}

// GetGeo returns value of Geo field.
func (m *MessageMediaVenue) GetGeo() (value GeoPointClass) {
	if m == nil {
		return
	}
	return m.Geo
}

// GetTitle returns value of Title field.
func (m *MessageMediaVenue) GetTitle() (value string) {
	if m == nil {
		return
	}
	return m.Title
}

// GetAddress returns value of Address field.
func (m *MessageMediaVenue) GetAddress() (value string) {
	if m == nil {
		return
	}
	return m.Address
}

// GetProvider returns value of Provider field.
func (m *MessageMediaVenue) GetProvider() (value string) {
	if m == nil {
		return
	}
	return m.Provider
}

// GetVenueID returns value of VenueID field.
func (m *MessageMediaVenue) GetVenueID() (value string) {
	if m == nil {
		return
	}
	return m.VenueID
}

// GetVenueType returns value of VenueType field.
func (m *MessageMediaVenue) GetVenueType() (value string) {
	if m == nil {
		return
	}
	return m.VenueType
}

// MessageMediaGame represents TL type `messageMediaGame#fdb19008`.
// Telegram game
//
// See https://core.telegram.org/constructor/messageMediaGame for reference.
type MessageMediaGame struct {
	// Game
	Game Game
}

// MessageMediaGameTypeID is TL type id of MessageMediaGame.
const MessageMediaGameTypeID = 0xfdb19008

// construct implements constructor of MessageMediaClass.
func (m MessageMediaGame) construct() MessageMediaClass { return &m }

// Ensuring interfaces in compile-time for MessageMediaGame.
var (
	_ bin.Encoder     = &MessageMediaGame{}
	_ bin.Decoder     = &MessageMediaGame{}
	_ bin.BareEncoder = &MessageMediaGame{}
	_ bin.BareDecoder = &MessageMediaGame{}

	_ MessageMediaClass = &MessageMediaGame{}
)

func (m *MessageMediaGame) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.Game.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageMediaGame) String() string {
	if m == nil {
		return "MessageMediaGame(nil)"
	}
	type Alias MessageMediaGame
	return fmt.Sprintf("MessageMediaGame%+v", Alias(*m))
}

// FillFrom fills MessageMediaGame from given interface.
func (m *MessageMediaGame) FillFrom(from interface {
	GetGame() (value Game)
}) {
	m.Game = from.GetGame()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageMediaGame) TypeID() uint32 {
	return MessageMediaGameTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageMediaGame) TypeName() string {
	return "messageMediaGame"
}

// TypeInfo returns info about TL type.
func (m *MessageMediaGame) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageMediaGame",
		ID:   MessageMediaGameTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Game",
			SchemaName: "game",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageMediaGame) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageMediaGame#fdb19008 as nil")
	}
	b.PutID(MessageMediaGameTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageMediaGame) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageMediaGame#fdb19008 as nil")
	}
	if err := m.Game.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageMediaGame#fdb19008: field game: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageMediaGame) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageMediaGame#fdb19008 to nil")
	}
	if err := b.ConsumeID(MessageMediaGameTypeID); err != nil {
		return fmt.Errorf("unable to decode messageMediaGame#fdb19008: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageMediaGame) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageMediaGame#fdb19008 to nil")
	}
	{
		if err := m.Game.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messageMediaGame#fdb19008: field game: %w", err)
		}
	}
	return nil
}

// GetGame returns value of Game field.
func (m *MessageMediaGame) GetGame() (value Game) {
	if m == nil {
		return
	}
	return m.Game
}

// MessageMediaInvoice represents TL type `messageMediaInvoice#f6a548d3`.
// Invoice
//
// See https://core.telegram.org/constructor/messageMediaInvoice for reference.
type MessageMediaInvoice struct {
	// Flags, see TL conditional fieldsÂ¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// Whether the shipping address was requested
	ShippingAddressRequested bool
	// Whether this is an example invoice
	Test bool
	// Product name, 1-32 characters
	Title string
	// Product description, 1-255 characters
	Description string
	// URL of the product photo for the invoice. Can be a photo of the goods or a marketing
	// image for a service. People like it better when they see what they are paying for.
	//
	// Use SetPhoto and GetPhoto helpers.
	Photo WebDocumentClass
	// Message ID of receipt: if set, clients should change the text of the first
	// keyboardButtonBuyÂ¹ button always attached to the messageÂ² to a localized version of
	// the word Receipt
	//
	// Links:
	//  1) https://core.telegram.org/constructor/keyboardButtonBuy
	//  2) https://core.telegram.org/constructor/message
	//
	// Use SetReceiptMsgID and GetReceiptMsgID helpers.
	ReceiptMsgID int
	// Three-letter ISO 4217 currencyÂ¹ code, or XTR for Telegram StarsÂ².
	//
	// Links:
	//  1) https://core.telegram.org/bots/payments#supported-currencies
	//  2) https://core.telegram.org/api/stars
	Currency string
	// Total price in the smallest units of the currency (integer, not float/double). For
	// example, for a price of US$ 1.45 pass amount = 145. See the exp parameter in
	// currencies.jsonÂ¹, it shows the number of digits past the decimal point for each
	// currency (2 for the majority of currencies).
	//
	// Links:
	//  1) https://core.telegram.org/bots/payments/currencies.json
	TotalAmount int64
	// Unique bot deep-linking parameter that can be used to generate this invoice
	StartParam string
	// Deprecated
	//
	// Use SetExtendedMedia and GetExtendedMedia helpers.
	ExtendedMedia MessageExtendedMediaClass
}

// MessageMediaInvoiceTypeID is TL type id of MessageMediaInvoice.
const MessageMediaInvoiceTypeID = 0xf6a548d3

// construct implements constructor of MessageMediaClass.
func (m MessageMediaInvoice) construct() MessageMediaClass { return &m }

// Ensuring interfaces in compile-time for MessageMediaInvoice.
var (
	_ bin.Encoder     = &MessageMediaInvoice{}
	_ bin.Decoder     = &MessageMediaInvoice{}
	_ bin.BareEncoder = &MessageMediaInvoice{}
	_ bin.BareDecoder = &MessageMediaInvoice{}

	_ MessageMediaClass = &MessageMediaInvoice{}
)

func (m *MessageMediaInvoice) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.Flags.Zero()) {
		return false
	}
	if !(m.ShippingAddressRequested == false) {
		return false
	}
	if !(m.Test == false) {
		return false
	}
	if !(m.Title == "") {
		return false
	}
	if !(m.Description == "") {
		return false
	}
	if !(m.Photo == nil) {
		return false
	}
	if !(m.ReceiptMsgID == 0) {
		return false
	}
	if !(m.Currency == "") {
		return false
	}
	if !(m.TotalAmount == 0) {
		return false
	}
	if !(m.StartParam == "") {
		return false
	}
	if !(m.ExtendedMedia == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageMediaInvoice) String() string {
	if m == nil {
		return "MessageMediaInvoice(nil)"
	}
	type Alias MessageMediaInvoice
	return fmt.Sprintf("MessageMediaInvoice%+v", Alias(*m))
}

// FillFrom fills MessageMediaInvoice from given interface.
func (m *MessageMediaInvoice) FillFrom(from interface {
	GetShippingAddressRequested() (value bool)
	GetTest() (value bool)
	GetTitle() (value string)
	GetDescription() (value string)
	GetPhoto() (value WebDocumentClass, ok bool)
	GetReceiptMsgID() (value int, ok bool)
	GetCurrency() (value string)
	GetTotalAmount() (value int64)
	GetStartParam() (value string)
	GetExtendedMedia() (value MessageExtendedMediaClass, ok bool)
}) {
	m.ShippingAddressRequested = from.GetShippingAddressRequested()
	m.Test = from.GetTest()
	m.Title = from.GetTitle()
	m.Description = from.GetDescription()
	if val, ok := from.GetPhoto(); ok {
		m.Photo = val
	}

	if val, ok := from.GetReceiptMsgID(); ok {
		m.ReceiptMsgID = val
	}

	m.Currency = from.GetCurrency()
	m.TotalAmount = from.GetTotalAmount()
	m.StartParam = from.GetStartParam()
	if val, ok := from.GetExtendedMedia(); ok {
		m.ExtendedMedia = val
	}

}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageMediaInvoice) TypeID() uint32 {
	return MessageMediaInvoiceTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageMediaInvoice) TypeName() string {
	return "messageMediaInvoice"
}

// TypeInfo returns info about TL type.
func (m *MessageMediaInvoice) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageMediaInvoice",
		ID:   MessageMediaInvoiceTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ShippingAddressRequested",
			SchemaName: "shipping_address_requested",
			Null:       !m.Flags.Has(1),
		},
		{
			Name:       "Test",
			SchemaName: "test",
			Null:       !m.Flags.Has(3),
		},
		{
			Name:       "Title",
			SchemaName: "title",
		},
		{
			Name:       "Description",
			SchemaName: "description",
		},
		{
			Name:       "Photo",
			SchemaName: "photo",
			Null:       !m.Flags.Has(0),
		},
		{
			Name:       "ReceiptMsgID",
			SchemaName: "receipt_msg_id",
			Null:       !m.Flags.Has(2),
		},
		{
			Name:       "Currency",
			SchemaName: "currency",
		},
		{
			Name:       "TotalAmount",
			SchemaName: "total_amount",
		},
		{
			Name:       "StartParam",
			SchemaName: "start_param",
		},
		{
			Name:       "ExtendedMedia",
			SchemaName: "extended_media",
			Null:       !m.Flags.Has(4),
		},
	}
	return typ
}

// SetFlags sets flags for non-zero fields.
func (m *MessageMediaInvoice) SetFlags() {
	if !(m.ShippingAddressRequested == false) {
		m.Flags.Set(1)
	}
	if !(m.Test == false) {
		m.Flags.Set(3)
	}
	if !(m.Photo == nil) {
		m.Flags.Set(0)
	}
	if !(m.ReceiptMsgID == 0) {
		m.Flags.Set(2)
	}
	if !(m.ExtendedMedia == nil) {
		m.Flags.Set(4)
	}
}

// Encode implements bin.Encoder.
func (m *MessageMediaInvoice) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageMediaInvoice#f6a548d3 as nil")
	}
	b.PutID(MessageMediaInvoiceTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageMediaInvoice) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageMediaInvoice#f6a548d3 as nil")
	}
	m.SetFlags()
	if err := m.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageMediaInvoice#f6a548d3: field flags: %w", err)
	}
	b.PutString(m.Title)
	b.PutString(m.Description)
	if m.Flags.Has(0) {
		if m.Photo == nil {
			return fmt.Errorf("unable to encode messageMediaInvoice#f6a548d3: field photo is nil")
		}
		if err := m.Photo.Encode(b); err != nil {
			return fmt.Errorf("unable to encode messageMediaInvoice#f6a548d3: field photo: %w", err)
		}
	}
	if m.Flags.Has(2) {
		b.PutInt(m.ReceiptMsgID)
	}
	b.PutString(m.Currency)
	b.PutLong(m.TotalAmount)
	b.PutString(m.StartParam)
	if m.Flags.Has(4) {
		if m.ExtendedMedia == nil {
			return fmt.Errorf("unable to encode messageMediaInvoice#f6a548d3: field extended_media is nil")
		}
		if err := m.ExtendedMedia.Encode(b); err != nil {
			return fmt.Errorf("unable to encode messageMediaInvoice#f6a548d3: field extended_media: %w", err)
		}
	}
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageMediaInvoice) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageMediaInvoice#f6a548d3 to nil")
	}
	if err := b.ConsumeID(MessageMediaInvoiceTypeID); err != nil {
		return fmt.Errorf("unable to decode messageMediaInvoice#f6a548d3: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageMediaInvoice) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageMediaInvoice#f6a548d3 to nil")
	}
	{
		if err := m.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messageMediaInvoice#f6a548d3: field flags: %w", err)
		}
	}
	m.ShippingAddressRequested = m.Flags.Has(1)
	m.Test = m.Flags.Has(3)
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode messageMediaInvoice#f6a548d3: field title: %w", err)
		}
		m.Title = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode messageMediaInvoice#f6a548d3: field description: %w", err)
		}
		m.Description = value
	}
	if m.Flags.Has(0) {
		value, err := DecodeWebDocument(b)
		if err != nil {
			return fmt.Errorf("unable to decode messageMediaInvoice#f6a548d3: field photo: %w", err)
		}
		m.Photo = value
	}
	if m.Flags.Has(2) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode messageMediaInvoice#f6a548d3: field receipt_msg_id: %w", err)
		}
		m.ReceiptMsgID = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode messageMediaInvoice#f6a548d3: field currency: %w", err)
		}
		m.Currency = value
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode messageMediaInvoice#f6a548d3: field total_amount: %w", err)
		}
		m.TotalAmount = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode messageMediaInvoice#f6a548d3: field start_param: %w", err)
		}
		m.StartParam = value
	}
	if m.Flags.Has(4) {
		value, err := DecodeMessageExtendedMedia(b)
		if err != nil {
			return fmt.Errorf("unable to decode messageMediaInvoice#f6a548d3: field extended_media: %w", err)
		}
		m.ExtendedMedia = value
	}
	return nil
}

// SetShippingAddressRequested sets value of ShippingAddressRequested conditional field.
func (m *MessageMediaInvoice) SetShippingAddressRequested(value bool) {
	if value {
		m.Flags.Set(1)
		m.ShippingAddressRequested = true
	} else {
		m.Flags.Unset(1)
		m.ShippingAddressRequested = false
	}
}

// GetShippingAddressRequested returns value of ShippingAddressRequested conditional field.
func (m *MessageMediaInvoice) GetShippingAddressRequested() (value bool) {
	if m == nil {
		return
	}
	return m.Flags.Has(1)
}

// SetTest sets value of Test conditional field.
func (m *MessageMediaInvoice) SetTest(value bool) {
	if value {
		m.Flags.Set(3)
		m.Test = true
	} else {
		m.Flags.Unset(3)
		m.Test = false
	}
}

// GetTest returns value of Test conditional field.
func (m *MessageMediaInvoice) GetTest() (value bool) {
	if m == nil {
		return
	}
	return m.Flags.Has(3)
}

// GetTitle returns value of Title field.
func (m *MessageMediaInvoice) GetTitle() (value string) {
	if m == nil {
		return
	}
	return m.Title
}

// GetDescription returns value of Description field.
func (m *MessageMediaInvoice) GetDescription() (value string) {
	if m == nil {
		return
	}
	return m.Description
}

// SetPhoto sets value of Photo conditional field.
func (m *MessageMediaInvoice) SetPhoto(value WebDocumentClass) {
	m.Flags.Set(0)
	m.Photo = value
}

// GetPhoto returns value of Photo conditional field and
// boolean which is true if field was set.
func (m *MessageMediaInvoice) GetPhoto() (value WebDocumentClass, ok bool) {
	if m == nil {
		return
	}
	if !m.Flags.Has(0) {
		return value, false
	}
	return m.Photo, true
}

// SetReceiptMsgID sets value of ReceiptMsgID conditional field.
func (m *MessageMediaInvoice) SetReceiptMsgID(value int) {
	m.Flags.Set(2)
	m.ReceiptMsgID = value
}

// GetReceiptMsgID returns value of ReceiptMsgID conditional field and
// boolean which is true if field was set.
func (m *MessageMediaInvoice) GetReceiptMsgID() (value int, ok bool) {
	if m == nil {
		return
	}
	if !m.Flags.Has(2) {
		return value, false
	}
	return m.ReceiptMsgID, true
}

// GetCurrency returns value of Currency field.
func (m *MessageMediaInvoice) GetCurrency() (value string) {
	if m == nil {
		return
	}
	return m.Currency
}

// GetTotalAmount returns value of TotalAmount field.
func (m *MessageMediaInvoice) GetTotalAmount() (value int64) {
	if m == nil {
		return
	}
	return m.TotalAmount
}

// GetStartParam returns value of StartParam field.
func (m *MessageMediaInvoice) GetStartParam() (value string) {
	if m == nil {
		return
	}
	return m.StartParam
}

// SetExtendedMedia sets value of ExtendedMedia conditional field.
func (m *MessageMediaInvoice) SetExtendedMedia(value MessageExtendedMediaClass) {
	m.Flags.Set(4)
	m.ExtendedMedia = value
}

// GetExtendedMedia returns value of ExtendedMedia conditional field and
// boolean which is true if field was set.
func (m *MessageMediaInvoice) GetExtendedMedia() (value MessageExtendedMediaClass, ok bool) {
	if m == nil {
		return
	}
	if !m.Flags.Has(4) {
		return value, false
	}
	return m.ExtendedMedia, true
}

// MessageMediaGeoLive represents TL type `messageMediaGeoLive#b940c666`.
// Indicates a live geolocationÂ¹
//
// Links:
//  1. https://core.telegram.org/api/live-location
//
// See https://core.telegram.org/constructor/messageMediaGeoLive for reference.
type MessageMediaGeoLive struct {
	// Flags, see TL conditional fieldsÂ¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// Geolocation
	Geo GeoPointClass
	// For live locationsÂ¹, a direction in which the location moves, in degrees; 1-360
	//
	// Links:
	//  1) https://core.telegram.org/api/live-location
	//
	// Use SetHeading and GetHeading helpers.
	Heading int
	// Validity period of provided geolocation
	Period int
	// For live locationsÂ¹, a maximum distance to another chat member for proximity alerts,
	// in meters (0-100000).
	//
	// Links:
	//  1) https://core.telegram.org/api/live-location
	//
	// Use SetProximityNotificationRadius and GetProximityNotificationRadius helpers.
	ProximityNotificationRadius int
}

// MessageMediaGeoLiveTypeID is TL type id of MessageMediaGeoLive.
const MessageMediaGeoLiveTypeID = 0xb940c666

// construct implements constructor of MessageMediaClass.
func (m MessageMediaGeoLive) construct() MessageMediaClass { return &m }

// Ensuring interfaces in compile-time for MessageMediaGeoLive.
var (
	_ bin.Encoder     = &MessageMediaGeoLive{}
	_ bin.Decoder     = &MessageMediaGeoLive{}
	_ bin.BareEncoder = &MessageMediaGeoLive{}
	_ bin.BareDecoder = &MessageMediaGeoLive{}

	_ MessageMediaClass = &MessageMediaGeoLive{}
)

func (m *MessageMediaGeoLive) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.Flags.Zero()) {
		return false
	}
	if !(m.Geo == nil) {
		return false
	}
	if !(m.Heading == 0) {
		return false
	}
	if !(m.Period == 0) {
		return false
	}
	if !(m.ProximityNotificationRadius == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageMediaGeoLive) String() string {
	if m == nil {
		return "MessageMediaGeoLive(nil)"
	}
	type Alias MessageMediaGeoLive
	return fmt.Sprintf("MessageMediaGeoLive%+v", Alias(*m))
}

// FillFrom fills MessageMediaGeoLive from given interface.
func (m *MessageMediaGeoLive) FillFrom(from interface {
	GetGeo() (value GeoPointClass)
	GetHeading() (value int, ok bool)
	GetPeriod() (value int)
	GetProximityNotificationRadius() (value int, ok bool)
}) {
	m.Geo = from.GetGeo()
	if val, ok := from.GetHeading(); ok {
		m.Heading = val
	}

	m.Period = from.GetPeriod()
	if val, ok := from.GetProximityNotificationRadius(); ok {
		m.ProximityNotificationRadius = val
	}

}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageMediaGeoLive) TypeID() uint32 {
	return MessageMediaGeoLiveTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageMediaGeoLive) TypeName() string {
	return "messageMediaGeoLive"
}

// TypeInfo returns info about TL type.
func (m *MessageMediaGeoLive) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageMediaGeoLive",
		ID:   MessageMediaGeoLiveTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Geo",
			SchemaName: "geo",
		},
		{
			Name:       "Heading",
			SchemaName: "heading",
			Null:       !m.Flags.Has(0),
		},
		{
			Name:       "Period",
			SchemaName: "period",
		},
		{
			Name:       "ProximityNotificationRadius",
			SchemaName: "proximity_notification_radius",
			Null:       !m.Flags.Has(1),
		},
	}
	return typ
}

// SetFlags sets flags for non-zero fields.
func (m *MessageMediaGeoLive) SetFlags() {
	if !(m.Heading == 0) {
		m.Flags.Set(0)
	}
	if !(m.ProximityNotificationRadius == 0) {
		m.Flags.Set(1)
	}
}

// Encode implements bin.Encoder.
func (m *MessageMediaGeoLive) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageMediaGeoLive#b940c666 as nil")
	}
	b.PutID(MessageMediaGeoLiveTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageMediaGeoLive) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageMediaGeoLive#b940c666 as nil")
	}
	m.SetFlags()
	if err := m.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageMediaGeoLive#b940c666: field flags: %w", err)
	}
	if m.Geo == nil {
		return fmt.Errorf("unable to encode messageMediaGeoLive#b940c666: field geo is nil")
	}
	if err := m.Geo.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageMediaGeoLive#b940c666: field geo: %w", err)
	}
	if m.Flags.Has(0) {
		b.PutInt(m.Heading)
	}
	b.PutInt(m.Period)
	if m.Flags.Has(1) {
		b.PutInt(m.ProximityNotificationRadius)
	}
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageMediaGeoLive) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageMediaGeoLive#b940c666 to nil")
	}
	if err := b.ConsumeID(MessageMediaGeoLiveTypeID); err != nil {
		return fmt.Errorf("unable to decode messageMediaGeoLive#b940c666: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageMediaGeoLive) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageMediaGeoLive#b940c666 to nil")
	}
	{
		if err := m.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messageMediaGeoLive#b940c666: field flags: %w", err)
		}
	}
	{
		value, err := DecodeGeoPoint(b)
		if err != nil {
			return fmt.Errorf("unable to decode messageMediaGeoLive#b940c666: field geo: %w", err)
		}
		m.Geo = value
	}
	if m.Flags.Has(0) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode messageMediaGeoLive#b940c666: field heading: %w", err)
		}
		m.Heading = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode messageMediaGeoLive#b940c666: field period: %w", err)
		}
		m.Period = value
	}
	if m.Flags.Has(1) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode messageMediaGeoLive#b940c666: field proximity_notification_radius: %w", err)
		}
		m.ProximityNotificationRadius = value
	}
	return nil
}

// GetGeo returns value of Geo field.
func (m *MessageMediaGeoLive) GetGeo() (value GeoPointClass) {
	if m == nil {
		return
	}
	return m.Geo
}

// SetHeading sets value of Heading conditional field.
func (m *MessageMediaGeoLive) SetHeading(value int) {
	m.Flags.Set(0)
	m.Heading = value
}

// GetHeading returns value of Heading conditional field and
// boolean which is true if field was set.
func (m *MessageMediaGeoLive) GetHeading() (value int, ok bool) {
	if m == nil {
		return
	}
	if !m.Flags.Has(0) {
		return value, false
	}
	return m.Heading, true
}

// GetPeriod returns value of Period field.
func (m *MessageMediaGeoLive) GetPeriod() (value int) {
	if m == nil {
		return
	}
	return m.Period
}

// SetProximityNotificationRadius sets value of ProximityNotificationRadius conditional field.
func (m *MessageMediaGeoLive) SetProximityNotificationRadius(value int) {
	m.Flags.Set(1)
	m.ProximityNotificationRadius = value
}

// GetProximityNotificationRadius returns value of ProximityNotificationRadius conditional field and
// boolean which is true if field was set.
func (m *MessageMediaGeoLive) GetProximityNotificationRadius() (value int, ok bool) {
	if m == nil {
		return
	}
	if !m.Flags.Has(1) {
		return value, false
	}
	return m.ProximityNotificationRadius, true
}

// MessageMediaPoll represents TL type `messageMediaPoll#4bd6e798`.
// Poll
//
// See https://core.telegram.org/constructor/messageMediaPoll for reference.
type MessageMediaPoll struct {
	// The poll
	Poll Poll
	// The results of the poll
	Results PollResults
}

// MessageMediaPollTypeID is TL type id of MessageMediaPoll.
const MessageMediaPollTypeID = 0x4bd6e798

// construct implements constructor of MessageMediaClass.
func (m MessageMediaPoll) construct() MessageMediaClass { return &m }

// Ensuring interfaces in compile-time for MessageMediaPoll.
var (
	_ bin.Encoder     = &MessageMediaPoll{}
	_ bin.Decoder     = &MessageMediaPoll{}
	_ bin.BareEncoder = &MessageMediaPoll{}
	_ bin.BareDecoder = &MessageMediaPoll{}

	_ MessageMediaClass = &MessageMediaPoll{}
)

func (m *MessageMediaPoll) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.Poll.Zero()) {
		return false
	}
	if !(m.Results.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageMediaPoll) String() string {
	if m == nil {
		return "MessageMediaPoll(nil)"
	}
	type Alias MessageMediaPoll
	return fmt.Sprintf("MessageMediaPoll%+v", Alias(*m))
}

// FillFrom fills MessageMediaPoll from given interface.
func (m *MessageMediaPoll) FillFrom(from interface {
	GetPoll() (value Poll)
	GetResults() (value PollResults)
}) {
	m.Poll = from.GetPoll()
	m.Results = from.GetResults()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageMediaPoll) TypeID() uint32 {
	return MessageMediaPollTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageMediaPoll) TypeName() string {
	return "messageMediaPoll"
}

// TypeInfo returns info about TL type.
func (m *MessageMediaPoll) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageMediaPoll",
		ID:   MessageMediaPollTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Poll",
			SchemaName: "poll",
		},
		{
			Name:       "Results",
			SchemaName: "results",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageMediaPoll) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageMediaPoll#4bd6e798 as nil")
	}
	b.PutID(MessageMediaPollTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageMediaPoll) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageMediaPoll#4bd6e798 as nil")
	}
	if err := m.Poll.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageMediaPoll#4bd6e798: field poll: %w", err)
	}
	if err := m.Results.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageMediaPoll#4bd6e798: field results: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageMediaPoll) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageMediaPoll#4bd6e798 to nil")
	}
	if err := b.ConsumeID(MessageMediaPollTypeID); err != nil {
		return fmt.Errorf("unable to decode messageMediaPoll#4bd6e798: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageMediaPoll) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageMediaPoll#4bd6e798 to nil")
	}
	{
		if err := m.Poll.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messageMediaPoll#4bd6e798: field poll: %w", err)
		}
	}
	{
		if err := m.Results.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messageMediaPoll#4bd6e798: field results: %w", err)
		}
	}
	return nil
}

// GetPoll returns value of Poll field.
func (m *MessageMediaPoll) GetPoll() (value Poll) {
	if m == nil {
		return
	}
	return m.Poll
}

// GetResults returns value of Results field.
func (m *MessageMediaPoll) GetResults() (value PollResults) {
	if m == nil {
		return
	}
	return m.Results
}

// MessageMediaDice represents TL type `messageMediaDice#3f7ee58b`.
// Dice-based animated stickerÂ¹
//
// Links:
//  1. https://core.telegram.org/api/dice
//
// See https://core.telegram.org/constructor/messageMediaDice for reference.
type MessageMediaDice struct {
	// Dice valueÂ¹
	//
	// Links:
	//  1) https://core.telegram.org/api/dice
	Value int
	// The emoji, for now ,  and  are supported
	Emoticon string
}

// MessageMediaDiceTypeID is TL type id of MessageMediaDice.
const MessageMediaDiceTypeID = 0x3f7ee58b

// construct implements constructor of MessageMediaClass.
func (m MessageMediaDice) construct() MessageMediaClass { return &m }

// Ensuring interfaces in compile-time for MessageMediaDice.
var (
	_ bin.Encoder     = &MessageMediaDice{}
	_ bin.Decoder     = &MessageMediaDice{}
	_ bin.BareEncoder = &MessageMediaDice{}
	_ bin.BareDecoder = &MessageMediaDice{}

	_ MessageMediaClass = &MessageMediaDice{}
)

func (m *MessageMediaDice) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.Value == 0) {
		return false
	}
	if !(m.Emoticon == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageMediaDice) String() string {
	if m == nil {
		return "MessageMediaDice(nil)"
	}
	type Alias MessageMediaDice
	return fmt.Sprintf("MessageMediaDice%+v", Alias(*m))
}

// FillFrom fills MessageMediaDice from given interface.
func (m *MessageMediaDice) FillFrom(from interface {
	GetValue() (value int)
	GetEmoticon() (value string)
}) {
	m.Value = from.GetValue()
	m.Emoticon = from.GetEmoticon()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageMediaDice) TypeID() uint32 {
	return MessageMediaDiceTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageMediaDice) TypeName() string {
	return "messageMediaDice"
}

// TypeInfo returns info about TL type.
func (m *MessageMediaDice) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageMediaDice",
		ID:   MessageMediaDiceTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Value",
			SchemaName: "value",
		},
		{
			Name:       "Emoticon",
			SchemaName: "emoticon",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageMediaDice) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageMediaDice#3f7ee58b as nil")
	}
	b.PutID(MessageMediaDiceTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageMediaDice) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageMediaDice#3f7ee58b as nil")
	}
	b.PutInt(m.Value)
	b.PutString(m.Emoticon)
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageMediaDice) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageMediaDice#3f7ee58b to nil")
	}
	if err := b.ConsumeID(MessageMediaDiceTypeID); err != nil {
		return fmt.Errorf("unable to decode messageMediaDice#3f7ee58b: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageMediaDice) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageMediaDice#3f7ee58b to nil")
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode messageMediaDice#3f7ee58b: field value: %w", err)
		}
		m.Value = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode messageMediaDice#3f7ee58b: field emoticon: %w", err)
		}
		m.Emoticon = value
	}
	return nil
}

// GetValue returns value of Value field.
func (m *MessageMediaDice) GetValue() (value int) {
	if m == nil {
		return
	}
	return m.Value
}

// GetEmoticon returns value of Emoticon field.
func (m *MessageMediaDice) GetEmoticon() (value string) {
	if m == nil {
		return
	}
	return m.Emoticon
}

// MessageMediaStory represents TL type `messageMediaStory#68cb6283`.
// Represents a forwarded storyÂ¹ or a story mention.
//
// Links:
//  1. https://core.telegram.org/api/stories
//
// See https://core.telegram.org/constructor/messageMediaStory for reference.
type MessageMediaStory struct {
	// Flags, see TL conditional fieldsÂ¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// If set, indicates that this someone has mentioned us in this story (i.e. by tagging us
	// in the description) or vice versa, we have mentioned the other peer (if the message is
	// outgoing).
	ViaMention bool
	// Peer that posted the story.
	Peer PeerClass
	// Story ID
	ID int
	// The story itself, if absent fetch it using stories.getStoriesByIDÂ¹ and the peer/id
	// parameters specified above.
	//
	// Links:
	//  1) https://core.telegram.org/method/stories.getStoriesByID
	//
	// Use SetStory and GetStory helpers.
	Story StoryItemClass
}

// MessageMediaStoryTypeID is TL type id of MessageMediaStory.
const MessageMediaStoryTypeID = 0x68cb6283

// construct implements constructor of MessageMediaClass.
func (m MessageMediaStory) construct() MessageMediaClass { return &m }

// Ensuring interfaces in compile-time for MessageMediaStory.
var (
	_ bin.Encoder     = &MessageMediaStory{}
	_ bin.Decoder     = &MessageMediaStory{}
	_ bin.BareEncoder = &MessageMediaStory{}
	_ bin.BareDecoder = &MessageMediaStory{}

	_ MessageMediaClass = &MessageMediaStory{}
)

func (m *MessageMediaStory) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.Flags.Zero()) {
		return false
	}
	if !(m.ViaMention == false) {
		return false
	}
	if !(m.Peer == nil) {
		return false
	}
	if !(m.ID == 0) {
		return false
	}
	if !(m.Story == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageMediaStory) String() string {
	if m == nil {
		return "MessageMediaStory(nil)"
	}
	type Alias MessageMediaStory
	return fmt.Sprintf("MessageMediaStory%+v", Alias(*m))
}

// FillFrom fills MessageMediaStory from given interface.
func (m *MessageMediaStory) FillFrom(from interface {
	GetViaMention() (value bool)
	GetPeer() (value PeerClass)
	GetID() (value int)
	GetStory() (value StoryItemClass, ok bool)
}) {
	m.ViaMention = from.GetViaMention()
	m.Peer = from.GetPeer()
	m.ID = from.GetID()
	if val, ok := from.GetStory(); ok {
		m.Story = val
	}

}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageMediaStory) TypeID() uint32 {
	return MessageMediaStoryTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageMediaStory) TypeName() string {
	return "messageMediaStory"
}

// TypeInfo returns info about TL type.
func (m *MessageMediaStory) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageMediaStory",
		ID:   MessageMediaStoryTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ViaMention",
			SchemaName: "via_mention",
			Null:       !m.Flags.Has(1),
		},
		{
			Name:       "Peer",
			SchemaName: "peer",
		},
		{
			Name:       "ID",
			SchemaName: "id",
		},
		{
			Name:       "Story",
			SchemaName: "story",
			Null:       !m.Flags.Has(0),
		},
	}
	return typ
}

// SetFlags sets flags for non-zero fields.
func (m *MessageMediaStory) SetFlags() {
	if !(m.ViaMention == false) {
		m.Flags.Set(1)
	}
	if !(m.Story == nil) {
		m.Flags.Set(0)
	}
}

// Encode implements bin.Encoder.
func (m *MessageMediaStory) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageMediaStory#68cb6283 as nil")
	}
	b.PutID(MessageMediaStoryTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageMediaStory) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageMediaStory#68cb6283 as nil")
	}
	m.SetFlags()
	if err := m.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageMediaStory#68cb6283: field flags: %w", err)
	}
	if m.Peer == nil {
		return fmt.Errorf("unable to encode messageMediaStory#68cb6283: field peer is nil")
	}
	if err := m.Peer.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageMediaStory#68cb6283: field peer: %w", err)
	}
	b.PutInt(m.ID)
	if m.Flags.Has(0) {
		if m.Story == nil {
			return fmt.Errorf("unable to encode messageMediaStory#68cb6283: field story is nil")
		}
		if err := m.Story.Encode(b); err != nil {
			return fmt.Errorf("unable to encode messageMediaStory#68cb6283: field story: %w", err)
		}
	}
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageMediaStory) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageMediaStory#68cb6283 to nil")
	}
	if err := b.ConsumeID(MessageMediaStoryTypeID); err != nil {
		return fmt.Errorf("unable to decode messageMediaStory#68cb6283: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageMediaStory) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageMediaStory#68cb6283 to nil")
	}
	{
		if err := m.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messageMediaStory#68cb6283: field flags: %w", err)
		}
	}
	m.ViaMention = m.Flags.Has(1)
	{
		value, err := DecodePeer(b)
		if err != nil {
			return fmt.Errorf("unable to decode messageMediaStory#68cb6283: field peer: %w", err)
		}
		m.Peer = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode messageMediaStory#68cb6283: field id: %w", err)
		}
		m.ID = value
	}
	if m.Flags.Has(0) {
		value, err := DecodeStoryItem(b)
		if err != nil {
			return fmt.Errorf("unable to decode messageMediaStory#68cb6283: field story: %w", err)
		}
		m.Story = value
	}
	return nil
}

// SetViaMention sets value of ViaMention conditional field.
func (m *MessageMediaStory) SetViaMention(value bool) {
	if value {
		m.Flags.Set(1)
		m.ViaMention = true
	} else {
		m.Flags.Unset(1)
		m.ViaMention = false
	}
}

// GetViaMention returns value of ViaMention conditional field.
func (m *MessageMediaStory) GetViaMention() (value bool) {
	if m == nil {
		return
	}
	return m.Flags.Has(1)
}

// GetPeer returns value of Peer field.
func (m *MessageMediaStory) GetPeer() (value PeerClass) {
	if m == nil {
		return
	}
	return m.Peer
}

// GetID returns value of ID field.
func (m *MessageMediaStory) GetID() (value int) {
	if m == nil {
		return
	}
	return m.ID
}

// SetStory sets value of Story conditional field.
func (m *MessageMediaStory) SetStory(value StoryItemClass) {
	m.Flags.Set(0)
	m.Story = value
}

// GetStory returns value of Story conditional field and
// boolean which is true if field was set.
func (m *MessageMediaStory) GetStory() (value StoryItemClass, ok bool) {
	if m == nil {
		return
	}
	if !m.Flags.Has(0) {
		return value, false
	}
	return m.Story, true
}

// MessageMediaGiveaway represents TL type `messageMediaGiveaway#aa073beb`.
// Contains info about a giveaway, see here Â»Â¹ for more info.
//
// Links:
//  1. https://core.telegram.org/api/giveaways
//
// See https://core.telegram.org/constructor/messageMediaGiveaway for reference.
type MessageMediaGiveaway struct {
	// Flags, see TL conditional fieldsÂ¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// If set, only new subscribers starting from the giveaway creation date will be able to
	// participate to the giveaway.
	OnlyNewSubscribers bool
	// If set, giveaway winners are public and will be listed in a
	// messageMediaGiveawayResultsÂ¹ message that will be automatically sent to the channel
	// once the giveaway ends.
	//
	// Links:
	//  1) https://core.telegram.org/constructor/messageMediaGiveawayResults
	WinnersAreVisible bool
	// The channels that the user must join to participate in the giveaway.
	Channels []int64
	// If set, only users residing in these countries can participate in the giveaway,
	// (specified as a list of two-letter ISO 3166-1 alpha-2 country codes); otherwise there
	// are no country-based limitations.
	//
	// Use SetCountriesISO2 and GetCountriesISO2 helpers.
	CountriesISO2 []string
	// Can contain a textual description of additional giveaway prizes.
	//
	// Use SetPrizeDescription and GetPrizeDescription helpers.
	PrizeDescription string
	// Number of Telegram PremiumÂ¹ subscriptions given away.
	//
	// Links:
	//  1) https://core.telegram.org/api/premium
	Quantity int
	// Duration in months of each Telegram PremiumÂ¹ subscription in the giveaway.
	//
	// Links:
	//  1) https://core.telegram.org/api/premium
	//
	// Use SetMonths and GetMonths helpers.
	Months int
	// For Telegram Star giveawaysÂ¹, the total number of Telegram Stars being given away.
	//
	// Links:
	//  1) https://core.telegram.org/api/stars#star-giveaways
	//
	// Use SetStars and GetStars helpers.
	Stars int64
	// The end date of the giveaway.
	UntilDate int
}

// MessageMediaGiveawayTypeID is TL type id of MessageMediaGiveaway.
const MessageMediaGiveawayTypeID = 0xaa073beb

// construct implements constructor of MessageMediaClass.
func (m MessageMediaGiveaway) construct() MessageMediaClass { return &m }

// Ensuring interfaces in compile-time for MessageMediaGiveaway.
var (
	_ bin.Encoder     = &MessageMediaGiveaway{}
	_ bin.Decoder     = &MessageMediaGiveaway{}
	_ bin.BareEncoder = &MessageMediaGiveaway{}
	_ bin.BareDecoder = &MessageMediaGiveaway{}

	_ MessageMediaClass = &MessageMediaGiveaway{}
)

func (m *MessageMediaGiveaway) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.Flags.Zero()) {
		return false
	}
	if !(m.OnlyNewSubscribers == false) {
		return false
	}
	if !(m.WinnersAreVisible == false) {
		return false
	}
	if !(m.Channels == nil) {
		return false
	}
	if !(m.CountriesISO2 == nil) {
		return false
	}
	if !(m.PrizeDescription == "") {
		return false
	}
	if !(m.Quantity == 0) {
		return false
	}
	if !(m.Months == 0) {
		return false
	}
	if !(m.Stars == 0) {
		return false
	}
	if !(m.UntilDate == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageMediaGiveaway) String() string {
	if m == nil {
		return "MessageMediaGiveaway(nil)"
	}
	type Alias MessageMediaGiveaway
	return fmt.Sprintf("MessageMediaGiveaway%+v", Alias(*m))
}

// FillFrom fills MessageMediaGiveaway from given interface.
func (m *MessageMediaGiveaway) FillFrom(from interface {
	GetOnlyNewSubscribers() (value bool)
	GetWinnersAreVisible() (value bool)
	GetChannels() (value []int64)
	GetCountriesISO2() (value []string, ok bool)
	GetPrizeDescription() (value string, ok bool)
	GetQuantity() (value int)
	GetMonths() (value int, ok bool)
	GetStars() (value int64, ok bool)
	GetUntilDate() (value int)
}) {
	m.OnlyNewSubscribers = from.GetOnlyNewSubscribers()
	m.WinnersAreVisible = from.GetWinnersAreVisible()
	m.Channels = from.GetChannels()
	if val, ok := from.GetCountriesISO2(); ok {
		m.CountriesISO2 = val
	}

	if val, ok := from.GetPrizeDescription(); ok {
		m.PrizeDescription = val
	}

	m.Quantity = from.GetQuantity()
	if val, ok := from.GetMonths(); ok {
		m.Months = val
	}

	if val, ok := from.GetStars(); ok {
		m.Stars = val
	}

	m.UntilDate = from.GetUntilDate()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageMediaGiveaway) TypeID() uint32 {
	return MessageMediaGiveawayTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageMediaGiveaway) TypeName() string {
	return "messageMediaGiveaway"
}

// TypeInfo returns info about TL type.
func (m *MessageMediaGiveaway) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageMediaGiveaway",
		ID:   MessageMediaGiveawayTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "OnlyNewSubscribers",
			SchemaName: "only_new_subscribers",
			Null:       !m.Flags.Has(0),
		},
		{
			Name:       "WinnersAreVisible",
			SchemaName: "winners_are_visible",
			Null:       !m.Flags.Has(2),
		},
		{
			Name:       "Channels",
			SchemaName: "channels",
		},
		{
			Name:       "CountriesISO2",
			SchemaName: "countries_iso2",
			Null:       !m.Flags.Has(1),
		},
		{
			Name:       "PrizeDescription",
			SchemaName: "prize_description",
			Null:       !m.Flags.Has(3),
		},
		{
			Name:       "Quantity",
			SchemaName: "quantity",
		},
		{
			Name:       "Months",
			SchemaName: "months",
			Null:       !m.Flags.Has(4),
		},
		{
			Name:       "Stars",
			SchemaName: "stars",
			Null:       !m.Flags.Has(5),
		},
		{
			Name:       "UntilDate",
			SchemaName: "until_date",
		},
	}
	return typ
}

// SetFlags sets flags for non-zero fields.
func (m *MessageMediaGiveaway) SetFlags() {
	if !(m.OnlyNewSubscribers == false) {
		m.Flags.Set(0)
	}
	if !(m.WinnersAreVisible == false) {
		m.Flags.Set(2)
	}
	if !(m.CountriesISO2 == nil) {
		m.Flags.Set(1)
	}
	if !(m.PrizeDescription == "") {
		m.Flags.Set(3)
	}
	if !(m.Months == 0) {
		m.Flags.Set(4)
	}
	if !(m.Stars == 0) {
		m.Flags.Set(5)
	}
}

// Encode implements bin.Encoder.
func (m *MessageMediaGiveaway) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageMediaGiveaway#aa073beb as nil")
	}
	b.PutID(MessageMediaGiveawayTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageMediaGiveaway) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageMediaGiveaway#aa073beb as nil")
	}
	m.SetFlags()
	if err := m.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageMediaGiveaway#aa073beb: field flags: %w", err)
	}
	b.PutVectorHeader(len(m.Channels))
	for _, v := range m.Channels {
		b.PutLong(v)
	}
	if m.Flags.Has(1) {
		b.PutVectorHeader(len(m.CountriesISO2))
		for _, v := range m.CountriesISO2 {
			b.PutString(v)
		}
	}
	if m.Flags.Has(3) {
		b.PutString(m.PrizeDescription)
	}
	b.PutInt(m.Quantity)
	if m.Flags.Has(4) {
		b.PutInt(m.Months)
	}
	if m.Flags.Has(5) {
		b.PutLong(m.Stars)
	}
	b.PutInt(m.UntilDate)
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageMediaGiveaway) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageMediaGiveaway#aa073beb to nil")
	}
	if err := b.ConsumeID(MessageMediaGiveawayTypeID); err != nil {
		return fmt.Errorf("unable to decode messageMediaGiveaway#aa073beb: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageMediaGiveaway) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageMediaGiveaway#aa073beb to nil")
	}
	{
		if err := m.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messageMediaGiveaway#aa073beb: field flags: %w", err)
		}
	}
	m.OnlyNewSubscribers = m.Flags.Has(0)
	m.WinnersAreVisible = m.Flags.Has(2)
	{
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode messageMediaGiveaway#aa073beb: field channels: %w", err)
		}

		if headerLen > 0 {
			m.Channels = make([]int64, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := b.Long()
			if err != nil {
				return fmt.Errorf("unable to decode messageMediaGiveaway#aa073beb: field channels: %w", err)
			}
			m.Channels = append(m.Channels, value)
		}
	}
	if m.Flags.Has(1) {
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode messageMediaGiveaway#aa073beb: field countries_iso2: %w", err)
		}

		if headerLen > 0 {
			m.CountriesISO2 = make([]string, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode messageMediaGiveaway#aa073beb: field countries_iso2: %w", err)
			}
			m.CountriesISO2 = append(m.CountriesISO2, value)
		}
	}
	if m.Flags.Has(3) {
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode messageMediaGiveaway#aa073beb: field prize_description: %w", err)
		}
		m.PrizeDescription = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode messageMediaGiveaway#aa073beb: field quantity: %w", err)
		}
		m.Quantity = value
	}
	if m.Flags.Has(4) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode messageMediaGiveaway#aa073beb: field months: %w", err)
		}
		m.Months = value
	}
	if m.Flags.Has(5) {
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode messageMediaGiveaway#aa073beb: field stars: %w", err)
		}
		m.Stars = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode messageMediaGiveaway#aa073beb: field until_date: %w", err)
		}
		m.UntilDate = value
	}
	return nil
}

// SetOnlyNewSubscribers sets value of OnlyNewSubscribers conditional field.
func (m *MessageMediaGiveaway) SetOnlyNewSubscribers(value bool) {
	if value {
		m.Flags.Set(0)
		m.OnlyNewSubscribers = true
	} else {
		m.Flags.Unset(0)
		m.OnlyNewSubscribers = false
	}
}

// GetOnlyNewSubscribers returns value of OnlyNewSubscribers conditional field.
func (m *MessageMediaGiveaway) GetOnlyNewSubscribers() (value bool) {
	if m == nil {
		return
	}
	return m.Flags.Has(0)
}

// SetWinnersAreVisible sets value of WinnersAreVisible conditional field.
func (m *MessageMediaGiveaway) SetWinnersAreVisible(value bool) {
	if value {
		m.Flags.Set(2)
		m.WinnersAreVisible = true
	} else {
		m.Flags.Unset(2)
		m.WinnersAreVisible = false
	}
}

// GetWinnersAreVisible returns value of WinnersAreVisible conditional field.
func (m *MessageMediaGiveaway) GetWinnersAreVisible() (value bool) {
	if m == nil {
		return
	}
	return m.Flags.Has(2)
}

// GetChannels returns value of Channels field.
func (m *MessageMediaGiveaway) GetChannels() (value []int64) {
	if m == nil {
		return
	}
	return m.Channels
}

// SetCountriesISO2 sets value of CountriesISO2 conditional field.
func (m *MessageMediaGiveaway) SetCountriesISO2(value []string) {
	m.Flags.Set(1)
	m.CountriesISO2 = value
}

// GetCountriesISO2 returns value of CountriesISO2 conditional field and
// boolean which is true if field was set.
func (m *MessageMediaGiveaway) GetCountriesISO2() (value []string, ok bool) {
	if m == nil {
		return
	}
	if !m.Flags.Has(1) {
		return value, false
	}
	return m.CountriesISO2, true
}

// SetPrizeDescription sets value of PrizeDescription conditional field.
func (m *MessageMediaGiveaway) SetPrizeDescription(value string) {
	m.Flags.Set(3)
	m.PrizeDescription = value
}

// GetPrizeDescription returns value of PrizeDescription conditional field and
// boolean which is true if field was set.
func (m *MessageMediaGiveaway) GetPrizeDescription() (value string, ok bool) {
	if m == nil {
		return
	}
	if !m.Flags.Has(3) {
		return value, false
	}
	return m.PrizeDescription, true
}

// GetQuantity returns value of Quantity field.
func (m *MessageMediaGiveaway) GetQuantity() (value int) {
	if m == nil {
		return
	}
	return m.Quantity
}

// SetMonths sets value of Months conditional field.
func (m *MessageMediaGiveaway) SetMonths(value int) {
	m.Flags.Set(4)
	m.Months = value
}

// GetMonths returns value of Months conditional field and
// boolean which is true if field was set.
func (m *MessageMediaGiveaway) GetMonths() (value int, ok bool) {
	if m == nil {
		return
	}
	if !m.Flags.Has(4) {
		return value, false
	}
	return m.Months, true
}

// SetStars sets value of Stars conditional field.
func (m *MessageMediaGiveaway) SetStars(value int64) {
	m.Flags.Set(5)
	m.Stars = value
}

// GetStars returns value of Stars conditional field and
// boolean which is true if field was set.
func (m *MessageMediaGiveaway) GetStars() (value int64, ok bool) {
	if m == nil {
		return
	}
	if !m.Flags.Has(5) {
		return value, false
	}
	return m.Stars, true
}

// GetUntilDate returns value of UntilDate field.
func (m *MessageMediaGiveaway) GetUntilDate() (value int) {
	if m == nil {
		return
	}
	return m.UntilDate
}

// MessageMediaGiveawayResults represents TL type `messageMediaGiveawayResults#ceaa3ea1`.
// A giveawayÂ¹ with public winners has finished, this constructor contains info about
// the winners.
//
// Links:
//  1. https://core.telegram.org/api/giveaways
//
// See https://core.telegram.org/constructor/messageMediaGiveawayResults for reference.
type MessageMediaGiveawayResults struct {
	// Flags, see TL conditional fieldsÂ¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// If set, only new subscribers starting from the giveaway creation date participated in
	// the giveaway.
	OnlyNewSubscribers bool
	// If set, the giveaway was canceled and was fully refunded.
	Refunded bool
	// ID of the channel/supergroup that was automatically boostedÂ¹ by the winners of the
	// giveaway for duration of the Premium subscription.
	//
	// Links:
	//  1) https://core.telegram.org/api/boost
	ChannelID int64
	// Number of other channels that participated in the giveaway.
	//
	// Use SetAdditionalPeersCount and GetAdditionalPeersCount helpers.
	AdditionalPeersCount int
	// Identifier of the message with the giveaway in channel_id.
	LaunchMsgID int
	// Total number of winners in the giveaway.
	WinnersCount int
	// Number of not-yet-claimed prizes.
	UnclaimedCount int
	// Up to 100 user identifiers of the winners of the giveaway.
	Winners []int64
	// Duration in months of each Telegram PremiumÂ¹ subscription in the giveaway.
	//
	// Links:
	//  1) https://core.telegram.org/api/premium
	//
	// Use SetMonths and GetMonths helpers.
	Months int
	// For Telegram Star giveawaysÂ¹, the total number of Telegram Stars being given away.
	//
	// Links:
	//  1) https://core.telegram.org/api/stars#star-giveaways
	//
	// Use SetStars and GetStars helpers.
	Stars int64
	// Can contain a textual description of additional giveaway prizes.
	//
	// Use SetPrizeDescription and GetPrizeDescription helpers.
	PrizeDescription string
	// Point in time (Unix timestamp) when the winners were selected. May be bigger than
	// winners selection date specified in initial parameters of the giveaway.
	UntilDate int
}

// MessageMediaGiveawayResultsTypeID is TL type id of MessageMediaGiveawayResults.
const MessageMediaGiveawayResultsTypeID = 0xceaa3ea1

// construct implements constructor of MessageMediaClass.
func (m MessageMediaGiveawayResults) construct() MessageMediaClass { return &m }

// Ensuring interfaces in compile-time for MessageMediaGiveawayResults.
var (
	_ bin.Encoder     = &MessageMediaGiveawayResults{}
	_ bin.Decoder     = &MessageMediaGiveawayResults{}
	_ bin.BareEncoder = &MessageMediaGiveawayResults{}
	_ bin.BareDecoder = &MessageMediaGiveawayResults{}

	_ MessageMediaClass = &MessageMediaGiveawayResults{}
)

func (m *MessageMediaGiveawayResults) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.Flags.Zero()) {
		return false
	}
	if !(m.OnlyNewSubscribers == false) {
		return false
	}
	if !(m.Refunded == false) {
		return false
	}
	if !(m.ChannelID == 0) {
		return false
	}
	if !(m.AdditionalPeersCount == 0) {
		return false
	}
	if !(m.LaunchMsgID == 0) {
		return false
	}
	if !(m.WinnersCount == 0) {
		return false
	}
	if !(m.UnclaimedCount == 0) {
		return false
	}
	if !(m.Winners == nil) {
		return false
	}
	if !(m.Months == 0) {
		return false
	}
	if !(m.Stars == 0) {
		return false
	}
	if !(m.PrizeDescription == "") {
		return false
	}
	if !(m.UntilDate == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageMediaGiveawayResults) String() string {
	if m == nil {
		return "MessageMediaGiveawayResults(nil)"
	}
	type Alias MessageMediaGiveawayResults
	return fmt.Sprintf("MessageMediaGiveawayResults%+v", Alias(*m))
}

// FillFrom fills MessageMediaGiveawayResults from given interface.
func (m *MessageMediaGiveawayResults) FillFrom(from interface {
	GetOnlyNewSubscribers() (value bool)
	GetRefunded() (value bool)
	GetChannelID() (value int64)
	GetAdditionalPeersCount() (value int, ok bool)
	GetLaunchMsgID() (value int)
	GetWinnersCount() (value int)
	GetUnclaimedCount() (value int)
	GetWinners() (value []int64)
	GetMonths() (value int, ok bool)
	GetStars() (value int64, ok bool)
	GetPrizeDescription() (value string, ok bool)
	GetUntilDate() (value int)
}) {
	m.OnlyNewSubscribers = from.GetOnlyNewSubscribers()
	m.Refunded = from.GetRefunded()
	m.ChannelID = from.GetChannelID()
	if val, ok := from.GetAdditionalPeersCount(); ok {
		m.AdditionalPeersCount = val
	}

	m.LaunchMsgID = from.GetLaunchMsgID()
	m.WinnersCount = from.GetWinnersCount()
	m.UnclaimedCount = from.GetUnclaimedCount()
	m.Winners = from.GetWinners()
	if val, ok := from.GetMonths(); ok {
		m.Months = val
	}

	if val, ok := from.GetStars(); ok {
		m.Stars = val
	}

	if val, ok := from.GetPrizeDescription(); ok {
		m.PrizeDescription = val
	}

	m.UntilDate = from.GetUntilDate()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageMediaGiveawayResults) TypeID() uint32 {
	return MessageMediaGiveawayResultsTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageMediaGiveawayResults) TypeName() string {
	return "messageMediaGiveawayResults"
}

// TypeInfo returns info about TL type.
func (m *MessageMediaGiveawayResults) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageMediaGiveawayResults",
		ID:   MessageMediaGiveawayResultsTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "OnlyNewSubscribers",
			SchemaName: "only_new_subscribers",
			Null:       !m.Flags.Has(0),
		},
		{
			Name:       "Refunded",
			SchemaName: "refunded",
			Null:       !m.Flags.Has(2),
		},
		{
			Name:       "ChannelID",
			SchemaName: "channel_id",
		},
		{
			Name:       "AdditionalPeersCount",
			SchemaName: "additional_peers_count",
			Null:       !m.Flags.Has(3),
		},
		{
			Name:       "LaunchMsgID",
			SchemaName: "launch_msg_id",
		},
		{
			Name:       "WinnersCount",
			SchemaName: "winners_count",
		},
		{
			Name:       "UnclaimedCount",
			SchemaName: "unclaimed_count",
		},
		{
			Name:       "Winners",
			SchemaName: "winners",
		},
		{
			Name:       "Months",
			SchemaName: "months",
			Null:       !m.Flags.Has(4),
		},
		{
			Name:       "Stars",
			SchemaName: "stars",
			Null:       !m.Flags.Has(5),
		},
		{
			Name:       "PrizeDescription",
			SchemaName: "prize_description",
			Null:       !m.Flags.Has(1),
		},
		{
			Name:       "UntilDate",
			SchemaName: "until_date",
		},
	}
	return typ
}

// SetFlags sets flags for non-zero fields.
func (m *MessageMediaGiveawayResults) SetFlags() {
	if !(m.OnlyNewSubscribers == false) {
		m.Flags.Set(0)
	}
	if !(m.Refunded == false) {
		m.Flags.Set(2)
	}
	if !(m.AdditionalPeersCount == 0) {
		m.Flags.Set(3)
	}
	if !(m.Months == 0) {
		m.Flags.Set(4)
	}
	if !(m.Stars == 0) {
		m.Flags.Set(5)
	}
	if !(m.PrizeDescription == "") {
		m.Flags.Set(1)
	}
}

// Encode implements bin.Encoder.
func (m *MessageMediaGiveawayResults) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageMediaGiveawayResults#ceaa3ea1 as nil")
	}
	b.PutID(MessageMediaGiveawayResultsTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageMediaGiveawayResults) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageMediaGiveawayResults#ceaa3ea1 as nil")
	}
	m.SetFlags()
	if err := m.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messageMediaGiveawayResults#ceaa3ea1: field flags: %w", err)
	}
	b.PutLong(m.ChannelID)
	if m.Flags.Has(3) {
		b.PutInt(m.AdditionalPeersCount)
	}
	b.PutInt(m.LaunchMsgID)
	b.PutInt(m.WinnersCount)
	b.PutInt(m.UnclaimedCount)
	b.PutVectorHeader(len(m.Winners))
	for _, v := range m.Winners {
		b.PutLong(v)
	}
	if m.Flags.Has(4) {
		b.PutInt(m.Months)
	}
	if m.Flags.Has(5) {
		b.PutLong(m.Stars)
	}
	if m.Flags.Has(1) {
		b.PutString(m.PrizeDescription)
	}
	b.PutInt(m.UntilDate)
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageMediaGiveawayResults) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageMediaGiveawayResults#ceaa3ea1 to nil")
	}
	if err := b.ConsumeID(MessageMediaGiveawayResultsTypeID); err != nil {
		return fmt.Errorf("unable to decode messageMediaGiveawayResults#ceaa3ea1: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageMediaGiveawayResults) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageMediaGiveawayResults#ceaa3ea1 to nil")
	}
	{
		if err := m.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messageMediaGiveawayResults#ceaa3ea1: field flags: %w", err)
		}
	}
	m.OnlyNewSubscribers = m.Flags.Has(0)
	m.Refunded = m.Flags.Has(2)
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode messageMediaGiveawayResults#ceaa3ea1: field channel_id: %w", err)
		}
		m.ChannelID = value
	}
	if m.Flags.Has(3) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode messageMediaGiveawayResults#ceaa3ea1: field additional_peers_count: %w", err)
		}
		m.AdditionalPeersCount = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode messageMediaGiveawayResults#ceaa3ea1: field launch_msg_id: %w", err)
		}
		m.LaunchMsgID = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode messageMediaGiveawayResults#ceaa3ea1: field winners_count: %w", err)
		}
		m.WinnersCount = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode messageMediaGiveawayResults#ceaa3ea1: field unclaimed_count: %w", err)
		}
		m.UnclaimedCount = value
	}
	{
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode messageMediaGiveawayResults#ceaa3ea1: field winners: %w", err)
		}

		if headerLen > 0 {
			m.Winners = make([]int64, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := b.Long()
			if err != nil {
				return fmt.Errorf("unable to decode messageMediaGiveawayResults#ceaa3ea1: field winners: %w", err)
			}
			m.Winners = append(m.Winners, value)
		}
	}
	if m.Flags.Has(4) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode messageMediaGiveawayResults#ceaa3ea1: field months: %w", err)
		}
		m.Months = value
	}
	if m.Flags.Has(5) {
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode messageMediaGiveawayResults#ceaa3ea1: field stars: %w", err)
		}
		m.Stars = value
	}
	if m.Flags.Has(1) {
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode messageMediaGiveawayResults#ceaa3ea1: field prize_description: %w", err)
		}
		m.PrizeDescription = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode messageMediaGiveawayResults#ceaa3ea1: field until_date: %w", err)
		}
		m.UntilDate = value
	}
	return nil
}

// SetOnlyNewSubscribers sets value of OnlyNewSubscribers conditional field.
func (m *MessageMediaGiveawayResults) SetOnlyNewSubscribers(value bool) {
	if value {
		m.Flags.Set(0)
		m.OnlyNewSubscribers = true
	} else {
		m.Flags.Unset(0)
		m.OnlyNewSubscribers = false
	}
}

// GetOnlyNewSubscribers returns value of OnlyNewSubscribers conditional field.
func (m *MessageMediaGiveawayResults) GetOnlyNewSubscribers() (value bool) {
	if m == nil {
		return
	}
	return m.Flags.Has(0)
}

// SetRefunded sets value of Refunded conditional field.
func (m *MessageMediaGiveawayResults) SetRefunded(value bool) {
	if value {
		m.Flags.Set(2)
		m.Refunded = true
	} else {
		m.Flags.Unset(2)
		m.Refunded = false
	}
}

// GetRefunded returns value of Refunded conditional field.
func (m *MessageMediaGiveawayResults) GetRefunded() (value bool) {
	if m == nil {
		return
	}
	return m.Flags.Has(2)
}

// GetChannelID returns value of ChannelID field.
func (m *MessageMediaGiveawayResults) GetChannelID() (value int64) {
	if m == nil {
		return
	}
	return m.ChannelID
}

// SetAdditionalPeersCount sets value of AdditionalPeersCount conditional field.
func (m *MessageMediaGiveawayResults) SetAdditionalPeersCount(value int) {
	m.Flags.Set(3)
	m.AdditionalPeersCount = value
}

// GetAdditionalPeersCount returns value of AdditionalPeersCount conditional field and
// boolean which is true if field was set.
func (m *MessageMediaGiveawayResults) GetAdditionalPeersCount() (value int, ok bool) {
	if m == nil {
		return
	}
	if !m.Flags.Has(3) {
		return value, false
	}
	return m.AdditionalPeersCount, true
}

// GetLaunchMsgID returns value of LaunchMsgID field.
func (m *MessageMediaGiveawayResults) GetLaunchMsgID() (value int) {
	if m == nil {
		return
	}
	return m.LaunchMsgID
}

// GetWinnersCount returns value of WinnersCount field.
func (m *MessageMediaGiveawayResults) GetWinnersCount() (value int) {
	if m == nil {
		return
	}
	return m.WinnersCount
}

// GetUnclaimedCount returns value of UnclaimedCount field.
func (m *MessageMediaGiveawayResults) GetUnclaimedCount() (value int) {
	if m == nil {
		return
	}
	return m.UnclaimedCount
}

// GetWinners returns value of Winners field.
func (m *MessageMediaGiveawayResults) GetWinners() (value []int64) {
	if m == nil {
		return
	}
	return m.Winners
}

// SetMonths sets value of Months conditional field.
func (m *MessageMediaGiveawayResults) SetMonths(value int) {
	m.Flags.Set(4)
	m.Months = value
}

// GetMonths returns value of Months conditional field and
// boolean which is true if field was set.
func (m *MessageMediaGiveawayResults) GetMonths() (value int, ok bool) {
	if m == nil {
		return
	}
	if !m.Flags.Has(4) {
		return value, false
	}
	return m.Months, true
}

// SetStars sets value of Stars conditional field.
func (m *MessageMediaGiveawayResults) SetStars(value int64) {
	m.Flags.Set(5)
	m.Stars = value
}

// GetStars returns value of Stars conditional field and
// boolean which is true if field was set.
func (m *MessageMediaGiveawayResults) GetStars() (value int64, ok bool) {
	if m == nil {
		return
	}
	if !m.Flags.Has(5) {
		return value, false
	}
	return m.Stars, true
}

// SetPrizeDescription sets value of PrizeDescription conditional field.
func (m *MessageMediaGiveawayResults) SetPrizeDescription(value string) {
	m.Flags.Set(1)
	m.PrizeDescription = value
}

// GetPrizeDescription returns value of PrizeDescription conditional field and
// boolean which is true if field was set.
func (m *MessageMediaGiveawayResults) GetPrizeDescription() (value string, ok bool) {
	if m == nil {
		return
	}
	if !m.Flags.Has(1) {
		return value, false
	}
	return m.PrizeDescription, true
}

// GetUntilDate returns value of UntilDate field.
func (m *MessageMediaGiveawayResults) GetUntilDate() (value int) {
	if m == nil {
		return
	}
	return m.UntilDate
}

// MessageMediaPaidMedia represents TL type `messageMediaPaidMedia#a8852491`.
// Paid media, see here Â»Â¹ for more info.
//
// Links:
//  1. https://core.telegram.org/api/paid-media
//
// See https://core.telegram.org/constructor/messageMediaPaidMedia for reference.
type MessageMediaPaidMedia struct {
	// The price of the media in Telegram StarsÂ¹.
	//
	// Links:
	//  1) https://core.telegram.org/api/stars
	StarsAmount int64
	// Either the paid-for media, or super low resolution media previews if the media wasn't
	// purchased yet, see here Â»Â¹ for more info.
	//
	// Links:
	//  1) https://core.telegram.org/api/paid-media#viewing-paid-media
	ExtendedMedia []MessageExtendedMediaClass
}

// MessageMediaPaidMediaTypeID is TL type id of MessageMediaPaidMedia.
const MessageMediaPaidMediaTypeID = 0xa8852491

// construct implements constructor of MessageMediaClass.
func (m MessageMediaPaidMedia) construct() MessageMediaClass { return &m }

// Ensuring interfaces in compile-time for MessageMediaPaidMedia.
var (
	_ bin.Encoder     = &MessageMediaPaidMedia{}
	_ bin.Decoder     = &MessageMediaPaidMedia{}
	_ bin.BareEncoder = &MessageMediaPaidMedia{}
	_ bin.BareDecoder = &MessageMediaPaidMedia{}

	_ MessageMediaClass = &MessageMediaPaidMedia{}
)

func (m *MessageMediaPaidMedia) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.StarsAmount == 0) {
		return false
	}
	if !(m.ExtendedMedia == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *MessageMediaPaidMedia) String() string {
	if m == nil {
		return "MessageMediaPaidMedia(nil)"
	}
	type Alias MessageMediaPaidMedia
	return fmt.Sprintf("MessageMediaPaidMedia%+v", Alias(*m))
}

// FillFrom fills MessageMediaPaidMedia from given interface.
func (m *MessageMediaPaidMedia) FillFrom(from interface {
	GetStarsAmount() (value int64)
	GetExtendedMedia() (value []MessageExtendedMediaClass)
}) {
	m.StarsAmount = from.GetStarsAmount()
	m.ExtendedMedia = from.GetExtendedMedia()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*MessageMediaPaidMedia) TypeID() uint32 {
	return MessageMediaPaidMediaTypeID
}

// TypeName returns name of type in TL schema.
func (*MessageMediaPaidMedia) TypeName() string {
	return "messageMediaPaidMedia"
}

// TypeInfo returns info about TL type.
func (m *MessageMediaPaidMedia) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "messageMediaPaidMedia",
		ID:   MessageMediaPaidMediaTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "StarsAmount",
			SchemaName: "stars_amount",
		},
		{
			Name:       "ExtendedMedia",
			SchemaName: "extended_media",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *MessageMediaPaidMedia) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageMediaPaidMedia#a8852491 as nil")
	}
	b.PutID(MessageMediaPaidMediaTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *MessageMediaPaidMedia) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messageMediaPaidMedia#a8852491 as nil")
	}
	b.PutLong(m.StarsAmount)
	b.PutVectorHeader(len(m.ExtendedMedia))
	for idx, v := range m.ExtendedMedia {
		if v == nil {
			return fmt.Errorf("unable to encode messageMediaPaidMedia#a8852491: field extended_media element with index %d is nil", idx)
		}
		if err := v.Encode(b); err != nil {
			return fmt.Errorf("unable to encode messageMediaPaidMedia#a8852491: field extended_media element with index %d: %w", idx, err)
		}
	}
	return nil
}

// Decode implements bin.Decoder.
func (m *MessageMediaPaidMedia) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageMediaPaidMedia#a8852491 to nil")
	}
	if err := b.ConsumeID(MessageMediaPaidMediaTypeID); err != nil {
		return fmt.Errorf("unable to decode messageMediaPaidMedia#a8852491: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *MessageMediaPaidMedia) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messageMediaPaidMedia#a8852491 to nil")
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode messageMediaPaidMedia#a8852491: field stars_amount: %w", err)
		}
		m.StarsAmount = value
	}
	{
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode messageMediaPaidMedia#a8852491: field extended_media: %w", err)
		}

		if headerLen > 0 {
			m.ExtendedMedia = make([]MessageExtendedMediaClass, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := DecodeMessageExtendedMedia(b)
			if err != nil {
				return fmt.Errorf("unable to decode messageMediaPaidMedia#a8852491: field extended_media: %w", err)
			}
			m.ExtendedMedia = append(m.ExtendedMedia, value)
		}
	}
	return nil
}

// GetStarsAmount returns value of StarsAmount field.
func (m *MessageMediaPaidMedia) GetStarsAmount() (value int64) {
	if m == nil {
		return
	}
	return m.StarsAmount
}

// GetExtendedMedia returns value of ExtendedMedia field.
func (m *MessageMediaPaidMedia) GetExtendedMedia() (value []MessageExtendedMediaClass) {
	if m == nil {
		return
	}
	return m.ExtendedMedia
}

// MapExtendedMedia returns field ExtendedMedia wrapped in MessageExtendedMediaClassArray helper.
func (m *MessageMediaPaidMedia) MapExtendedMedia() (value MessageExtendedMediaClassArray) {
	return MessageExtendedMediaClassArray(m.ExtendedMedia)
}

// MessageMediaClassName is schema name of MessageMediaClass.
const MessageMediaClassName = "MessageMedia"

// MessageMediaClass represents MessageMedia generic type.
//
// See https://core.telegram.org/type/MessageMedia for reference.
//
// Example:
//
//	g, err := tg.DecodeMessageMedia(buf)
//	if err != nil {
//	    panic(err)
//	}
//	switch v := g.(type) {
//	case *tg.MessageMediaEmpty: // messageMediaEmpty#3ded6320
//	case *tg.MessageMediaPhoto: // messageMediaPhoto#695150d7
//	case *tg.MessageMediaGeo: // messageMediaGeo#56e0d474
//	case *tg.MessageMediaContact: // messageMediaContact#70322949
//	case *tg.MessageMediaUnsupported: // messageMediaUnsupported#9f84f49e
//	case *tg.MessageMediaDocument: // messageMediaDocument#52d8ccd9
//	case *tg.MessageMediaWebPage: // messageMediaWebPage#ddf10c3b
//	case *tg.MessageMediaVenue: // messageMediaVenue#2ec0533f
//	case *tg.MessageMediaGame: // messageMediaGame#fdb19008
//	case *tg.MessageMediaInvoice: // messageMediaInvoice#f6a548d3
//	case *tg.MessageMediaGeoLive: // messageMediaGeoLive#b940c666
//	case *tg.MessageMediaPoll: // messageMediaPoll#4bd6e798
//	case *tg.MessageMediaDice: // messageMediaDice#3f7ee58b
//	case *tg.MessageMediaStory: // messageMediaStory#68cb6283
//	case *tg.MessageMediaGiveaway: // messageMediaGiveaway#aa073beb
//	case *tg.MessageMediaGiveawayResults: // messageMediaGiveawayResults#ceaa3ea1
//	case *tg.MessageMediaPaidMedia: // messageMediaPaidMedia#a8852491
//	default: panic(v)
//	}
type MessageMediaClass interface {
	bin.Encoder
	bin.Decoder
	bin.BareEncoder
	bin.BareDecoder
	construct() MessageMediaClass

	// TypeID returns type id in TL schema.
	//
	// See https://core.telegram.org/mtproto/TL-tl#remarks.
	TypeID() uint32
	// TypeName returns name of type in TL schema.
	TypeName() string
	// String implements fmt.Stringer.
	String() string
	// Zero returns true if current object has a zero value.
	Zero() bool
}

// DecodeMessageMedia implements binary de-serialization for MessageMediaClass.
func DecodeMessageMedia(buf *bin.Buffer) (MessageMediaClass, error) {
	id, err := buf.PeekID()
	if err != nil {
		return nil, err
	}
	switch id {
	case MessageMediaEmptyTypeID:
		// Decoding messageMediaEmpty#3ded6320.
		v := MessageMediaEmpty{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageMediaClass: %w", err)
		}
		return &v, nil
	case MessageMediaPhotoTypeID:
		// Decoding messageMediaPhoto#695150d7.
		v := MessageMediaPhoto{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageMediaClass: %w", err)
		}
		return &v, nil
	case MessageMediaGeoTypeID:
		// Decoding messageMediaGeo#56e0d474.
		v := MessageMediaGeo{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageMediaClass: %w", err)
		}
		return &v, nil
	case MessageMediaContactTypeID:
		// Decoding messageMediaContact#70322949.
		v := MessageMediaContact{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageMediaClass: %w", err)
		}
		return &v, nil
	case MessageMediaUnsupportedTypeID:
		// Decoding messageMediaUnsupported#9f84f49e.
		v := MessageMediaUnsupported{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageMediaClass: %w", err)
		}
		return &v, nil
	case MessageMediaDocumentTypeID:
		// Decoding messageMediaDocument#52d8ccd9.
		v := MessageMediaDocument{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageMediaClass: %w", err)
		}
		return &v, nil
	case MessageMediaWebPageTypeID:
		// Decoding messageMediaWebPage#ddf10c3b.
		v := MessageMediaWebPage{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageMediaClass: %w", err)
		}
		return &v, nil
	case MessageMediaVenueTypeID:
		// Decoding messageMediaVenue#2ec0533f.
		v := MessageMediaVenue{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageMediaClass: %w", err)
		}
		return &v, nil
	case MessageMediaGameTypeID:
		// Decoding messageMediaGame#fdb19008.
		v := MessageMediaGame{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageMediaClass: %w", err)
		}
		return &v, nil
	case MessageMediaInvoiceTypeID:
		// Decoding messageMediaInvoice#f6a548d3.
		v := MessageMediaInvoice{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageMediaClass: %w", err)
		}
		return &v, nil
	case MessageMediaGeoLiveTypeID:
		// Decoding messageMediaGeoLive#b940c666.
		v := MessageMediaGeoLive{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageMediaClass: %w", err)
		}
		return &v, nil
	case MessageMediaPollTypeID:
		// Decoding messageMediaPoll#4bd6e798.
		v := MessageMediaPoll{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageMediaClass: %w", err)
		}
		return &v, nil
	case MessageMediaDiceTypeID:
		// Decoding messageMediaDice#3f7ee58b.
		v := MessageMediaDice{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageMediaClass: %w", err)
		}
		return &v, nil
	case MessageMediaStoryTypeID:
		// Decoding messageMediaStory#68cb6283.
		v := MessageMediaStory{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageMediaClass: %w", err)
		}
		return &v, nil
	case MessageMediaGiveawayTypeID:
		// Decoding messageMediaGiveaway#aa073beb.
		v := MessageMediaGiveaway{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageMediaClass: %w", err)
		}
		return &v, nil
	case MessageMediaGiveawayResultsTypeID:
		// Decoding messageMediaGiveawayResults#ceaa3ea1.
		v := MessageMediaGiveawayResults{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageMediaClass: %w", err)
		}
		return &v, nil
	case MessageMediaPaidMediaTypeID:
		// Decoding messageMediaPaidMedia#a8852491.
		v := MessageMediaPaidMedia{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessageMediaClass: %w", err)
		}
		return &v, nil
	default:
		return nil, fmt.Errorf("unable to decode MessageMediaClass: %w", bin.NewUnexpectedID(id))
	}
}

// MessageMedia boxes the MessageMediaClass providing a helper.
type MessageMediaBox struct {
	MessageMedia MessageMediaClass
}

// Decode implements bin.Decoder for MessageMediaBox.
func (b *MessageMediaBox) Decode(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("unable to decode MessageMediaBox to nil")
	}
	v, err := DecodeMessageMedia(buf)
	if err != nil {
		return fmt.Errorf("unable to decode boxed value: %w", err)
	}
	b.MessageMedia = v
	return nil
}

// Encode implements bin.Encode for MessageMediaBox.
func (b *MessageMediaBox) Encode(buf *bin.Buffer) error {
	if b == nil || b.MessageMedia == nil {
		return fmt.Errorf("unable to encode MessageMediaClass as nil")
	}
	return b.MessageMedia.Encode(buf)
}
