// Code generated by gotdgen, DO NOT EDIT.

package tdapi

import (
	"context"
	"errors"
	"fmt"
	"sort"
	"strings"

	"go.uber.org/multierr"

	"go.mau.fi/mautrix-telegram/pkg/gotd/bin"
	"go.mau.fi/mautrix-telegram/pkg/gotd/tdjson"
	"go.mau.fi/mautrix-telegram/pkg/gotd/tdp"
	"go.mau.fi/mautrix-telegram/pkg/gotd/tgerr"
)

// No-op definition for keeping imports.
var (
	_ = bin.Buffer{}
	_ = context.Background()
	_ = fmt.Stringer(nil)
	_ = strings.Builder{}
	_ = errors.Is
	_ = multierr.AppendInto
	_ = sort.Ints
	_ = tdp.Format
	_ = tgerr.Error{}
	_ = tdjson.Encoder{}
)

// DeviceTokenFirebaseCloudMessaging represents TL type `deviceTokenFirebaseCloudMessaging#d0714a07`.
type DeviceTokenFirebaseCloudMessaging struct {
	// Device registration token; may be empty to deregister a device
	Token string
	// True, if push notifications must be additionally encrypted
	Encrypt bool
}

// DeviceTokenFirebaseCloudMessagingTypeID is TL type id of DeviceTokenFirebaseCloudMessaging.
const DeviceTokenFirebaseCloudMessagingTypeID = 0xd0714a07

// construct implements constructor of DeviceTokenClass.
func (d DeviceTokenFirebaseCloudMessaging) construct() DeviceTokenClass { return &d }

// Ensuring interfaces in compile-time for DeviceTokenFirebaseCloudMessaging.
var (
	_ bin.Encoder     = &DeviceTokenFirebaseCloudMessaging{}
	_ bin.Decoder     = &DeviceTokenFirebaseCloudMessaging{}
	_ bin.BareEncoder = &DeviceTokenFirebaseCloudMessaging{}
	_ bin.BareDecoder = &DeviceTokenFirebaseCloudMessaging{}

	_ DeviceTokenClass = &DeviceTokenFirebaseCloudMessaging{}
)

func (d *DeviceTokenFirebaseCloudMessaging) Zero() bool {
	if d == nil {
		return true
	}
	if !(d.Token == "") {
		return false
	}
	if !(d.Encrypt == false) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (d *DeviceTokenFirebaseCloudMessaging) String() string {
	if d == nil {
		return "DeviceTokenFirebaseCloudMessaging(nil)"
	}
	type Alias DeviceTokenFirebaseCloudMessaging
	return fmt.Sprintf("DeviceTokenFirebaseCloudMessaging%+v", Alias(*d))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*DeviceTokenFirebaseCloudMessaging) TypeID() uint32 {
	return DeviceTokenFirebaseCloudMessagingTypeID
}

// TypeName returns name of type in TL schema.
func (*DeviceTokenFirebaseCloudMessaging) TypeName() string {
	return "deviceTokenFirebaseCloudMessaging"
}

// TypeInfo returns info about TL type.
func (d *DeviceTokenFirebaseCloudMessaging) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "deviceTokenFirebaseCloudMessaging",
		ID:   DeviceTokenFirebaseCloudMessagingTypeID,
	}
	if d == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Token",
			SchemaName: "token",
		},
		{
			Name:       "Encrypt",
			SchemaName: "encrypt",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (d *DeviceTokenFirebaseCloudMessaging) Encode(b *bin.Buffer) error {
	if d == nil {
		return fmt.Errorf("can't encode deviceTokenFirebaseCloudMessaging#d0714a07 as nil")
	}
	b.PutID(DeviceTokenFirebaseCloudMessagingTypeID)
	return d.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (d *DeviceTokenFirebaseCloudMessaging) EncodeBare(b *bin.Buffer) error {
	if d == nil {
		return fmt.Errorf("can't encode deviceTokenFirebaseCloudMessaging#d0714a07 as nil")
	}
	b.PutString(d.Token)
	b.PutBool(d.Encrypt)
	return nil
}

// Decode implements bin.Decoder.
func (d *DeviceTokenFirebaseCloudMessaging) Decode(b *bin.Buffer) error {
	if d == nil {
		return fmt.Errorf("can't decode deviceTokenFirebaseCloudMessaging#d0714a07 to nil")
	}
	if err := b.ConsumeID(DeviceTokenFirebaseCloudMessagingTypeID); err != nil {
		return fmt.Errorf("unable to decode deviceTokenFirebaseCloudMessaging#d0714a07: %w", err)
	}
	return d.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (d *DeviceTokenFirebaseCloudMessaging) DecodeBare(b *bin.Buffer) error {
	if d == nil {
		return fmt.Errorf("can't decode deviceTokenFirebaseCloudMessaging#d0714a07 to nil")
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode deviceTokenFirebaseCloudMessaging#d0714a07: field token: %w", err)
		}
		d.Token = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode deviceTokenFirebaseCloudMessaging#d0714a07: field encrypt: %w", err)
		}
		d.Encrypt = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (d *DeviceTokenFirebaseCloudMessaging) EncodeTDLibJSON(b tdjson.Encoder) error {
	if d == nil {
		return fmt.Errorf("can't encode deviceTokenFirebaseCloudMessaging#d0714a07 as nil")
	}
	b.ObjStart()
	b.PutID("deviceTokenFirebaseCloudMessaging")
	b.Comma()
	b.FieldStart("token")
	b.PutString(d.Token)
	b.Comma()
	b.FieldStart("encrypt")
	b.PutBool(d.Encrypt)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (d *DeviceTokenFirebaseCloudMessaging) DecodeTDLibJSON(b tdjson.Decoder) error {
	if d == nil {
		return fmt.Errorf("can't decode deviceTokenFirebaseCloudMessaging#d0714a07 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("deviceTokenFirebaseCloudMessaging"); err != nil {
				return fmt.Errorf("unable to decode deviceTokenFirebaseCloudMessaging#d0714a07: %w", err)
			}
		case "token":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode deviceTokenFirebaseCloudMessaging#d0714a07: field token: %w", err)
			}
			d.Token = value
		case "encrypt":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode deviceTokenFirebaseCloudMessaging#d0714a07: field encrypt: %w", err)
			}
			d.Encrypt = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetToken returns value of Token field.
func (d *DeviceTokenFirebaseCloudMessaging) GetToken() (value string) {
	if d == nil {
		return
	}
	return d.Token
}

// GetEncrypt returns value of Encrypt field.
func (d *DeviceTokenFirebaseCloudMessaging) GetEncrypt() (value bool) {
	if d == nil {
		return
	}
	return d.Encrypt
}

// DeviceTokenApplePush represents TL type `deviceTokenApplePush#17196bc3`.
type DeviceTokenApplePush struct {
	// Device token; may be empty to deregister a device
	DeviceToken string
	// True, if App Sandbox is enabled
	IsAppSandbox bool
}

// DeviceTokenApplePushTypeID is TL type id of DeviceTokenApplePush.
const DeviceTokenApplePushTypeID = 0x17196bc3

// construct implements constructor of DeviceTokenClass.
func (d DeviceTokenApplePush) construct() DeviceTokenClass { return &d }

// Ensuring interfaces in compile-time for DeviceTokenApplePush.
var (
	_ bin.Encoder     = &DeviceTokenApplePush{}
	_ bin.Decoder     = &DeviceTokenApplePush{}
	_ bin.BareEncoder = &DeviceTokenApplePush{}
	_ bin.BareDecoder = &DeviceTokenApplePush{}

	_ DeviceTokenClass = &DeviceTokenApplePush{}
)

func (d *DeviceTokenApplePush) Zero() bool {
	if d == nil {
		return true
	}
	if !(d.DeviceToken == "") {
		return false
	}
	if !(d.IsAppSandbox == false) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (d *DeviceTokenApplePush) String() string {
	if d == nil {
		return "DeviceTokenApplePush(nil)"
	}
	type Alias DeviceTokenApplePush
	return fmt.Sprintf("DeviceTokenApplePush%+v", Alias(*d))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*DeviceTokenApplePush) TypeID() uint32 {
	return DeviceTokenApplePushTypeID
}

// TypeName returns name of type in TL schema.
func (*DeviceTokenApplePush) TypeName() string {
	return "deviceTokenApplePush"
}

// TypeInfo returns info about TL type.
func (d *DeviceTokenApplePush) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "deviceTokenApplePush",
		ID:   DeviceTokenApplePushTypeID,
	}
	if d == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "DeviceToken",
			SchemaName: "device_token",
		},
		{
			Name:       "IsAppSandbox",
			SchemaName: "is_app_sandbox",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (d *DeviceTokenApplePush) Encode(b *bin.Buffer) error {
	if d == nil {
		return fmt.Errorf("can't encode deviceTokenApplePush#17196bc3 as nil")
	}
	b.PutID(DeviceTokenApplePushTypeID)
	return d.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (d *DeviceTokenApplePush) EncodeBare(b *bin.Buffer) error {
	if d == nil {
		return fmt.Errorf("can't encode deviceTokenApplePush#17196bc3 as nil")
	}
	b.PutString(d.DeviceToken)
	b.PutBool(d.IsAppSandbox)
	return nil
}

// Decode implements bin.Decoder.
func (d *DeviceTokenApplePush) Decode(b *bin.Buffer) error {
	if d == nil {
		return fmt.Errorf("can't decode deviceTokenApplePush#17196bc3 to nil")
	}
	if err := b.ConsumeID(DeviceTokenApplePushTypeID); err != nil {
		return fmt.Errorf("unable to decode deviceTokenApplePush#17196bc3: %w", err)
	}
	return d.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (d *DeviceTokenApplePush) DecodeBare(b *bin.Buffer) error {
	if d == nil {
		return fmt.Errorf("can't decode deviceTokenApplePush#17196bc3 to nil")
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode deviceTokenApplePush#17196bc3: field device_token: %w", err)
		}
		d.DeviceToken = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode deviceTokenApplePush#17196bc3: field is_app_sandbox: %w", err)
		}
		d.IsAppSandbox = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (d *DeviceTokenApplePush) EncodeTDLibJSON(b tdjson.Encoder) error {
	if d == nil {
		return fmt.Errorf("can't encode deviceTokenApplePush#17196bc3 as nil")
	}
	b.ObjStart()
	b.PutID("deviceTokenApplePush")
	b.Comma()
	b.FieldStart("device_token")
	b.PutString(d.DeviceToken)
	b.Comma()
	b.FieldStart("is_app_sandbox")
	b.PutBool(d.IsAppSandbox)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (d *DeviceTokenApplePush) DecodeTDLibJSON(b tdjson.Decoder) error {
	if d == nil {
		return fmt.Errorf("can't decode deviceTokenApplePush#17196bc3 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("deviceTokenApplePush"); err != nil {
				return fmt.Errorf("unable to decode deviceTokenApplePush#17196bc3: %w", err)
			}
		case "device_token":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode deviceTokenApplePush#17196bc3: field device_token: %w", err)
			}
			d.DeviceToken = value
		case "is_app_sandbox":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode deviceTokenApplePush#17196bc3: field is_app_sandbox: %w", err)
			}
			d.IsAppSandbox = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetDeviceToken returns value of DeviceToken field.
func (d *DeviceTokenApplePush) GetDeviceToken() (value string) {
	if d == nil {
		return
	}
	return d.DeviceToken
}

// GetIsAppSandbox returns value of IsAppSandbox field.
func (d *DeviceTokenApplePush) GetIsAppSandbox() (value bool) {
	if d == nil {
		return
	}
	return d.IsAppSandbox
}

// DeviceTokenApplePushVoIP represents TL type `deviceTokenApplePushVoIP#2ff045e9`.
type DeviceTokenApplePushVoIP struct {
	// Device token; may be empty to deregister a device
	DeviceToken string
	// True, if App Sandbox is enabled
	IsAppSandbox bool
	// True, if push notifications must be additionally encrypted
	Encrypt bool
}

// DeviceTokenApplePushVoIPTypeID is TL type id of DeviceTokenApplePushVoIP.
const DeviceTokenApplePushVoIPTypeID = 0x2ff045e9

// construct implements constructor of DeviceTokenClass.
func (d DeviceTokenApplePushVoIP) construct() DeviceTokenClass { return &d }

// Ensuring interfaces in compile-time for DeviceTokenApplePushVoIP.
var (
	_ bin.Encoder     = &DeviceTokenApplePushVoIP{}
	_ bin.Decoder     = &DeviceTokenApplePushVoIP{}
	_ bin.BareEncoder = &DeviceTokenApplePushVoIP{}
	_ bin.BareDecoder = &DeviceTokenApplePushVoIP{}

	_ DeviceTokenClass = &DeviceTokenApplePushVoIP{}
)

func (d *DeviceTokenApplePushVoIP) Zero() bool {
	if d == nil {
		return true
	}
	if !(d.DeviceToken == "") {
		return false
	}
	if !(d.IsAppSandbox == false) {
		return false
	}
	if !(d.Encrypt == false) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (d *DeviceTokenApplePushVoIP) String() string {
	if d == nil {
		return "DeviceTokenApplePushVoIP(nil)"
	}
	type Alias DeviceTokenApplePushVoIP
	return fmt.Sprintf("DeviceTokenApplePushVoIP%+v", Alias(*d))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*DeviceTokenApplePushVoIP) TypeID() uint32 {
	return DeviceTokenApplePushVoIPTypeID
}

// TypeName returns name of type in TL schema.
func (*DeviceTokenApplePushVoIP) TypeName() string {
	return "deviceTokenApplePushVoIP"
}

// TypeInfo returns info about TL type.
func (d *DeviceTokenApplePushVoIP) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "deviceTokenApplePushVoIP",
		ID:   DeviceTokenApplePushVoIPTypeID,
	}
	if d == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "DeviceToken",
			SchemaName: "device_token",
		},
		{
			Name:       "IsAppSandbox",
			SchemaName: "is_app_sandbox",
		},
		{
			Name:       "Encrypt",
			SchemaName: "encrypt",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (d *DeviceTokenApplePushVoIP) Encode(b *bin.Buffer) error {
	if d == nil {
		return fmt.Errorf("can't encode deviceTokenApplePushVoIP#2ff045e9 as nil")
	}
	b.PutID(DeviceTokenApplePushVoIPTypeID)
	return d.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (d *DeviceTokenApplePushVoIP) EncodeBare(b *bin.Buffer) error {
	if d == nil {
		return fmt.Errorf("can't encode deviceTokenApplePushVoIP#2ff045e9 as nil")
	}
	b.PutString(d.DeviceToken)
	b.PutBool(d.IsAppSandbox)
	b.PutBool(d.Encrypt)
	return nil
}

// Decode implements bin.Decoder.
func (d *DeviceTokenApplePushVoIP) Decode(b *bin.Buffer) error {
	if d == nil {
		return fmt.Errorf("can't decode deviceTokenApplePushVoIP#2ff045e9 to nil")
	}
	if err := b.ConsumeID(DeviceTokenApplePushVoIPTypeID); err != nil {
		return fmt.Errorf("unable to decode deviceTokenApplePushVoIP#2ff045e9: %w", err)
	}
	return d.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (d *DeviceTokenApplePushVoIP) DecodeBare(b *bin.Buffer) error {
	if d == nil {
		return fmt.Errorf("can't decode deviceTokenApplePushVoIP#2ff045e9 to nil")
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode deviceTokenApplePushVoIP#2ff045e9: field device_token: %w", err)
		}
		d.DeviceToken = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode deviceTokenApplePushVoIP#2ff045e9: field is_app_sandbox: %w", err)
		}
		d.IsAppSandbox = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode deviceTokenApplePushVoIP#2ff045e9: field encrypt: %w", err)
		}
		d.Encrypt = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (d *DeviceTokenApplePushVoIP) EncodeTDLibJSON(b tdjson.Encoder) error {
	if d == nil {
		return fmt.Errorf("can't encode deviceTokenApplePushVoIP#2ff045e9 as nil")
	}
	b.ObjStart()
	b.PutID("deviceTokenApplePushVoIP")
	b.Comma()
	b.FieldStart("device_token")
	b.PutString(d.DeviceToken)
	b.Comma()
	b.FieldStart("is_app_sandbox")
	b.PutBool(d.IsAppSandbox)
	b.Comma()
	b.FieldStart("encrypt")
	b.PutBool(d.Encrypt)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (d *DeviceTokenApplePushVoIP) DecodeTDLibJSON(b tdjson.Decoder) error {
	if d == nil {
		return fmt.Errorf("can't decode deviceTokenApplePushVoIP#2ff045e9 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("deviceTokenApplePushVoIP"); err != nil {
				return fmt.Errorf("unable to decode deviceTokenApplePushVoIP#2ff045e9: %w", err)
			}
		case "device_token":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode deviceTokenApplePushVoIP#2ff045e9: field device_token: %w", err)
			}
			d.DeviceToken = value
		case "is_app_sandbox":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode deviceTokenApplePushVoIP#2ff045e9: field is_app_sandbox: %w", err)
			}
			d.IsAppSandbox = value
		case "encrypt":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode deviceTokenApplePushVoIP#2ff045e9: field encrypt: %w", err)
			}
			d.Encrypt = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetDeviceToken returns value of DeviceToken field.
func (d *DeviceTokenApplePushVoIP) GetDeviceToken() (value string) {
	if d == nil {
		return
	}
	return d.DeviceToken
}

// GetIsAppSandbox returns value of IsAppSandbox field.
func (d *DeviceTokenApplePushVoIP) GetIsAppSandbox() (value bool) {
	if d == nil {
		return
	}
	return d.IsAppSandbox
}

// GetEncrypt returns value of Encrypt field.
func (d *DeviceTokenApplePushVoIP) GetEncrypt() (value bool) {
	if d == nil {
		return
	}
	return d.Encrypt
}

// DeviceTokenWindowsPush represents TL type `deviceTokenWindowsPush#abed428f`.
type DeviceTokenWindowsPush struct {
	// The access token that will be used to send notifications; may be empty to deregister a
	// device
	AccessToken string
}

// DeviceTokenWindowsPushTypeID is TL type id of DeviceTokenWindowsPush.
const DeviceTokenWindowsPushTypeID = 0xabed428f

// construct implements constructor of DeviceTokenClass.
func (d DeviceTokenWindowsPush) construct() DeviceTokenClass { return &d }

// Ensuring interfaces in compile-time for DeviceTokenWindowsPush.
var (
	_ bin.Encoder     = &DeviceTokenWindowsPush{}
	_ bin.Decoder     = &DeviceTokenWindowsPush{}
	_ bin.BareEncoder = &DeviceTokenWindowsPush{}
	_ bin.BareDecoder = &DeviceTokenWindowsPush{}

	_ DeviceTokenClass = &DeviceTokenWindowsPush{}
)

func (d *DeviceTokenWindowsPush) Zero() bool {
	if d == nil {
		return true
	}
	if !(d.AccessToken == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (d *DeviceTokenWindowsPush) String() string {
	if d == nil {
		return "DeviceTokenWindowsPush(nil)"
	}
	type Alias DeviceTokenWindowsPush
	return fmt.Sprintf("DeviceTokenWindowsPush%+v", Alias(*d))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*DeviceTokenWindowsPush) TypeID() uint32 {
	return DeviceTokenWindowsPushTypeID
}

// TypeName returns name of type in TL schema.
func (*DeviceTokenWindowsPush) TypeName() string {
	return "deviceTokenWindowsPush"
}

// TypeInfo returns info about TL type.
func (d *DeviceTokenWindowsPush) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "deviceTokenWindowsPush",
		ID:   DeviceTokenWindowsPushTypeID,
	}
	if d == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "AccessToken",
			SchemaName: "access_token",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (d *DeviceTokenWindowsPush) Encode(b *bin.Buffer) error {
	if d == nil {
		return fmt.Errorf("can't encode deviceTokenWindowsPush#abed428f as nil")
	}
	b.PutID(DeviceTokenWindowsPushTypeID)
	return d.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (d *DeviceTokenWindowsPush) EncodeBare(b *bin.Buffer) error {
	if d == nil {
		return fmt.Errorf("can't encode deviceTokenWindowsPush#abed428f as nil")
	}
	b.PutString(d.AccessToken)
	return nil
}

// Decode implements bin.Decoder.
func (d *DeviceTokenWindowsPush) Decode(b *bin.Buffer) error {
	if d == nil {
		return fmt.Errorf("can't decode deviceTokenWindowsPush#abed428f to nil")
	}
	if err := b.ConsumeID(DeviceTokenWindowsPushTypeID); err != nil {
		return fmt.Errorf("unable to decode deviceTokenWindowsPush#abed428f: %w", err)
	}
	return d.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (d *DeviceTokenWindowsPush) DecodeBare(b *bin.Buffer) error {
	if d == nil {
		return fmt.Errorf("can't decode deviceTokenWindowsPush#abed428f to nil")
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode deviceTokenWindowsPush#abed428f: field access_token: %w", err)
		}
		d.AccessToken = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (d *DeviceTokenWindowsPush) EncodeTDLibJSON(b tdjson.Encoder) error {
	if d == nil {
		return fmt.Errorf("can't encode deviceTokenWindowsPush#abed428f as nil")
	}
	b.ObjStart()
	b.PutID("deviceTokenWindowsPush")
	b.Comma()
	b.FieldStart("access_token")
	b.PutString(d.AccessToken)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (d *DeviceTokenWindowsPush) DecodeTDLibJSON(b tdjson.Decoder) error {
	if d == nil {
		return fmt.Errorf("can't decode deviceTokenWindowsPush#abed428f to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("deviceTokenWindowsPush"); err != nil {
				return fmt.Errorf("unable to decode deviceTokenWindowsPush#abed428f: %w", err)
			}
		case "access_token":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode deviceTokenWindowsPush#abed428f: field access_token: %w", err)
			}
			d.AccessToken = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetAccessToken returns value of AccessToken field.
func (d *DeviceTokenWindowsPush) GetAccessToken() (value string) {
	if d == nil {
		return
	}
	return d.AccessToken
}

// DeviceTokenMicrosoftPush represents TL type `deviceTokenMicrosoftPush#48f8e04c`.
type DeviceTokenMicrosoftPush struct {
	// Push notification channel URI; may be empty to deregister a device
	ChannelURI string
}

// DeviceTokenMicrosoftPushTypeID is TL type id of DeviceTokenMicrosoftPush.
const DeviceTokenMicrosoftPushTypeID = 0x48f8e04c

// construct implements constructor of DeviceTokenClass.
func (d DeviceTokenMicrosoftPush) construct() DeviceTokenClass { return &d }

// Ensuring interfaces in compile-time for DeviceTokenMicrosoftPush.
var (
	_ bin.Encoder     = &DeviceTokenMicrosoftPush{}
	_ bin.Decoder     = &DeviceTokenMicrosoftPush{}
	_ bin.BareEncoder = &DeviceTokenMicrosoftPush{}
	_ bin.BareDecoder = &DeviceTokenMicrosoftPush{}

	_ DeviceTokenClass = &DeviceTokenMicrosoftPush{}
)

func (d *DeviceTokenMicrosoftPush) Zero() bool {
	if d == nil {
		return true
	}
	if !(d.ChannelURI == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (d *DeviceTokenMicrosoftPush) String() string {
	if d == nil {
		return "DeviceTokenMicrosoftPush(nil)"
	}
	type Alias DeviceTokenMicrosoftPush
	return fmt.Sprintf("DeviceTokenMicrosoftPush%+v", Alias(*d))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*DeviceTokenMicrosoftPush) TypeID() uint32 {
	return DeviceTokenMicrosoftPushTypeID
}

// TypeName returns name of type in TL schema.
func (*DeviceTokenMicrosoftPush) TypeName() string {
	return "deviceTokenMicrosoftPush"
}

// TypeInfo returns info about TL type.
func (d *DeviceTokenMicrosoftPush) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "deviceTokenMicrosoftPush",
		ID:   DeviceTokenMicrosoftPushTypeID,
	}
	if d == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ChannelURI",
			SchemaName: "channel_uri",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (d *DeviceTokenMicrosoftPush) Encode(b *bin.Buffer) error {
	if d == nil {
		return fmt.Errorf("can't encode deviceTokenMicrosoftPush#48f8e04c as nil")
	}
	b.PutID(DeviceTokenMicrosoftPushTypeID)
	return d.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (d *DeviceTokenMicrosoftPush) EncodeBare(b *bin.Buffer) error {
	if d == nil {
		return fmt.Errorf("can't encode deviceTokenMicrosoftPush#48f8e04c as nil")
	}
	b.PutString(d.ChannelURI)
	return nil
}

// Decode implements bin.Decoder.
func (d *DeviceTokenMicrosoftPush) Decode(b *bin.Buffer) error {
	if d == nil {
		return fmt.Errorf("can't decode deviceTokenMicrosoftPush#48f8e04c to nil")
	}
	if err := b.ConsumeID(DeviceTokenMicrosoftPushTypeID); err != nil {
		return fmt.Errorf("unable to decode deviceTokenMicrosoftPush#48f8e04c: %w", err)
	}
	return d.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (d *DeviceTokenMicrosoftPush) DecodeBare(b *bin.Buffer) error {
	if d == nil {
		return fmt.Errorf("can't decode deviceTokenMicrosoftPush#48f8e04c to nil")
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode deviceTokenMicrosoftPush#48f8e04c: field channel_uri: %w", err)
		}
		d.ChannelURI = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (d *DeviceTokenMicrosoftPush) EncodeTDLibJSON(b tdjson.Encoder) error {
	if d == nil {
		return fmt.Errorf("can't encode deviceTokenMicrosoftPush#48f8e04c as nil")
	}
	b.ObjStart()
	b.PutID("deviceTokenMicrosoftPush")
	b.Comma()
	b.FieldStart("channel_uri")
	b.PutString(d.ChannelURI)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (d *DeviceTokenMicrosoftPush) DecodeTDLibJSON(b tdjson.Decoder) error {
	if d == nil {
		return fmt.Errorf("can't decode deviceTokenMicrosoftPush#48f8e04c to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("deviceTokenMicrosoftPush"); err != nil {
				return fmt.Errorf("unable to decode deviceTokenMicrosoftPush#48f8e04c: %w", err)
			}
		case "channel_uri":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode deviceTokenMicrosoftPush#48f8e04c: field channel_uri: %w", err)
			}
			d.ChannelURI = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetChannelURI returns value of ChannelURI field.
func (d *DeviceTokenMicrosoftPush) GetChannelURI() (value string) {
	if d == nil {
		return
	}
	return d.ChannelURI
}

// DeviceTokenMicrosoftPushVoIP represents TL type `deviceTokenMicrosoftPushVoIP#d12ca351`.
type DeviceTokenMicrosoftPushVoIP struct {
	// Push notification channel URI; may be empty to deregister a device
	ChannelURI string
}

// DeviceTokenMicrosoftPushVoIPTypeID is TL type id of DeviceTokenMicrosoftPushVoIP.
const DeviceTokenMicrosoftPushVoIPTypeID = 0xd12ca351

// construct implements constructor of DeviceTokenClass.
func (d DeviceTokenMicrosoftPushVoIP) construct() DeviceTokenClass { return &d }

// Ensuring interfaces in compile-time for DeviceTokenMicrosoftPushVoIP.
var (
	_ bin.Encoder     = &DeviceTokenMicrosoftPushVoIP{}
	_ bin.Decoder     = &DeviceTokenMicrosoftPushVoIP{}
	_ bin.BareEncoder = &DeviceTokenMicrosoftPushVoIP{}
	_ bin.BareDecoder = &DeviceTokenMicrosoftPushVoIP{}

	_ DeviceTokenClass = &DeviceTokenMicrosoftPushVoIP{}
)

func (d *DeviceTokenMicrosoftPushVoIP) Zero() bool {
	if d == nil {
		return true
	}
	if !(d.ChannelURI == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (d *DeviceTokenMicrosoftPushVoIP) String() string {
	if d == nil {
		return "DeviceTokenMicrosoftPushVoIP(nil)"
	}
	type Alias DeviceTokenMicrosoftPushVoIP
	return fmt.Sprintf("DeviceTokenMicrosoftPushVoIP%+v", Alias(*d))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*DeviceTokenMicrosoftPushVoIP) TypeID() uint32 {
	return DeviceTokenMicrosoftPushVoIPTypeID
}

// TypeName returns name of type in TL schema.
func (*DeviceTokenMicrosoftPushVoIP) TypeName() string {
	return "deviceTokenMicrosoftPushVoIP"
}

// TypeInfo returns info about TL type.
func (d *DeviceTokenMicrosoftPushVoIP) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "deviceTokenMicrosoftPushVoIP",
		ID:   DeviceTokenMicrosoftPushVoIPTypeID,
	}
	if d == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ChannelURI",
			SchemaName: "channel_uri",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (d *DeviceTokenMicrosoftPushVoIP) Encode(b *bin.Buffer) error {
	if d == nil {
		return fmt.Errorf("can't encode deviceTokenMicrosoftPushVoIP#d12ca351 as nil")
	}
	b.PutID(DeviceTokenMicrosoftPushVoIPTypeID)
	return d.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (d *DeviceTokenMicrosoftPushVoIP) EncodeBare(b *bin.Buffer) error {
	if d == nil {
		return fmt.Errorf("can't encode deviceTokenMicrosoftPushVoIP#d12ca351 as nil")
	}
	b.PutString(d.ChannelURI)
	return nil
}

// Decode implements bin.Decoder.
func (d *DeviceTokenMicrosoftPushVoIP) Decode(b *bin.Buffer) error {
	if d == nil {
		return fmt.Errorf("can't decode deviceTokenMicrosoftPushVoIP#d12ca351 to nil")
	}
	if err := b.ConsumeID(DeviceTokenMicrosoftPushVoIPTypeID); err != nil {
		return fmt.Errorf("unable to decode deviceTokenMicrosoftPushVoIP#d12ca351: %w", err)
	}
	return d.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (d *DeviceTokenMicrosoftPushVoIP) DecodeBare(b *bin.Buffer) error {
	if d == nil {
		return fmt.Errorf("can't decode deviceTokenMicrosoftPushVoIP#d12ca351 to nil")
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode deviceTokenMicrosoftPushVoIP#d12ca351: field channel_uri: %w", err)
		}
		d.ChannelURI = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (d *DeviceTokenMicrosoftPushVoIP) EncodeTDLibJSON(b tdjson.Encoder) error {
	if d == nil {
		return fmt.Errorf("can't encode deviceTokenMicrosoftPushVoIP#d12ca351 as nil")
	}
	b.ObjStart()
	b.PutID("deviceTokenMicrosoftPushVoIP")
	b.Comma()
	b.FieldStart("channel_uri")
	b.PutString(d.ChannelURI)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (d *DeviceTokenMicrosoftPushVoIP) DecodeTDLibJSON(b tdjson.Decoder) error {
	if d == nil {
		return fmt.Errorf("can't decode deviceTokenMicrosoftPushVoIP#d12ca351 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("deviceTokenMicrosoftPushVoIP"); err != nil {
				return fmt.Errorf("unable to decode deviceTokenMicrosoftPushVoIP#d12ca351: %w", err)
			}
		case "channel_uri":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode deviceTokenMicrosoftPushVoIP#d12ca351: field channel_uri: %w", err)
			}
			d.ChannelURI = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetChannelURI returns value of ChannelURI field.
func (d *DeviceTokenMicrosoftPushVoIP) GetChannelURI() (value string) {
	if d == nil {
		return
	}
	return d.ChannelURI
}

// DeviceTokenWebPush represents TL type `deviceTokenWebPush#9affdef7`.
type DeviceTokenWebPush struct {
	// Absolute URL exposed by the push service where the application server can send push
	// messages; may be empty to deregister a device
	Endpoint string
	// Base64url-encoded P-256 elliptic curve Diffie-Hellman public key
	P256dhBase64url string
	// Base64url-encoded authentication secret
	AuthBase64url string
}

// DeviceTokenWebPushTypeID is TL type id of DeviceTokenWebPush.
const DeviceTokenWebPushTypeID = 0x9affdef7

// construct implements constructor of DeviceTokenClass.
func (d DeviceTokenWebPush) construct() DeviceTokenClass { return &d }

// Ensuring interfaces in compile-time for DeviceTokenWebPush.
var (
	_ bin.Encoder     = &DeviceTokenWebPush{}
	_ bin.Decoder     = &DeviceTokenWebPush{}
	_ bin.BareEncoder = &DeviceTokenWebPush{}
	_ bin.BareDecoder = &DeviceTokenWebPush{}

	_ DeviceTokenClass = &DeviceTokenWebPush{}
)

func (d *DeviceTokenWebPush) Zero() bool {
	if d == nil {
		return true
	}
	if !(d.Endpoint == "") {
		return false
	}
	if !(d.P256dhBase64url == "") {
		return false
	}
	if !(d.AuthBase64url == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (d *DeviceTokenWebPush) String() string {
	if d == nil {
		return "DeviceTokenWebPush(nil)"
	}
	type Alias DeviceTokenWebPush
	return fmt.Sprintf("DeviceTokenWebPush%+v", Alias(*d))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*DeviceTokenWebPush) TypeID() uint32 {
	return DeviceTokenWebPushTypeID
}

// TypeName returns name of type in TL schema.
func (*DeviceTokenWebPush) TypeName() string {
	return "deviceTokenWebPush"
}

// TypeInfo returns info about TL type.
func (d *DeviceTokenWebPush) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "deviceTokenWebPush",
		ID:   DeviceTokenWebPushTypeID,
	}
	if d == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Endpoint",
			SchemaName: "endpoint",
		},
		{
			Name:       "P256dhBase64url",
			SchemaName: "p256dh_base64url",
		},
		{
			Name:       "AuthBase64url",
			SchemaName: "auth_base64url",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (d *DeviceTokenWebPush) Encode(b *bin.Buffer) error {
	if d == nil {
		return fmt.Errorf("can't encode deviceTokenWebPush#9affdef7 as nil")
	}
	b.PutID(DeviceTokenWebPushTypeID)
	return d.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (d *DeviceTokenWebPush) EncodeBare(b *bin.Buffer) error {
	if d == nil {
		return fmt.Errorf("can't encode deviceTokenWebPush#9affdef7 as nil")
	}
	b.PutString(d.Endpoint)
	b.PutString(d.P256dhBase64url)
	b.PutString(d.AuthBase64url)
	return nil
}

// Decode implements bin.Decoder.
func (d *DeviceTokenWebPush) Decode(b *bin.Buffer) error {
	if d == nil {
		return fmt.Errorf("can't decode deviceTokenWebPush#9affdef7 to nil")
	}
	if err := b.ConsumeID(DeviceTokenWebPushTypeID); err != nil {
		return fmt.Errorf("unable to decode deviceTokenWebPush#9affdef7: %w", err)
	}
	return d.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (d *DeviceTokenWebPush) DecodeBare(b *bin.Buffer) error {
	if d == nil {
		return fmt.Errorf("can't decode deviceTokenWebPush#9affdef7 to nil")
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode deviceTokenWebPush#9affdef7: field endpoint: %w", err)
		}
		d.Endpoint = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode deviceTokenWebPush#9affdef7: field p256dh_base64url: %w", err)
		}
		d.P256dhBase64url = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode deviceTokenWebPush#9affdef7: field auth_base64url: %w", err)
		}
		d.AuthBase64url = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (d *DeviceTokenWebPush) EncodeTDLibJSON(b tdjson.Encoder) error {
	if d == nil {
		return fmt.Errorf("can't encode deviceTokenWebPush#9affdef7 as nil")
	}
	b.ObjStart()
	b.PutID("deviceTokenWebPush")
	b.Comma()
	b.FieldStart("endpoint")
	b.PutString(d.Endpoint)
	b.Comma()
	b.FieldStart("p256dh_base64url")
	b.PutString(d.P256dhBase64url)
	b.Comma()
	b.FieldStart("auth_base64url")
	b.PutString(d.AuthBase64url)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (d *DeviceTokenWebPush) DecodeTDLibJSON(b tdjson.Decoder) error {
	if d == nil {
		return fmt.Errorf("can't decode deviceTokenWebPush#9affdef7 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("deviceTokenWebPush"); err != nil {
				return fmt.Errorf("unable to decode deviceTokenWebPush#9affdef7: %w", err)
			}
		case "endpoint":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode deviceTokenWebPush#9affdef7: field endpoint: %w", err)
			}
			d.Endpoint = value
		case "p256dh_base64url":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode deviceTokenWebPush#9affdef7: field p256dh_base64url: %w", err)
			}
			d.P256dhBase64url = value
		case "auth_base64url":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode deviceTokenWebPush#9affdef7: field auth_base64url: %w", err)
			}
			d.AuthBase64url = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetEndpoint returns value of Endpoint field.
func (d *DeviceTokenWebPush) GetEndpoint() (value string) {
	if d == nil {
		return
	}
	return d.Endpoint
}

// GetP256dhBase64url returns value of P256dhBase64url field.
func (d *DeviceTokenWebPush) GetP256dhBase64url() (value string) {
	if d == nil {
		return
	}
	return d.P256dhBase64url
}

// GetAuthBase64url returns value of AuthBase64url field.
func (d *DeviceTokenWebPush) GetAuthBase64url() (value string) {
	if d == nil {
		return
	}
	return d.AuthBase64url
}

// DeviceTokenSimplePush represents TL type `deviceTokenSimplePush#2f49a60`.
type DeviceTokenSimplePush struct {
	// Absolute URL exposed by the push service where the application server can send push
	// messages; may be empty to deregister a device
	Endpoint string
}

// DeviceTokenSimplePushTypeID is TL type id of DeviceTokenSimplePush.
const DeviceTokenSimplePushTypeID = 0x2f49a60

// construct implements constructor of DeviceTokenClass.
func (d DeviceTokenSimplePush) construct() DeviceTokenClass { return &d }

// Ensuring interfaces in compile-time for DeviceTokenSimplePush.
var (
	_ bin.Encoder     = &DeviceTokenSimplePush{}
	_ bin.Decoder     = &DeviceTokenSimplePush{}
	_ bin.BareEncoder = &DeviceTokenSimplePush{}
	_ bin.BareDecoder = &DeviceTokenSimplePush{}

	_ DeviceTokenClass = &DeviceTokenSimplePush{}
)

func (d *DeviceTokenSimplePush) Zero() bool {
	if d == nil {
		return true
	}
	if !(d.Endpoint == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (d *DeviceTokenSimplePush) String() string {
	if d == nil {
		return "DeviceTokenSimplePush(nil)"
	}
	type Alias DeviceTokenSimplePush
	return fmt.Sprintf("DeviceTokenSimplePush%+v", Alias(*d))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*DeviceTokenSimplePush) TypeID() uint32 {
	return DeviceTokenSimplePushTypeID
}

// TypeName returns name of type in TL schema.
func (*DeviceTokenSimplePush) TypeName() string {
	return "deviceTokenSimplePush"
}

// TypeInfo returns info about TL type.
func (d *DeviceTokenSimplePush) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "deviceTokenSimplePush",
		ID:   DeviceTokenSimplePushTypeID,
	}
	if d == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Endpoint",
			SchemaName: "endpoint",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (d *DeviceTokenSimplePush) Encode(b *bin.Buffer) error {
	if d == nil {
		return fmt.Errorf("can't encode deviceTokenSimplePush#2f49a60 as nil")
	}
	b.PutID(DeviceTokenSimplePushTypeID)
	return d.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (d *DeviceTokenSimplePush) EncodeBare(b *bin.Buffer) error {
	if d == nil {
		return fmt.Errorf("can't encode deviceTokenSimplePush#2f49a60 as nil")
	}
	b.PutString(d.Endpoint)
	return nil
}

// Decode implements bin.Decoder.
func (d *DeviceTokenSimplePush) Decode(b *bin.Buffer) error {
	if d == nil {
		return fmt.Errorf("can't decode deviceTokenSimplePush#2f49a60 to nil")
	}
	if err := b.ConsumeID(DeviceTokenSimplePushTypeID); err != nil {
		return fmt.Errorf("unable to decode deviceTokenSimplePush#2f49a60: %w", err)
	}
	return d.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (d *DeviceTokenSimplePush) DecodeBare(b *bin.Buffer) error {
	if d == nil {
		return fmt.Errorf("can't decode deviceTokenSimplePush#2f49a60 to nil")
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode deviceTokenSimplePush#2f49a60: field endpoint: %w", err)
		}
		d.Endpoint = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (d *DeviceTokenSimplePush) EncodeTDLibJSON(b tdjson.Encoder) error {
	if d == nil {
		return fmt.Errorf("can't encode deviceTokenSimplePush#2f49a60 as nil")
	}
	b.ObjStart()
	b.PutID("deviceTokenSimplePush")
	b.Comma()
	b.FieldStart("endpoint")
	b.PutString(d.Endpoint)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (d *DeviceTokenSimplePush) DecodeTDLibJSON(b tdjson.Decoder) error {
	if d == nil {
		return fmt.Errorf("can't decode deviceTokenSimplePush#2f49a60 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("deviceTokenSimplePush"); err != nil {
				return fmt.Errorf("unable to decode deviceTokenSimplePush#2f49a60: %w", err)
			}
		case "endpoint":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode deviceTokenSimplePush#2f49a60: field endpoint: %w", err)
			}
			d.Endpoint = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetEndpoint returns value of Endpoint field.
func (d *DeviceTokenSimplePush) GetEndpoint() (value string) {
	if d == nil {
		return
	}
	return d.Endpoint
}

// DeviceTokenUbuntuPush represents TL type `deviceTokenUbuntuPush#6a3c0d26`.
type DeviceTokenUbuntuPush struct {
	// Token; may be empty to deregister a device
	Token string
}

// DeviceTokenUbuntuPushTypeID is TL type id of DeviceTokenUbuntuPush.
const DeviceTokenUbuntuPushTypeID = 0x6a3c0d26

// construct implements constructor of DeviceTokenClass.
func (d DeviceTokenUbuntuPush) construct() DeviceTokenClass { return &d }

// Ensuring interfaces in compile-time for DeviceTokenUbuntuPush.
var (
	_ bin.Encoder     = &DeviceTokenUbuntuPush{}
	_ bin.Decoder     = &DeviceTokenUbuntuPush{}
	_ bin.BareEncoder = &DeviceTokenUbuntuPush{}
	_ bin.BareDecoder = &DeviceTokenUbuntuPush{}

	_ DeviceTokenClass = &DeviceTokenUbuntuPush{}
)

func (d *DeviceTokenUbuntuPush) Zero() bool {
	if d == nil {
		return true
	}
	if !(d.Token == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (d *DeviceTokenUbuntuPush) String() string {
	if d == nil {
		return "DeviceTokenUbuntuPush(nil)"
	}
	type Alias DeviceTokenUbuntuPush
	return fmt.Sprintf("DeviceTokenUbuntuPush%+v", Alias(*d))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*DeviceTokenUbuntuPush) TypeID() uint32 {
	return DeviceTokenUbuntuPushTypeID
}

// TypeName returns name of type in TL schema.
func (*DeviceTokenUbuntuPush) TypeName() string {
	return "deviceTokenUbuntuPush"
}

// TypeInfo returns info about TL type.
func (d *DeviceTokenUbuntuPush) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "deviceTokenUbuntuPush",
		ID:   DeviceTokenUbuntuPushTypeID,
	}
	if d == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Token",
			SchemaName: "token",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (d *DeviceTokenUbuntuPush) Encode(b *bin.Buffer) error {
	if d == nil {
		return fmt.Errorf("can't encode deviceTokenUbuntuPush#6a3c0d26 as nil")
	}
	b.PutID(DeviceTokenUbuntuPushTypeID)
	return d.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (d *DeviceTokenUbuntuPush) EncodeBare(b *bin.Buffer) error {
	if d == nil {
		return fmt.Errorf("can't encode deviceTokenUbuntuPush#6a3c0d26 as nil")
	}
	b.PutString(d.Token)
	return nil
}

// Decode implements bin.Decoder.
func (d *DeviceTokenUbuntuPush) Decode(b *bin.Buffer) error {
	if d == nil {
		return fmt.Errorf("can't decode deviceTokenUbuntuPush#6a3c0d26 to nil")
	}
	if err := b.ConsumeID(DeviceTokenUbuntuPushTypeID); err != nil {
		return fmt.Errorf("unable to decode deviceTokenUbuntuPush#6a3c0d26: %w", err)
	}
	return d.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (d *DeviceTokenUbuntuPush) DecodeBare(b *bin.Buffer) error {
	if d == nil {
		return fmt.Errorf("can't decode deviceTokenUbuntuPush#6a3c0d26 to nil")
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode deviceTokenUbuntuPush#6a3c0d26: field token: %w", err)
		}
		d.Token = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (d *DeviceTokenUbuntuPush) EncodeTDLibJSON(b tdjson.Encoder) error {
	if d == nil {
		return fmt.Errorf("can't encode deviceTokenUbuntuPush#6a3c0d26 as nil")
	}
	b.ObjStart()
	b.PutID("deviceTokenUbuntuPush")
	b.Comma()
	b.FieldStart("token")
	b.PutString(d.Token)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (d *DeviceTokenUbuntuPush) DecodeTDLibJSON(b tdjson.Decoder) error {
	if d == nil {
		return fmt.Errorf("can't decode deviceTokenUbuntuPush#6a3c0d26 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("deviceTokenUbuntuPush"); err != nil {
				return fmt.Errorf("unable to decode deviceTokenUbuntuPush#6a3c0d26: %w", err)
			}
		case "token":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode deviceTokenUbuntuPush#6a3c0d26: field token: %w", err)
			}
			d.Token = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetToken returns value of Token field.
func (d *DeviceTokenUbuntuPush) GetToken() (value string) {
	if d == nil {
		return
	}
	return d.Token
}

// DeviceTokenBlackBerryPush represents TL type `deviceTokenBlackBerryPush#5cef0102`.
type DeviceTokenBlackBerryPush struct {
	// Token; may be empty to deregister a device
	Token string
}

// DeviceTokenBlackBerryPushTypeID is TL type id of DeviceTokenBlackBerryPush.
const DeviceTokenBlackBerryPushTypeID = 0x5cef0102

// construct implements constructor of DeviceTokenClass.
func (d DeviceTokenBlackBerryPush) construct() DeviceTokenClass { return &d }

// Ensuring interfaces in compile-time for DeviceTokenBlackBerryPush.
var (
	_ bin.Encoder     = &DeviceTokenBlackBerryPush{}
	_ bin.Decoder     = &DeviceTokenBlackBerryPush{}
	_ bin.BareEncoder = &DeviceTokenBlackBerryPush{}
	_ bin.BareDecoder = &DeviceTokenBlackBerryPush{}

	_ DeviceTokenClass = &DeviceTokenBlackBerryPush{}
)

func (d *DeviceTokenBlackBerryPush) Zero() bool {
	if d == nil {
		return true
	}
	if !(d.Token == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (d *DeviceTokenBlackBerryPush) String() string {
	if d == nil {
		return "DeviceTokenBlackBerryPush(nil)"
	}
	type Alias DeviceTokenBlackBerryPush
	return fmt.Sprintf("DeviceTokenBlackBerryPush%+v", Alias(*d))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*DeviceTokenBlackBerryPush) TypeID() uint32 {
	return DeviceTokenBlackBerryPushTypeID
}

// TypeName returns name of type in TL schema.
func (*DeviceTokenBlackBerryPush) TypeName() string {
	return "deviceTokenBlackBerryPush"
}

// TypeInfo returns info about TL type.
func (d *DeviceTokenBlackBerryPush) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "deviceTokenBlackBerryPush",
		ID:   DeviceTokenBlackBerryPushTypeID,
	}
	if d == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Token",
			SchemaName: "token",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (d *DeviceTokenBlackBerryPush) Encode(b *bin.Buffer) error {
	if d == nil {
		return fmt.Errorf("can't encode deviceTokenBlackBerryPush#5cef0102 as nil")
	}
	b.PutID(DeviceTokenBlackBerryPushTypeID)
	return d.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (d *DeviceTokenBlackBerryPush) EncodeBare(b *bin.Buffer) error {
	if d == nil {
		return fmt.Errorf("can't encode deviceTokenBlackBerryPush#5cef0102 as nil")
	}
	b.PutString(d.Token)
	return nil
}

// Decode implements bin.Decoder.
func (d *DeviceTokenBlackBerryPush) Decode(b *bin.Buffer) error {
	if d == nil {
		return fmt.Errorf("can't decode deviceTokenBlackBerryPush#5cef0102 to nil")
	}
	if err := b.ConsumeID(DeviceTokenBlackBerryPushTypeID); err != nil {
		return fmt.Errorf("unable to decode deviceTokenBlackBerryPush#5cef0102: %w", err)
	}
	return d.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (d *DeviceTokenBlackBerryPush) DecodeBare(b *bin.Buffer) error {
	if d == nil {
		return fmt.Errorf("can't decode deviceTokenBlackBerryPush#5cef0102 to nil")
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode deviceTokenBlackBerryPush#5cef0102: field token: %w", err)
		}
		d.Token = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (d *DeviceTokenBlackBerryPush) EncodeTDLibJSON(b tdjson.Encoder) error {
	if d == nil {
		return fmt.Errorf("can't encode deviceTokenBlackBerryPush#5cef0102 as nil")
	}
	b.ObjStart()
	b.PutID("deviceTokenBlackBerryPush")
	b.Comma()
	b.FieldStart("token")
	b.PutString(d.Token)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (d *DeviceTokenBlackBerryPush) DecodeTDLibJSON(b tdjson.Decoder) error {
	if d == nil {
		return fmt.Errorf("can't decode deviceTokenBlackBerryPush#5cef0102 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("deviceTokenBlackBerryPush"); err != nil {
				return fmt.Errorf("unable to decode deviceTokenBlackBerryPush#5cef0102: %w", err)
			}
		case "token":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode deviceTokenBlackBerryPush#5cef0102: field token: %w", err)
			}
			d.Token = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetToken returns value of Token field.
func (d *DeviceTokenBlackBerryPush) GetToken() (value string) {
	if d == nil {
		return
	}
	return d.Token
}

// DeviceTokenTizenPush represents TL type `deviceTokenTizenPush#aef0da33`.
type DeviceTokenTizenPush struct {
	// Push service registration identifier; may be empty to deregister a device
	RegID string
}

// DeviceTokenTizenPushTypeID is TL type id of DeviceTokenTizenPush.
const DeviceTokenTizenPushTypeID = 0xaef0da33

// construct implements constructor of DeviceTokenClass.
func (d DeviceTokenTizenPush) construct() DeviceTokenClass { return &d }

// Ensuring interfaces in compile-time for DeviceTokenTizenPush.
var (
	_ bin.Encoder     = &DeviceTokenTizenPush{}
	_ bin.Decoder     = &DeviceTokenTizenPush{}
	_ bin.BareEncoder = &DeviceTokenTizenPush{}
	_ bin.BareDecoder = &DeviceTokenTizenPush{}

	_ DeviceTokenClass = &DeviceTokenTizenPush{}
)

func (d *DeviceTokenTizenPush) Zero() bool {
	if d == nil {
		return true
	}
	if !(d.RegID == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (d *DeviceTokenTizenPush) String() string {
	if d == nil {
		return "DeviceTokenTizenPush(nil)"
	}
	type Alias DeviceTokenTizenPush
	return fmt.Sprintf("DeviceTokenTizenPush%+v", Alias(*d))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*DeviceTokenTizenPush) TypeID() uint32 {
	return DeviceTokenTizenPushTypeID
}

// TypeName returns name of type in TL schema.
func (*DeviceTokenTizenPush) TypeName() string {
	return "deviceTokenTizenPush"
}

// TypeInfo returns info about TL type.
func (d *DeviceTokenTizenPush) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "deviceTokenTizenPush",
		ID:   DeviceTokenTizenPushTypeID,
	}
	if d == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "RegID",
			SchemaName: "reg_id",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (d *DeviceTokenTizenPush) Encode(b *bin.Buffer) error {
	if d == nil {
		return fmt.Errorf("can't encode deviceTokenTizenPush#aef0da33 as nil")
	}
	b.PutID(DeviceTokenTizenPushTypeID)
	return d.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (d *DeviceTokenTizenPush) EncodeBare(b *bin.Buffer) error {
	if d == nil {
		return fmt.Errorf("can't encode deviceTokenTizenPush#aef0da33 as nil")
	}
	b.PutString(d.RegID)
	return nil
}

// Decode implements bin.Decoder.
func (d *DeviceTokenTizenPush) Decode(b *bin.Buffer) error {
	if d == nil {
		return fmt.Errorf("can't decode deviceTokenTizenPush#aef0da33 to nil")
	}
	if err := b.ConsumeID(DeviceTokenTizenPushTypeID); err != nil {
		return fmt.Errorf("unable to decode deviceTokenTizenPush#aef0da33: %w", err)
	}
	return d.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (d *DeviceTokenTizenPush) DecodeBare(b *bin.Buffer) error {
	if d == nil {
		return fmt.Errorf("can't decode deviceTokenTizenPush#aef0da33 to nil")
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode deviceTokenTizenPush#aef0da33: field reg_id: %w", err)
		}
		d.RegID = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (d *DeviceTokenTizenPush) EncodeTDLibJSON(b tdjson.Encoder) error {
	if d == nil {
		return fmt.Errorf("can't encode deviceTokenTizenPush#aef0da33 as nil")
	}
	b.ObjStart()
	b.PutID("deviceTokenTizenPush")
	b.Comma()
	b.FieldStart("reg_id")
	b.PutString(d.RegID)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (d *DeviceTokenTizenPush) DecodeTDLibJSON(b tdjson.Decoder) error {
	if d == nil {
		return fmt.Errorf("can't decode deviceTokenTizenPush#aef0da33 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("deviceTokenTizenPush"); err != nil {
				return fmt.Errorf("unable to decode deviceTokenTizenPush#aef0da33: %w", err)
			}
		case "reg_id":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode deviceTokenTizenPush#aef0da33: field reg_id: %w", err)
			}
			d.RegID = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetRegID returns value of RegID field.
func (d *DeviceTokenTizenPush) GetRegID() (value string) {
	if d == nil {
		return
	}
	return d.RegID
}

// DeviceTokenHuaweiPush represents TL type `deviceTokenHuaweiPush#768f4e26`.
type DeviceTokenHuaweiPush struct {
	// Device registration token; may be empty to deregister a device
	Token string
	// True, if push notifications must be additionally encrypted
	Encrypt bool
}

// DeviceTokenHuaweiPushTypeID is TL type id of DeviceTokenHuaweiPush.
const DeviceTokenHuaweiPushTypeID = 0x768f4e26

// construct implements constructor of DeviceTokenClass.
func (d DeviceTokenHuaweiPush) construct() DeviceTokenClass { return &d }

// Ensuring interfaces in compile-time for DeviceTokenHuaweiPush.
var (
	_ bin.Encoder     = &DeviceTokenHuaweiPush{}
	_ bin.Decoder     = &DeviceTokenHuaweiPush{}
	_ bin.BareEncoder = &DeviceTokenHuaweiPush{}
	_ bin.BareDecoder = &DeviceTokenHuaweiPush{}

	_ DeviceTokenClass = &DeviceTokenHuaweiPush{}
)

func (d *DeviceTokenHuaweiPush) Zero() bool {
	if d == nil {
		return true
	}
	if !(d.Token == "") {
		return false
	}
	if !(d.Encrypt == false) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (d *DeviceTokenHuaweiPush) String() string {
	if d == nil {
		return "DeviceTokenHuaweiPush(nil)"
	}
	type Alias DeviceTokenHuaweiPush
	return fmt.Sprintf("DeviceTokenHuaweiPush%+v", Alias(*d))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*DeviceTokenHuaweiPush) TypeID() uint32 {
	return DeviceTokenHuaweiPushTypeID
}

// TypeName returns name of type in TL schema.
func (*DeviceTokenHuaweiPush) TypeName() string {
	return "deviceTokenHuaweiPush"
}

// TypeInfo returns info about TL type.
func (d *DeviceTokenHuaweiPush) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "deviceTokenHuaweiPush",
		ID:   DeviceTokenHuaweiPushTypeID,
	}
	if d == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Token",
			SchemaName: "token",
		},
		{
			Name:       "Encrypt",
			SchemaName: "encrypt",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (d *DeviceTokenHuaweiPush) Encode(b *bin.Buffer) error {
	if d == nil {
		return fmt.Errorf("can't encode deviceTokenHuaweiPush#768f4e26 as nil")
	}
	b.PutID(DeviceTokenHuaweiPushTypeID)
	return d.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (d *DeviceTokenHuaweiPush) EncodeBare(b *bin.Buffer) error {
	if d == nil {
		return fmt.Errorf("can't encode deviceTokenHuaweiPush#768f4e26 as nil")
	}
	b.PutString(d.Token)
	b.PutBool(d.Encrypt)
	return nil
}

// Decode implements bin.Decoder.
func (d *DeviceTokenHuaweiPush) Decode(b *bin.Buffer) error {
	if d == nil {
		return fmt.Errorf("can't decode deviceTokenHuaweiPush#768f4e26 to nil")
	}
	if err := b.ConsumeID(DeviceTokenHuaweiPushTypeID); err != nil {
		return fmt.Errorf("unable to decode deviceTokenHuaweiPush#768f4e26: %w", err)
	}
	return d.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (d *DeviceTokenHuaweiPush) DecodeBare(b *bin.Buffer) error {
	if d == nil {
		return fmt.Errorf("can't decode deviceTokenHuaweiPush#768f4e26 to nil")
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode deviceTokenHuaweiPush#768f4e26: field token: %w", err)
		}
		d.Token = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode deviceTokenHuaweiPush#768f4e26: field encrypt: %w", err)
		}
		d.Encrypt = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (d *DeviceTokenHuaweiPush) EncodeTDLibJSON(b tdjson.Encoder) error {
	if d == nil {
		return fmt.Errorf("can't encode deviceTokenHuaweiPush#768f4e26 as nil")
	}
	b.ObjStart()
	b.PutID("deviceTokenHuaweiPush")
	b.Comma()
	b.FieldStart("token")
	b.PutString(d.Token)
	b.Comma()
	b.FieldStart("encrypt")
	b.PutBool(d.Encrypt)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (d *DeviceTokenHuaweiPush) DecodeTDLibJSON(b tdjson.Decoder) error {
	if d == nil {
		return fmt.Errorf("can't decode deviceTokenHuaweiPush#768f4e26 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("deviceTokenHuaweiPush"); err != nil {
				return fmt.Errorf("unable to decode deviceTokenHuaweiPush#768f4e26: %w", err)
			}
		case "token":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode deviceTokenHuaweiPush#768f4e26: field token: %w", err)
			}
			d.Token = value
		case "encrypt":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode deviceTokenHuaweiPush#768f4e26: field encrypt: %w", err)
			}
			d.Encrypt = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetToken returns value of Token field.
func (d *DeviceTokenHuaweiPush) GetToken() (value string) {
	if d == nil {
		return
	}
	return d.Token
}

// GetEncrypt returns value of Encrypt field.
func (d *DeviceTokenHuaweiPush) GetEncrypt() (value bool) {
	if d == nil {
		return
	}
	return d.Encrypt
}

// DeviceTokenClassName is schema name of DeviceTokenClass.
const DeviceTokenClassName = "DeviceToken"

// DeviceTokenClass represents DeviceToken generic type.
//
// Example:
//
//	g, err := tdapi.DecodeDeviceToken(buf)
//	if err != nil {
//	    panic(err)
//	}
//	switch v := g.(type) {
//	case *tdapi.DeviceTokenFirebaseCloudMessaging: // deviceTokenFirebaseCloudMessaging#d0714a07
//	case *tdapi.DeviceTokenApplePush: // deviceTokenApplePush#17196bc3
//	case *tdapi.DeviceTokenApplePushVoIP: // deviceTokenApplePushVoIP#2ff045e9
//	case *tdapi.DeviceTokenWindowsPush: // deviceTokenWindowsPush#abed428f
//	case *tdapi.DeviceTokenMicrosoftPush: // deviceTokenMicrosoftPush#48f8e04c
//	case *tdapi.DeviceTokenMicrosoftPushVoIP: // deviceTokenMicrosoftPushVoIP#d12ca351
//	case *tdapi.DeviceTokenWebPush: // deviceTokenWebPush#9affdef7
//	case *tdapi.DeviceTokenSimplePush: // deviceTokenSimplePush#2f49a60
//	case *tdapi.DeviceTokenUbuntuPush: // deviceTokenUbuntuPush#6a3c0d26
//	case *tdapi.DeviceTokenBlackBerryPush: // deviceTokenBlackBerryPush#5cef0102
//	case *tdapi.DeviceTokenTizenPush: // deviceTokenTizenPush#aef0da33
//	case *tdapi.DeviceTokenHuaweiPush: // deviceTokenHuaweiPush#768f4e26
//	default: panic(v)
//	}
type DeviceTokenClass interface {
	bin.Encoder
	bin.Decoder
	bin.BareEncoder
	bin.BareDecoder
	construct() DeviceTokenClass

	// TypeID returns type id in TL schema.
	//
	// See https://core.telegram.org/mtproto/TL-tl#remarks.
	TypeID() uint32
	// TypeName returns name of type in TL schema.
	TypeName() string
	// String implements fmt.Stringer.
	String() string
	// Zero returns true if current object has a zero value.
	Zero() bool

	EncodeTDLibJSON(b tdjson.Encoder) error
	DecodeTDLibJSON(b tdjson.Decoder) error
}

// DecodeDeviceToken implements binary de-serialization for DeviceTokenClass.
func DecodeDeviceToken(buf *bin.Buffer) (DeviceTokenClass, error) {
	id, err := buf.PeekID()
	if err != nil {
		return nil, err
	}
	switch id {
	case DeviceTokenFirebaseCloudMessagingTypeID:
		// Decoding deviceTokenFirebaseCloudMessaging#d0714a07.
		v := DeviceTokenFirebaseCloudMessaging{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode DeviceTokenClass: %w", err)
		}
		return &v, nil
	case DeviceTokenApplePushTypeID:
		// Decoding deviceTokenApplePush#17196bc3.
		v := DeviceTokenApplePush{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode DeviceTokenClass: %w", err)
		}
		return &v, nil
	case DeviceTokenApplePushVoIPTypeID:
		// Decoding deviceTokenApplePushVoIP#2ff045e9.
		v := DeviceTokenApplePushVoIP{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode DeviceTokenClass: %w", err)
		}
		return &v, nil
	case DeviceTokenWindowsPushTypeID:
		// Decoding deviceTokenWindowsPush#abed428f.
		v := DeviceTokenWindowsPush{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode DeviceTokenClass: %w", err)
		}
		return &v, nil
	case DeviceTokenMicrosoftPushTypeID:
		// Decoding deviceTokenMicrosoftPush#48f8e04c.
		v := DeviceTokenMicrosoftPush{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode DeviceTokenClass: %w", err)
		}
		return &v, nil
	case DeviceTokenMicrosoftPushVoIPTypeID:
		// Decoding deviceTokenMicrosoftPushVoIP#d12ca351.
		v := DeviceTokenMicrosoftPushVoIP{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode DeviceTokenClass: %w", err)
		}
		return &v, nil
	case DeviceTokenWebPushTypeID:
		// Decoding deviceTokenWebPush#9affdef7.
		v := DeviceTokenWebPush{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode DeviceTokenClass: %w", err)
		}
		return &v, nil
	case DeviceTokenSimplePushTypeID:
		// Decoding deviceTokenSimplePush#2f49a60.
		v := DeviceTokenSimplePush{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode DeviceTokenClass: %w", err)
		}
		return &v, nil
	case DeviceTokenUbuntuPushTypeID:
		// Decoding deviceTokenUbuntuPush#6a3c0d26.
		v := DeviceTokenUbuntuPush{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode DeviceTokenClass: %w", err)
		}
		return &v, nil
	case DeviceTokenBlackBerryPushTypeID:
		// Decoding deviceTokenBlackBerryPush#5cef0102.
		v := DeviceTokenBlackBerryPush{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode DeviceTokenClass: %w", err)
		}
		return &v, nil
	case DeviceTokenTizenPushTypeID:
		// Decoding deviceTokenTizenPush#aef0da33.
		v := DeviceTokenTizenPush{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode DeviceTokenClass: %w", err)
		}
		return &v, nil
	case DeviceTokenHuaweiPushTypeID:
		// Decoding deviceTokenHuaweiPush#768f4e26.
		v := DeviceTokenHuaweiPush{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode DeviceTokenClass: %w", err)
		}
		return &v, nil
	default:
		return nil, fmt.Errorf("unable to decode DeviceTokenClass: %w", bin.NewUnexpectedID(id))
	}
}

// DecodeTDLibJSONDeviceToken implements binary de-serialization for DeviceTokenClass.
func DecodeTDLibJSONDeviceToken(buf tdjson.Decoder) (DeviceTokenClass, error) {
	id, err := buf.FindTypeID()
	if err != nil {
		return nil, err
	}
	switch id {
	case "deviceTokenFirebaseCloudMessaging":
		// Decoding deviceTokenFirebaseCloudMessaging#d0714a07.
		v := DeviceTokenFirebaseCloudMessaging{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode DeviceTokenClass: %w", err)
		}
		return &v, nil
	case "deviceTokenApplePush":
		// Decoding deviceTokenApplePush#17196bc3.
		v := DeviceTokenApplePush{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode DeviceTokenClass: %w", err)
		}
		return &v, nil
	case "deviceTokenApplePushVoIP":
		// Decoding deviceTokenApplePushVoIP#2ff045e9.
		v := DeviceTokenApplePushVoIP{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode DeviceTokenClass: %w", err)
		}
		return &v, nil
	case "deviceTokenWindowsPush":
		// Decoding deviceTokenWindowsPush#abed428f.
		v := DeviceTokenWindowsPush{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode DeviceTokenClass: %w", err)
		}
		return &v, nil
	case "deviceTokenMicrosoftPush":
		// Decoding deviceTokenMicrosoftPush#48f8e04c.
		v := DeviceTokenMicrosoftPush{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode DeviceTokenClass: %w", err)
		}
		return &v, nil
	case "deviceTokenMicrosoftPushVoIP":
		// Decoding deviceTokenMicrosoftPushVoIP#d12ca351.
		v := DeviceTokenMicrosoftPushVoIP{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode DeviceTokenClass: %w", err)
		}
		return &v, nil
	case "deviceTokenWebPush":
		// Decoding deviceTokenWebPush#9affdef7.
		v := DeviceTokenWebPush{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode DeviceTokenClass: %w", err)
		}
		return &v, nil
	case "deviceTokenSimplePush":
		// Decoding deviceTokenSimplePush#2f49a60.
		v := DeviceTokenSimplePush{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode DeviceTokenClass: %w", err)
		}
		return &v, nil
	case "deviceTokenUbuntuPush":
		// Decoding deviceTokenUbuntuPush#6a3c0d26.
		v := DeviceTokenUbuntuPush{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode DeviceTokenClass: %w", err)
		}
		return &v, nil
	case "deviceTokenBlackBerryPush":
		// Decoding deviceTokenBlackBerryPush#5cef0102.
		v := DeviceTokenBlackBerryPush{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode DeviceTokenClass: %w", err)
		}
		return &v, nil
	case "deviceTokenTizenPush":
		// Decoding deviceTokenTizenPush#aef0da33.
		v := DeviceTokenTizenPush{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode DeviceTokenClass: %w", err)
		}
		return &v, nil
	case "deviceTokenHuaweiPush":
		// Decoding deviceTokenHuaweiPush#768f4e26.
		v := DeviceTokenHuaweiPush{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode DeviceTokenClass: %w", err)
		}
		return &v, nil
	default:
		return nil, fmt.Errorf("unable to decode DeviceTokenClass: %w", tdjson.NewUnexpectedID(id))
	}
}

// DeviceToken boxes the DeviceTokenClass providing a helper.
type DeviceTokenBox struct {
	DeviceToken DeviceTokenClass
}

// Decode implements bin.Decoder for DeviceTokenBox.
func (b *DeviceTokenBox) Decode(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("unable to decode DeviceTokenBox to nil")
	}
	v, err := DecodeDeviceToken(buf)
	if err != nil {
		return fmt.Errorf("unable to decode boxed value: %w", err)
	}
	b.DeviceToken = v
	return nil
}

// Encode implements bin.Encode for DeviceTokenBox.
func (b *DeviceTokenBox) Encode(buf *bin.Buffer) error {
	if b == nil || b.DeviceToken == nil {
		return fmt.Errorf("unable to encode DeviceTokenClass as nil")
	}
	return b.DeviceToken.Encode(buf)
}

// DecodeTDLibJSON implements bin.Decoder for DeviceTokenBox.
func (b *DeviceTokenBox) DecodeTDLibJSON(buf tdjson.Decoder) error {
	if b == nil {
		return fmt.Errorf("unable to decode DeviceTokenBox to nil")
	}
	v, err := DecodeTDLibJSONDeviceToken(buf)
	if err != nil {
		return fmt.Errorf("unable to decode boxed value: %w", err)
	}
	b.DeviceToken = v
	return nil
}

// EncodeTDLibJSON implements bin.Encode for DeviceTokenBox.
func (b *DeviceTokenBox) EncodeTDLibJSON(buf tdjson.Encoder) error {
	if b == nil || b.DeviceToken == nil {
		return fmt.Errorf("unable to encode DeviceTokenClass as nil")
	}
	return b.DeviceToken.EncodeTDLibJSON(buf)
}
