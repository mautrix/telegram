// Code generated by gotdgen, DO NOT EDIT.

package tdapi

import (
	"context"
	"errors"
	"fmt"
	"sort"
	"strings"

	"go.uber.org/multierr"

	"go.mau.fi/mautrix-telegram/pkg/gotd/bin"
	"go.mau.fi/mautrix-telegram/pkg/gotd/tdjson"
	"go.mau.fi/mautrix-telegram/pkg/gotd/tdp"
	"go.mau.fi/mautrix-telegram/pkg/gotd/tgerr"
)

// No-op definition for keeping imports.
var (
	_ = bin.Buffer{}
	_ = context.Background()
	_ = fmt.Stringer(nil)
	_ = strings.Builder{}
	_ = errors.Is
	_ = multierr.AppendInto
	_ = sort.Ints
	_ = tdp.Format
	_ = tgerr.Error{}
	_ = tdjson.Encoder{}
)

// InputPassportElementErrorSourceUnspecified represents TL type `inputPassportElementErrorSourceUnspecified#fed9c6f`.
type InputPassportElementErrorSourceUnspecified struct {
	// Current hash of the entire element
	ElementHash []byte
}

// InputPassportElementErrorSourceUnspecifiedTypeID is TL type id of InputPassportElementErrorSourceUnspecified.
const InputPassportElementErrorSourceUnspecifiedTypeID = 0xfed9c6f

// construct implements constructor of InputPassportElementErrorSourceClass.
func (i InputPassportElementErrorSourceUnspecified) construct() InputPassportElementErrorSourceClass {
	return &i
}

// Ensuring interfaces in compile-time for InputPassportElementErrorSourceUnspecified.
var (
	_ bin.Encoder     = &InputPassportElementErrorSourceUnspecified{}
	_ bin.Decoder     = &InputPassportElementErrorSourceUnspecified{}
	_ bin.BareEncoder = &InputPassportElementErrorSourceUnspecified{}
	_ bin.BareDecoder = &InputPassportElementErrorSourceUnspecified{}

	_ InputPassportElementErrorSourceClass = &InputPassportElementErrorSourceUnspecified{}
)

func (i *InputPassportElementErrorSourceUnspecified) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.ElementHash == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputPassportElementErrorSourceUnspecified) String() string {
	if i == nil {
		return "InputPassportElementErrorSourceUnspecified(nil)"
	}
	type Alias InputPassportElementErrorSourceUnspecified
	return fmt.Sprintf("InputPassportElementErrorSourceUnspecified%+v", Alias(*i))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputPassportElementErrorSourceUnspecified) TypeID() uint32 {
	return InputPassportElementErrorSourceUnspecifiedTypeID
}

// TypeName returns name of type in TL schema.
func (*InputPassportElementErrorSourceUnspecified) TypeName() string {
	return "inputPassportElementErrorSourceUnspecified"
}

// TypeInfo returns info about TL type.
func (i *InputPassportElementErrorSourceUnspecified) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputPassportElementErrorSourceUnspecified",
		ID:   InputPassportElementErrorSourceUnspecifiedTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ElementHash",
			SchemaName: "element_hash",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (i *InputPassportElementErrorSourceUnspecified) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputPassportElementErrorSourceUnspecified#fed9c6f as nil")
	}
	b.PutID(InputPassportElementErrorSourceUnspecifiedTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputPassportElementErrorSourceUnspecified) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputPassportElementErrorSourceUnspecified#fed9c6f as nil")
	}
	b.PutBytes(i.ElementHash)
	return nil
}

// Decode implements bin.Decoder.
func (i *InputPassportElementErrorSourceUnspecified) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputPassportElementErrorSourceUnspecified#fed9c6f to nil")
	}
	if err := b.ConsumeID(InputPassportElementErrorSourceUnspecifiedTypeID); err != nil {
		return fmt.Errorf("unable to decode inputPassportElementErrorSourceUnspecified#fed9c6f: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputPassportElementErrorSourceUnspecified) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputPassportElementErrorSourceUnspecified#fed9c6f to nil")
	}
	{
		value, err := b.Bytes()
		if err != nil {
			return fmt.Errorf("unable to decode inputPassportElementErrorSourceUnspecified#fed9c6f: field element_hash: %w", err)
		}
		i.ElementHash = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (i *InputPassportElementErrorSourceUnspecified) EncodeTDLibJSON(b tdjson.Encoder) error {
	if i == nil {
		return fmt.Errorf("can't encode inputPassportElementErrorSourceUnspecified#fed9c6f as nil")
	}
	b.ObjStart()
	b.PutID("inputPassportElementErrorSourceUnspecified")
	b.Comma()
	b.FieldStart("element_hash")
	b.PutBytes(i.ElementHash)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (i *InputPassportElementErrorSourceUnspecified) DecodeTDLibJSON(b tdjson.Decoder) error {
	if i == nil {
		return fmt.Errorf("can't decode inputPassportElementErrorSourceUnspecified#fed9c6f to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("inputPassportElementErrorSourceUnspecified"); err != nil {
				return fmt.Errorf("unable to decode inputPassportElementErrorSourceUnspecified#fed9c6f: %w", err)
			}
		case "element_hash":
			value, err := b.Bytes()
			if err != nil {
				return fmt.Errorf("unable to decode inputPassportElementErrorSourceUnspecified#fed9c6f: field element_hash: %w", err)
			}
			i.ElementHash = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetElementHash returns value of ElementHash field.
func (i *InputPassportElementErrorSourceUnspecified) GetElementHash() (value []byte) {
	if i == nil {
		return
	}
	return i.ElementHash
}

// InputPassportElementErrorSourceDataField represents TL type `inputPassportElementErrorSourceDataField#e68fa006`.
type InputPassportElementErrorSourceDataField struct {
	// Field name
	FieldName string
	// Current data hash
	DataHash []byte
}

// InputPassportElementErrorSourceDataFieldTypeID is TL type id of InputPassportElementErrorSourceDataField.
const InputPassportElementErrorSourceDataFieldTypeID = 0xe68fa006

// construct implements constructor of InputPassportElementErrorSourceClass.
func (i InputPassportElementErrorSourceDataField) construct() InputPassportElementErrorSourceClass {
	return &i
}

// Ensuring interfaces in compile-time for InputPassportElementErrorSourceDataField.
var (
	_ bin.Encoder     = &InputPassportElementErrorSourceDataField{}
	_ bin.Decoder     = &InputPassportElementErrorSourceDataField{}
	_ bin.BareEncoder = &InputPassportElementErrorSourceDataField{}
	_ bin.BareDecoder = &InputPassportElementErrorSourceDataField{}

	_ InputPassportElementErrorSourceClass = &InputPassportElementErrorSourceDataField{}
)

func (i *InputPassportElementErrorSourceDataField) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.FieldName == "") {
		return false
	}
	if !(i.DataHash == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputPassportElementErrorSourceDataField) String() string {
	if i == nil {
		return "InputPassportElementErrorSourceDataField(nil)"
	}
	type Alias InputPassportElementErrorSourceDataField
	return fmt.Sprintf("InputPassportElementErrorSourceDataField%+v", Alias(*i))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputPassportElementErrorSourceDataField) TypeID() uint32 {
	return InputPassportElementErrorSourceDataFieldTypeID
}

// TypeName returns name of type in TL schema.
func (*InputPassportElementErrorSourceDataField) TypeName() string {
	return "inputPassportElementErrorSourceDataField"
}

// TypeInfo returns info about TL type.
func (i *InputPassportElementErrorSourceDataField) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputPassportElementErrorSourceDataField",
		ID:   InputPassportElementErrorSourceDataFieldTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "FieldName",
			SchemaName: "field_name",
		},
		{
			Name:       "DataHash",
			SchemaName: "data_hash",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (i *InputPassportElementErrorSourceDataField) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputPassportElementErrorSourceDataField#e68fa006 as nil")
	}
	b.PutID(InputPassportElementErrorSourceDataFieldTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputPassportElementErrorSourceDataField) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputPassportElementErrorSourceDataField#e68fa006 as nil")
	}
	b.PutString(i.FieldName)
	b.PutBytes(i.DataHash)
	return nil
}

// Decode implements bin.Decoder.
func (i *InputPassportElementErrorSourceDataField) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputPassportElementErrorSourceDataField#e68fa006 to nil")
	}
	if err := b.ConsumeID(InputPassportElementErrorSourceDataFieldTypeID); err != nil {
		return fmt.Errorf("unable to decode inputPassportElementErrorSourceDataField#e68fa006: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputPassportElementErrorSourceDataField) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputPassportElementErrorSourceDataField#e68fa006 to nil")
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputPassportElementErrorSourceDataField#e68fa006: field field_name: %w", err)
		}
		i.FieldName = value
	}
	{
		value, err := b.Bytes()
		if err != nil {
			return fmt.Errorf("unable to decode inputPassportElementErrorSourceDataField#e68fa006: field data_hash: %w", err)
		}
		i.DataHash = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (i *InputPassportElementErrorSourceDataField) EncodeTDLibJSON(b tdjson.Encoder) error {
	if i == nil {
		return fmt.Errorf("can't encode inputPassportElementErrorSourceDataField#e68fa006 as nil")
	}
	b.ObjStart()
	b.PutID("inputPassportElementErrorSourceDataField")
	b.Comma()
	b.FieldStart("field_name")
	b.PutString(i.FieldName)
	b.Comma()
	b.FieldStart("data_hash")
	b.PutBytes(i.DataHash)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (i *InputPassportElementErrorSourceDataField) DecodeTDLibJSON(b tdjson.Decoder) error {
	if i == nil {
		return fmt.Errorf("can't decode inputPassportElementErrorSourceDataField#e68fa006 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("inputPassportElementErrorSourceDataField"); err != nil {
				return fmt.Errorf("unable to decode inputPassportElementErrorSourceDataField#e68fa006: %w", err)
			}
		case "field_name":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode inputPassportElementErrorSourceDataField#e68fa006: field field_name: %w", err)
			}
			i.FieldName = value
		case "data_hash":
			value, err := b.Bytes()
			if err != nil {
				return fmt.Errorf("unable to decode inputPassportElementErrorSourceDataField#e68fa006: field data_hash: %w", err)
			}
			i.DataHash = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetFieldName returns value of FieldName field.
func (i *InputPassportElementErrorSourceDataField) GetFieldName() (value string) {
	if i == nil {
		return
	}
	return i.FieldName
}

// GetDataHash returns value of DataHash field.
func (i *InputPassportElementErrorSourceDataField) GetDataHash() (value []byte) {
	if i == nil {
		return
	}
	return i.DataHash
}

// InputPassportElementErrorSourceFrontSide represents TL type `inputPassportElementErrorSourceFrontSide#230c87bd`.
type InputPassportElementErrorSourceFrontSide struct {
	// Current hash of the file containing the front side
	FileHash []byte
}

// InputPassportElementErrorSourceFrontSideTypeID is TL type id of InputPassportElementErrorSourceFrontSide.
const InputPassportElementErrorSourceFrontSideTypeID = 0x230c87bd

// construct implements constructor of InputPassportElementErrorSourceClass.
func (i InputPassportElementErrorSourceFrontSide) construct() InputPassportElementErrorSourceClass {
	return &i
}

// Ensuring interfaces in compile-time for InputPassportElementErrorSourceFrontSide.
var (
	_ bin.Encoder     = &InputPassportElementErrorSourceFrontSide{}
	_ bin.Decoder     = &InputPassportElementErrorSourceFrontSide{}
	_ bin.BareEncoder = &InputPassportElementErrorSourceFrontSide{}
	_ bin.BareDecoder = &InputPassportElementErrorSourceFrontSide{}

	_ InputPassportElementErrorSourceClass = &InputPassportElementErrorSourceFrontSide{}
)

func (i *InputPassportElementErrorSourceFrontSide) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.FileHash == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputPassportElementErrorSourceFrontSide) String() string {
	if i == nil {
		return "InputPassportElementErrorSourceFrontSide(nil)"
	}
	type Alias InputPassportElementErrorSourceFrontSide
	return fmt.Sprintf("InputPassportElementErrorSourceFrontSide%+v", Alias(*i))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputPassportElementErrorSourceFrontSide) TypeID() uint32 {
	return InputPassportElementErrorSourceFrontSideTypeID
}

// TypeName returns name of type in TL schema.
func (*InputPassportElementErrorSourceFrontSide) TypeName() string {
	return "inputPassportElementErrorSourceFrontSide"
}

// TypeInfo returns info about TL type.
func (i *InputPassportElementErrorSourceFrontSide) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputPassportElementErrorSourceFrontSide",
		ID:   InputPassportElementErrorSourceFrontSideTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "FileHash",
			SchemaName: "file_hash",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (i *InputPassportElementErrorSourceFrontSide) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputPassportElementErrorSourceFrontSide#230c87bd as nil")
	}
	b.PutID(InputPassportElementErrorSourceFrontSideTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputPassportElementErrorSourceFrontSide) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputPassportElementErrorSourceFrontSide#230c87bd as nil")
	}
	b.PutBytes(i.FileHash)
	return nil
}

// Decode implements bin.Decoder.
func (i *InputPassportElementErrorSourceFrontSide) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputPassportElementErrorSourceFrontSide#230c87bd to nil")
	}
	if err := b.ConsumeID(InputPassportElementErrorSourceFrontSideTypeID); err != nil {
		return fmt.Errorf("unable to decode inputPassportElementErrorSourceFrontSide#230c87bd: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputPassportElementErrorSourceFrontSide) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputPassportElementErrorSourceFrontSide#230c87bd to nil")
	}
	{
		value, err := b.Bytes()
		if err != nil {
			return fmt.Errorf("unable to decode inputPassportElementErrorSourceFrontSide#230c87bd: field file_hash: %w", err)
		}
		i.FileHash = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (i *InputPassportElementErrorSourceFrontSide) EncodeTDLibJSON(b tdjson.Encoder) error {
	if i == nil {
		return fmt.Errorf("can't encode inputPassportElementErrorSourceFrontSide#230c87bd as nil")
	}
	b.ObjStart()
	b.PutID("inputPassportElementErrorSourceFrontSide")
	b.Comma()
	b.FieldStart("file_hash")
	b.PutBytes(i.FileHash)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (i *InputPassportElementErrorSourceFrontSide) DecodeTDLibJSON(b tdjson.Decoder) error {
	if i == nil {
		return fmt.Errorf("can't decode inputPassportElementErrorSourceFrontSide#230c87bd to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("inputPassportElementErrorSourceFrontSide"); err != nil {
				return fmt.Errorf("unable to decode inputPassportElementErrorSourceFrontSide#230c87bd: %w", err)
			}
		case "file_hash":
			value, err := b.Bytes()
			if err != nil {
				return fmt.Errorf("unable to decode inputPassportElementErrorSourceFrontSide#230c87bd: field file_hash: %w", err)
			}
			i.FileHash = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetFileHash returns value of FileHash field.
func (i *InputPassportElementErrorSourceFrontSide) GetFileHash() (value []byte) {
	if i == nil {
		return
	}
	return i.FileHash
}

// InputPassportElementErrorSourceReverseSide represents TL type `inputPassportElementErrorSourceReverseSide#189efdfb`.
type InputPassportElementErrorSourceReverseSide struct {
	// Current hash of the file containing the reverse side
	FileHash []byte
}

// InputPassportElementErrorSourceReverseSideTypeID is TL type id of InputPassportElementErrorSourceReverseSide.
const InputPassportElementErrorSourceReverseSideTypeID = 0x189efdfb

// construct implements constructor of InputPassportElementErrorSourceClass.
func (i InputPassportElementErrorSourceReverseSide) construct() InputPassportElementErrorSourceClass {
	return &i
}

// Ensuring interfaces in compile-time for InputPassportElementErrorSourceReverseSide.
var (
	_ bin.Encoder     = &InputPassportElementErrorSourceReverseSide{}
	_ bin.Decoder     = &InputPassportElementErrorSourceReverseSide{}
	_ bin.BareEncoder = &InputPassportElementErrorSourceReverseSide{}
	_ bin.BareDecoder = &InputPassportElementErrorSourceReverseSide{}

	_ InputPassportElementErrorSourceClass = &InputPassportElementErrorSourceReverseSide{}
)

func (i *InputPassportElementErrorSourceReverseSide) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.FileHash == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputPassportElementErrorSourceReverseSide) String() string {
	if i == nil {
		return "InputPassportElementErrorSourceReverseSide(nil)"
	}
	type Alias InputPassportElementErrorSourceReverseSide
	return fmt.Sprintf("InputPassportElementErrorSourceReverseSide%+v", Alias(*i))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputPassportElementErrorSourceReverseSide) TypeID() uint32 {
	return InputPassportElementErrorSourceReverseSideTypeID
}

// TypeName returns name of type in TL schema.
func (*InputPassportElementErrorSourceReverseSide) TypeName() string {
	return "inputPassportElementErrorSourceReverseSide"
}

// TypeInfo returns info about TL type.
func (i *InputPassportElementErrorSourceReverseSide) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputPassportElementErrorSourceReverseSide",
		ID:   InputPassportElementErrorSourceReverseSideTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "FileHash",
			SchemaName: "file_hash",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (i *InputPassportElementErrorSourceReverseSide) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputPassportElementErrorSourceReverseSide#189efdfb as nil")
	}
	b.PutID(InputPassportElementErrorSourceReverseSideTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputPassportElementErrorSourceReverseSide) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputPassportElementErrorSourceReverseSide#189efdfb as nil")
	}
	b.PutBytes(i.FileHash)
	return nil
}

// Decode implements bin.Decoder.
func (i *InputPassportElementErrorSourceReverseSide) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputPassportElementErrorSourceReverseSide#189efdfb to nil")
	}
	if err := b.ConsumeID(InputPassportElementErrorSourceReverseSideTypeID); err != nil {
		return fmt.Errorf("unable to decode inputPassportElementErrorSourceReverseSide#189efdfb: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputPassportElementErrorSourceReverseSide) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputPassportElementErrorSourceReverseSide#189efdfb to nil")
	}
	{
		value, err := b.Bytes()
		if err != nil {
			return fmt.Errorf("unable to decode inputPassportElementErrorSourceReverseSide#189efdfb: field file_hash: %w", err)
		}
		i.FileHash = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (i *InputPassportElementErrorSourceReverseSide) EncodeTDLibJSON(b tdjson.Encoder) error {
	if i == nil {
		return fmt.Errorf("can't encode inputPassportElementErrorSourceReverseSide#189efdfb as nil")
	}
	b.ObjStart()
	b.PutID("inputPassportElementErrorSourceReverseSide")
	b.Comma()
	b.FieldStart("file_hash")
	b.PutBytes(i.FileHash)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (i *InputPassportElementErrorSourceReverseSide) DecodeTDLibJSON(b tdjson.Decoder) error {
	if i == nil {
		return fmt.Errorf("can't decode inputPassportElementErrorSourceReverseSide#189efdfb to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("inputPassportElementErrorSourceReverseSide"); err != nil {
				return fmt.Errorf("unable to decode inputPassportElementErrorSourceReverseSide#189efdfb: %w", err)
			}
		case "file_hash":
			value, err := b.Bytes()
			if err != nil {
				return fmt.Errorf("unable to decode inputPassportElementErrorSourceReverseSide#189efdfb: field file_hash: %w", err)
			}
			i.FileHash = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetFileHash returns value of FileHash field.
func (i *InputPassportElementErrorSourceReverseSide) GetFileHash() (value []byte) {
	if i == nil {
		return
	}
	return i.FileHash
}

// InputPassportElementErrorSourceSelfie represents TL type `inputPassportElementErrorSourceSelfie#d1e42c98`.
type InputPassportElementErrorSourceSelfie struct {
	// Current hash of the file containing the selfie
	FileHash []byte
}

// InputPassportElementErrorSourceSelfieTypeID is TL type id of InputPassportElementErrorSourceSelfie.
const InputPassportElementErrorSourceSelfieTypeID = 0xd1e42c98

// construct implements constructor of InputPassportElementErrorSourceClass.
func (i InputPassportElementErrorSourceSelfie) construct() InputPassportElementErrorSourceClass {
	return &i
}

// Ensuring interfaces in compile-time for InputPassportElementErrorSourceSelfie.
var (
	_ bin.Encoder     = &InputPassportElementErrorSourceSelfie{}
	_ bin.Decoder     = &InputPassportElementErrorSourceSelfie{}
	_ bin.BareEncoder = &InputPassportElementErrorSourceSelfie{}
	_ bin.BareDecoder = &InputPassportElementErrorSourceSelfie{}

	_ InputPassportElementErrorSourceClass = &InputPassportElementErrorSourceSelfie{}
)

func (i *InputPassportElementErrorSourceSelfie) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.FileHash == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputPassportElementErrorSourceSelfie) String() string {
	if i == nil {
		return "InputPassportElementErrorSourceSelfie(nil)"
	}
	type Alias InputPassportElementErrorSourceSelfie
	return fmt.Sprintf("InputPassportElementErrorSourceSelfie%+v", Alias(*i))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputPassportElementErrorSourceSelfie) TypeID() uint32 {
	return InputPassportElementErrorSourceSelfieTypeID
}

// TypeName returns name of type in TL schema.
func (*InputPassportElementErrorSourceSelfie) TypeName() string {
	return "inputPassportElementErrorSourceSelfie"
}

// TypeInfo returns info about TL type.
func (i *InputPassportElementErrorSourceSelfie) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputPassportElementErrorSourceSelfie",
		ID:   InputPassportElementErrorSourceSelfieTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "FileHash",
			SchemaName: "file_hash",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (i *InputPassportElementErrorSourceSelfie) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputPassportElementErrorSourceSelfie#d1e42c98 as nil")
	}
	b.PutID(InputPassportElementErrorSourceSelfieTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputPassportElementErrorSourceSelfie) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputPassportElementErrorSourceSelfie#d1e42c98 as nil")
	}
	b.PutBytes(i.FileHash)
	return nil
}

// Decode implements bin.Decoder.
func (i *InputPassportElementErrorSourceSelfie) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputPassportElementErrorSourceSelfie#d1e42c98 to nil")
	}
	if err := b.ConsumeID(InputPassportElementErrorSourceSelfieTypeID); err != nil {
		return fmt.Errorf("unable to decode inputPassportElementErrorSourceSelfie#d1e42c98: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputPassportElementErrorSourceSelfie) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputPassportElementErrorSourceSelfie#d1e42c98 to nil")
	}
	{
		value, err := b.Bytes()
		if err != nil {
			return fmt.Errorf("unable to decode inputPassportElementErrorSourceSelfie#d1e42c98: field file_hash: %w", err)
		}
		i.FileHash = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (i *InputPassportElementErrorSourceSelfie) EncodeTDLibJSON(b tdjson.Encoder) error {
	if i == nil {
		return fmt.Errorf("can't encode inputPassportElementErrorSourceSelfie#d1e42c98 as nil")
	}
	b.ObjStart()
	b.PutID("inputPassportElementErrorSourceSelfie")
	b.Comma()
	b.FieldStart("file_hash")
	b.PutBytes(i.FileHash)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (i *InputPassportElementErrorSourceSelfie) DecodeTDLibJSON(b tdjson.Decoder) error {
	if i == nil {
		return fmt.Errorf("can't decode inputPassportElementErrorSourceSelfie#d1e42c98 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("inputPassportElementErrorSourceSelfie"); err != nil {
				return fmt.Errorf("unable to decode inputPassportElementErrorSourceSelfie#d1e42c98: %w", err)
			}
		case "file_hash":
			value, err := b.Bytes()
			if err != nil {
				return fmt.Errorf("unable to decode inputPassportElementErrorSourceSelfie#d1e42c98: field file_hash: %w", err)
			}
			i.FileHash = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetFileHash returns value of FileHash field.
func (i *InputPassportElementErrorSourceSelfie) GetFileHash() (value []byte) {
	if i == nil {
		return
	}
	return i.FileHash
}

// InputPassportElementErrorSourceTranslationFile represents TL type `inputPassportElementErrorSourceTranslationFile#1e268a7b`.
type InputPassportElementErrorSourceTranslationFile struct {
	// Current hash of the file containing the translation
	FileHash []byte
}

// InputPassportElementErrorSourceTranslationFileTypeID is TL type id of InputPassportElementErrorSourceTranslationFile.
const InputPassportElementErrorSourceTranslationFileTypeID = 0x1e268a7b

// construct implements constructor of InputPassportElementErrorSourceClass.
func (i InputPassportElementErrorSourceTranslationFile) construct() InputPassportElementErrorSourceClass {
	return &i
}

// Ensuring interfaces in compile-time for InputPassportElementErrorSourceTranslationFile.
var (
	_ bin.Encoder     = &InputPassportElementErrorSourceTranslationFile{}
	_ bin.Decoder     = &InputPassportElementErrorSourceTranslationFile{}
	_ bin.BareEncoder = &InputPassportElementErrorSourceTranslationFile{}
	_ bin.BareDecoder = &InputPassportElementErrorSourceTranslationFile{}

	_ InputPassportElementErrorSourceClass = &InputPassportElementErrorSourceTranslationFile{}
)

func (i *InputPassportElementErrorSourceTranslationFile) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.FileHash == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputPassportElementErrorSourceTranslationFile) String() string {
	if i == nil {
		return "InputPassportElementErrorSourceTranslationFile(nil)"
	}
	type Alias InputPassportElementErrorSourceTranslationFile
	return fmt.Sprintf("InputPassportElementErrorSourceTranslationFile%+v", Alias(*i))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputPassportElementErrorSourceTranslationFile) TypeID() uint32 {
	return InputPassportElementErrorSourceTranslationFileTypeID
}

// TypeName returns name of type in TL schema.
func (*InputPassportElementErrorSourceTranslationFile) TypeName() string {
	return "inputPassportElementErrorSourceTranslationFile"
}

// TypeInfo returns info about TL type.
func (i *InputPassportElementErrorSourceTranslationFile) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputPassportElementErrorSourceTranslationFile",
		ID:   InputPassportElementErrorSourceTranslationFileTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "FileHash",
			SchemaName: "file_hash",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (i *InputPassportElementErrorSourceTranslationFile) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputPassportElementErrorSourceTranslationFile#1e268a7b as nil")
	}
	b.PutID(InputPassportElementErrorSourceTranslationFileTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputPassportElementErrorSourceTranslationFile) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputPassportElementErrorSourceTranslationFile#1e268a7b as nil")
	}
	b.PutBytes(i.FileHash)
	return nil
}

// Decode implements bin.Decoder.
func (i *InputPassportElementErrorSourceTranslationFile) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputPassportElementErrorSourceTranslationFile#1e268a7b to nil")
	}
	if err := b.ConsumeID(InputPassportElementErrorSourceTranslationFileTypeID); err != nil {
		return fmt.Errorf("unable to decode inputPassportElementErrorSourceTranslationFile#1e268a7b: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputPassportElementErrorSourceTranslationFile) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputPassportElementErrorSourceTranslationFile#1e268a7b to nil")
	}
	{
		value, err := b.Bytes()
		if err != nil {
			return fmt.Errorf("unable to decode inputPassportElementErrorSourceTranslationFile#1e268a7b: field file_hash: %w", err)
		}
		i.FileHash = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (i *InputPassportElementErrorSourceTranslationFile) EncodeTDLibJSON(b tdjson.Encoder) error {
	if i == nil {
		return fmt.Errorf("can't encode inputPassportElementErrorSourceTranslationFile#1e268a7b as nil")
	}
	b.ObjStart()
	b.PutID("inputPassportElementErrorSourceTranslationFile")
	b.Comma()
	b.FieldStart("file_hash")
	b.PutBytes(i.FileHash)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (i *InputPassportElementErrorSourceTranslationFile) DecodeTDLibJSON(b tdjson.Decoder) error {
	if i == nil {
		return fmt.Errorf("can't decode inputPassportElementErrorSourceTranslationFile#1e268a7b to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("inputPassportElementErrorSourceTranslationFile"); err != nil {
				return fmt.Errorf("unable to decode inputPassportElementErrorSourceTranslationFile#1e268a7b: %w", err)
			}
		case "file_hash":
			value, err := b.Bytes()
			if err != nil {
				return fmt.Errorf("unable to decode inputPassportElementErrorSourceTranslationFile#1e268a7b: field file_hash: %w", err)
			}
			i.FileHash = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetFileHash returns value of FileHash field.
func (i *InputPassportElementErrorSourceTranslationFile) GetFileHash() (value []byte) {
	if i == nil {
		return
	}
	return i.FileHash
}

// InputPassportElementErrorSourceTranslationFiles represents TL type `inputPassportElementErrorSourceTranslationFiles#ef54819b`.
type InputPassportElementErrorSourceTranslationFiles struct {
	// Current hashes of all files with the translation
	FileHashes [][]byte
}

// InputPassportElementErrorSourceTranslationFilesTypeID is TL type id of InputPassportElementErrorSourceTranslationFiles.
const InputPassportElementErrorSourceTranslationFilesTypeID = 0xef54819b

// construct implements constructor of InputPassportElementErrorSourceClass.
func (i InputPassportElementErrorSourceTranslationFiles) construct() InputPassportElementErrorSourceClass {
	return &i
}

// Ensuring interfaces in compile-time for InputPassportElementErrorSourceTranslationFiles.
var (
	_ bin.Encoder     = &InputPassportElementErrorSourceTranslationFiles{}
	_ bin.Decoder     = &InputPassportElementErrorSourceTranslationFiles{}
	_ bin.BareEncoder = &InputPassportElementErrorSourceTranslationFiles{}
	_ bin.BareDecoder = &InputPassportElementErrorSourceTranslationFiles{}

	_ InputPassportElementErrorSourceClass = &InputPassportElementErrorSourceTranslationFiles{}
)

func (i *InputPassportElementErrorSourceTranslationFiles) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.FileHashes == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputPassportElementErrorSourceTranslationFiles) String() string {
	if i == nil {
		return "InputPassportElementErrorSourceTranslationFiles(nil)"
	}
	type Alias InputPassportElementErrorSourceTranslationFiles
	return fmt.Sprintf("InputPassportElementErrorSourceTranslationFiles%+v", Alias(*i))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputPassportElementErrorSourceTranslationFiles) TypeID() uint32 {
	return InputPassportElementErrorSourceTranslationFilesTypeID
}

// TypeName returns name of type in TL schema.
func (*InputPassportElementErrorSourceTranslationFiles) TypeName() string {
	return "inputPassportElementErrorSourceTranslationFiles"
}

// TypeInfo returns info about TL type.
func (i *InputPassportElementErrorSourceTranslationFiles) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputPassportElementErrorSourceTranslationFiles",
		ID:   InputPassportElementErrorSourceTranslationFilesTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "FileHashes",
			SchemaName: "file_hashes",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (i *InputPassportElementErrorSourceTranslationFiles) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputPassportElementErrorSourceTranslationFiles#ef54819b as nil")
	}
	b.PutID(InputPassportElementErrorSourceTranslationFilesTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputPassportElementErrorSourceTranslationFiles) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputPassportElementErrorSourceTranslationFiles#ef54819b as nil")
	}
	b.PutInt(len(i.FileHashes))
	for _, v := range i.FileHashes {
		b.PutBytes(v)
	}
	return nil
}

// Decode implements bin.Decoder.
func (i *InputPassportElementErrorSourceTranslationFiles) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputPassportElementErrorSourceTranslationFiles#ef54819b to nil")
	}
	if err := b.ConsumeID(InputPassportElementErrorSourceTranslationFilesTypeID); err != nil {
		return fmt.Errorf("unable to decode inputPassportElementErrorSourceTranslationFiles#ef54819b: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputPassportElementErrorSourceTranslationFiles) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputPassportElementErrorSourceTranslationFiles#ef54819b to nil")
	}
	{
		headerLen, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode inputPassportElementErrorSourceTranslationFiles#ef54819b: field file_hashes: %w", err)
		}

		if headerLen > 0 {
			i.FileHashes = make([][]byte, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := b.Bytes()
			if err != nil {
				return fmt.Errorf("unable to decode inputPassportElementErrorSourceTranslationFiles#ef54819b: field file_hashes: %w", err)
			}
			i.FileHashes = append(i.FileHashes, value)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (i *InputPassportElementErrorSourceTranslationFiles) EncodeTDLibJSON(b tdjson.Encoder) error {
	if i == nil {
		return fmt.Errorf("can't encode inputPassportElementErrorSourceTranslationFiles#ef54819b as nil")
	}
	b.ObjStart()
	b.PutID("inputPassportElementErrorSourceTranslationFiles")
	b.Comma()
	b.FieldStart("file_hashes")
	b.ArrStart()
	for _, v := range i.FileHashes {
		b.PutBytes(v)
		b.Comma()
	}
	b.StripComma()
	b.ArrEnd()
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (i *InputPassportElementErrorSourceTranslationFiles) DecodeTDLibJSON(b tdjson.Decoder) error {
	if i == nil {
		return fmt.Errorf("can't decode inputPassportElementErrorSourceTranslationFiles#ef54819b to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("inputPassportElementErrorSourceTranslationFiles"); err != nil {
				return fmt.Errorf("unable to decode inputPassportElementErrorSourceTranslationFiles#ef54819b: %w", err)
			}
		case "file_hashes":
			if err := b.Arr(func(b tdjson.Decoder) error {
				value, err := b.Bytes()
				if err != nil {
					return fmt.Errorf("unable to decode inputPassportElementErrorSourceTranslationFiles#ef54819b: field file_hashes: %w", err)
				}
				i.FileHashes = append(i.FileHashes, value)
				return nil
			}); err != nil {
				return fmt.Errorf("unable to decode inputPassportElementErrorSourceTranslationFiles#ef54819b: field file_hashes: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetFileHashes returns value of FileHashes field.
func (i *InputPassportElementErrorSourceTranslationFiles) GetFileHashes() (value [][]byte) {
	if i == nil {
		return
	}
	return i.FileHashes
}

// InputPassportElementErrorSourceFile represents TL type `inputPassportElementErrorSourceFile#ee355dcb`.
type InputPassportElementErrorSourceFile struct {
	// Current hash of the file which has the error
	FileHash []byte
}

// InputPassportElementErrorSourceFileTypeID is TL type id of InputPassportElementErrorSourceFile.
const InputPassportElementErrorSourceFileTypeID = 0xee355dcb

// construct implements constructor of InputPassportElementErrorSourceClass.
func (i InputPassportElementErrorSourceFile) construct() InputPassportElementErrorSourceClass {
	return &i
}

// Ensuring interfaces in compile-time for InputPassportElementErrorSourceFile.
var (
	_ bin.Encoder     = &InputPassportElementErrorSourceFile{}
	_ bin.Decoder     = &InputPassportElementErrorSourceFile{}
	_ bin.BareEncoder = &InputPassportElementErrorSourceFile{}
	_ bin.BareDecoder = &InputPassportElementErrorSourceFile{}

	_ InputPassportElementErrorSourceClass = &InputPassportElementErrorSourceFile{}
)

func (i *InputPassportElementErrorSourceFile) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.FileHash == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputPassportElementErrorSourceFile) String() string {
	if i == nil {
		return "InputPassportElementErrorSourceFile(nil)"
	}
	type Alias InputPassportElementErrorSourceFile
	return fmt.Sprintf("InputPassportElementErrorSourceFile%+v", Alias(*i))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputPassportElementErrorSourceFile) TypeID() uint32 {
	return InputPassportElementErrorSourceFileTypeID
}

// TypeName returns name of type in TL schema.
func (*InputPassportElementErrorSourceFile) TypeName() string {
	return "inputPassportElementErrorSourceFile"
}

// TypeInfo returns info about TL type.
func (i *InputPassportElementErrorSourceFile) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputPassportElementErrorSourceFile",
		ID:   InputPassportElementErrorSourceFileTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "FileHash",
			SchemaName: "file_hash",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (i *InputPassportElementErrorSourceFile) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputPassportElementErrorSourceFile#ee355dcb as nil")
	}
	b.PutID(InputPassportElementErrorSourceFileTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputPassportElementErrorSourceFile) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputPassportElementErrorSourceFile#ee355dcb as nil")
	}
	b.PutBytes(i.FileHash)
	return nil
}

// Decode implements bin.Decoder.
func (i *InputPassportElementErrorSourceFile) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputPassportElementErrorSourceFile#ee355dcb to nil")
	}
	if err := b.ConsumeID(InputPassportElementErrorSourceFileTypeID); err != nil {
		return fmt.Errorf("unable to decode inputPassportElementErrorSourceFile#ee355dcb: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputPassportElementErrorSourceFile) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputPassportElementErrorSourceFile#ee355dcb to nil")
	}
	{
		value, err := b.Bytes()
		if err != nil {
			return fmt.Errorf("unable to decode inputPassportElementErrorSourceFile#ee355dcb: field file_hash: %w", err)
		}
		i.FileHash = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (i *InputPassportElementErrorSourceFile) EncodeTDLibJSON(b tdjson.Encoder) error {
	if i == nil {
		return fmt.Errorf("can't encode inputPassportElementErrorSourceFile#ee355dcb as nil")
	}
	b.ObjStart()
	b.PutID("inputPassportElementErrorSourceFile")
	b.Comma()
	b.FieldStart("file_hash")
	b.PutBytes(i.FileHash)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (i *InputPassportElementErrorSourceFile) DecodeTDLibJSON(b tdjson.Decoder) error {
	if i == nil {
		return fmt.Errorf("can't decode inputPassportElementErrorSourceFile#ee355dcb to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("inputPassportElementErrorSourceFile"); err != nil {
				return fmt.Errorf("unable to decode inputPassportElementErrorSourceFile#ee355dcb: %w", err)
			}
		case "file_hash":
			value, err := b.Bytes()
			if err != nil {
				return fmt.Errorf("unable to decode inputPassportElementErrorSourceFile#ee355dcb: field file_hash: %w", err)
			}
			i.FileHash = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetFileHash returns value of FileHash field.
func (i *InputPassportElementErrorSourceFile) GetFileHash() (value []byte) {
	if i == nil {
		return
	}
	return i.FileHash
}

// InputPassportElementErrorSourceFiles represents TL type `inputPassportElementErrorSourceFiles#673401d6`.
type InputPassportElementErrorSourceFiles struct {
	// Current hashes of all attached files
	FileHashes [][]byte
}

// InputPassportElementErrorSourceFilesTypeID is TL type id of InputPassportElementErrorSourceFiles.
const InputPassportElementErrorSourceFilesTypeID = 0x673401d6

// construct implements constructor of InputPassportElementErrorSourceClass.
func (i InputPassportElementErrorSourceFiles) construct() InputPassportElementErrorSourceClass {
	return &i
}

// Ensuring interfaces in compile-time for InputPassportElementErrorSourceFiles.
var (
	_ bin.Encoder     = &InputPassportElementErrorSourceFiles{}
	_ bin.Decoder     = &InputPassportElementErrorSourceFiles{}
	_ bin.BareEncoder = &InputPassportElementErrorSourceFiles{}
	_ bin.BareDecoder = &InputPassportElementErrorSourceFiles{}

	_ InputPassportElementErrorSourceClass = &InputPassportElementErrorSourceFiles{}
)

func (i *InputPassportElementErrorSourceFiles) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.FileHashes == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputPassportElementErrorSourceFiles) String() string {
	if i == nil {
		return "InputPassportElementErrorSourceFiles(nil)"
	}
	type Alias InputPassportElementErrorSourceFiles
	return fmt.Sprintf("InputPassportElementErrorSourceFiles%+v", Alias(*i))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputPassportElementErrorSourceFiles) TypeID() uint32 {
	return InputPassportElementErrorSourceFilesTypeID
}

// TypeName returns name of type in TL schema.
func (*InputPassportElementErrorSourceFiles) TypeName() string {
	return "inputPassportElementErrorSourceFiles"
}

// TypeInfo returns info about TL type.
func (i *InputPassportElementErrorSourceFiles) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputPassportElementErrorSourceFiles",
		ID:   InputPassportElementErrorSourceFilesTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "FileHashes",
			SchemaName: "file_hashes",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (i *InputPassportElementErrorSourceFiles) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputPassportElementErrorSourceFiles#673401d6 as nil")
	}
	b.PutID(InputPassportElementErrorSourceFilesTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputPassportElementErrorSourceFiles) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputPassportElementErrorSourceFiles#673401d6 as nil")
	}
	b.PutInt(len(i.FileHashes))
	for _, v := range i.FileHashes {
		b.PutBytes(v)
	}
	return nil
}

// Decode implements bin.Decoder.
func (i *InputPassportElementErrorSourceFiles) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputPassportElementErrorSourceFiles#673401d6 to nil")
	}
	if err := b.ConsumeID(InputPassportElementErrorSourceFilesTypeID); err != nil {
		return fmt.Errorf("unable to decode inputPassportElementErrorSourceFiles#673401d6: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputPassportElementErrorSourceFiles) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputPassportElementErrorSourceFiles#673401d6 to nil")
	}
	{
		headerLen, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode inputPassportElementErrorSourceFiles#673401d6: field file_hashes: %w", err)
		}

		if headerLen > 0 {
			i.FileHashes = make([][]byte, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := b.Bytes()
			if err != nil {
				return fmt.Errorf("unable to decode inputPassportElementErrorSourceFiles#673401d6: field file_hashes: %w", err)
			}
			i.FileHashes = append(i.FileHashes, value)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (i *InputPassportElementErrorSourceFiles) EncodeTDLibJSON(b tdjson.Encoder) error {
	if i == nil {
		return fmt.Errorf("can't encode inputPassportElementErrorSourceFiles#673401d6 as nil")
	}
	b.ObjStart()
	b.PutID("inputPassportElementErrorSourceFiles")
	b.Comma()
	b.FieldStart("file_hashes")
	b.ArrStart()
	for _, v := range i.FileHashes {
		b.PutBytes(v)
		b.Comma()
	}
	b.StripComma()
	b.ArrEnd()
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (i *InputPassportElementErrorSourceFiles) DecodeTDLibJSON(b tdjson.Decoder) error {
	if i == nil {
		return fmt.Errorf("can't decode inputPassportElementErrorSourceFiles#673401d6 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("inputPassportElementErrorSourceFiles"); err != nil {
				return fmt.Errorf("unable to decode inputPassportElementErrorSourceFiles#673401d6: %w", err)
			}
		case "file_hashes":
			if err := b.Arr(func(b tdjson.Decoder) error {
				value, err := b.Bytes()
				if err != nil {
					return fmt.Errorf("unable to decode inputPassportElementErrorSourceFiles#673401d6: field file_hashes: %w", err)
				}
				i.FileHashes = append(i.FileHashes, value)
				return nil
			}); err != nil {
				return fmt.Errorf("unable to decode inputPassportElementErrorSourceFiles#673401d6: field file_hashes: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetFileHashes returns value of FileHashes field.
func (i *InputPassportElementErrorSourceFiles) GetFileHashes() (value [][]byte) {
	if i == nil {
		return
	}
	return i.FileHashes
}

// InputPassportElementErrorSourceClassName is schema name of InputPassportElementErrorSourceClass.
const InputPassportElementErrorSourceClassName = "InputPassportElementErrorSource"

// InputPassportElementErrorSourceClass represents InputPassportElementErrorSource generic type.
//
// Example:
//
//	g, err := tdapi.DecodeInputPassportElementErrorSource(buf)
//	if err != nil {
//	    panic(err)
//	}
//	switch v := g.(type) {
//	case *tdapi.InputPassportElementErrorSourceUnspecified: // inputPassportElementErrorSourceUnspecified#fed9c6f
//	case *tdapi.InputPassportElementErrorSourceDataField: // inputPassportElementErrorSourceDataField#e68fa006
//	case *tdapi.InputPassportElementErrorSourceFrontSide: // inputPassportElementErrorSourceFrontSide#230c87bd
//	case *tdapi.InputPassportElementErrorSourceReverseSide: // inputPassportElementErrorSourceReverseSide#189efdfb
//	case *tdapi.InputPassportElementErrorSourceSelfie: // inputPassportElementErrorSourceSelfie#d1e42c98
//	case *tdapi.InputPassportElementErrorSourceTranslationFile: // inputPassportElementErrorSourceTranslationFile#1e268a7b
//	case *tdapi.InputPassportElementErrorSourceTranslationFiles: // inputPassportElementErrorSourceTranslationFiles#ef54819b
//	case *tdapi.InputPassportElementErrorSourceFile: // inputPassportElementErrorSourceFile#ee355dcb
//	case *tdapi.InputPassportElementErrorSourceFiles: // inputPassportElementErrorSourceFiles#673401d6
//	default: panic(v)
//	}
type InputPassportElementErrorSourceClass interface {
	bin.Encoder
	bin.Decoder
	bin.BareEncoder
	bin.BareDecoder
	construct() InputPassportElementErrorSourceClass

	// TypeID returns type id in TL schema.
	//
	// See https://core.telegram.org/mtproto/TL-tl#remarks.
	TypeID() uint32
	// TypeName returns name of type in TL schema.
	TypeName() string
	// String implements fmt.Stringer.
	String() string
	// Zero returns true if current object has a zero value.
	Zero() bool

	EncodeTDLibJSON(b tdjson.Encoder) error
	DecodeTDLibJSON(b tdjson.Decoder) error
}

// DecodeInputPassportElementErrorSource implements binary de-serialization for InputPassportElementErrorSourceClass.
func DecodeInputPassportElementErrorSource(buf *bin.Buffer) (InputPassportElementErrorSourceClass, error) {
	id, err := buf.PeekID()
	if err != nil {
		return nil, err
	}
	switch id {
	case InputPassportElementErrorSourceUnspecifiedTypeID:
		// Decoding inputPassportElementErrorSourceUnspecified#fed9c6f.
		v := InputPassportElementErrorSourceUnspecified{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputPassportElementErrorSourceClass: %w", err)
		}
		return &v, nil
	case InputPassportElementErrorSourceDataFieldTypeID:
		// Decoding inputPassportElementErrorSourceDataField#e68fa006.
		v := InputPassportElementErrorSourceDataField{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputPassportElementErrorSourceClass: %w", err)
		}
		return &v, nil
	case InputPassportElementErrorSourceFrontSideTypeID:
		// Decoding inputPassportElementErrorSourceFrontSide#230c87bd.
		v := InputPassportElementErrorSourceFrontSide{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputPassportElementErrorSourceClass: %w", err)
		}
		return &v, nil
	case InputPassportElementErrorSourceReverseSideTypeID:
		// Decoding inputPassportElementErrorSourceReverseSide#189efdfb.
		v := InputPassportElementErrorSourceReverseSide{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputPassportElementErrorSourceClass: %w", err)
		}
		return &v, nil
	case InputPassportElementErrorSourceSelfieTypeID:
		// Decoding inputPassportElementErrorSourceSelfie#d1e42c98.
		v := InputPassportElementErrorSourceSelfie{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputPassportElementErrorSourceClass: %w", err)
		}
		return &v, nil
	case InputPassportElementErrorSourceTranslationFileTypeID:
		// Decoding inputPassportElementErrorSourceTranslationFile#1e268a7b.
		v := InputPassportElementErrorSourceTranslationFile{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputPassportElementErrorSourceClass: %w", err)
		}
		return &v, nil
	case InputPassportElementErrorSourceTranslationFilesTypeID:
		// Decoding inputPassportElementErrorSourceTranslationFiles#ef54819b.
		v := InputPassportElementErrorSourceTranslationFiles{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputPassportElementErrorSourceClass: %w", err)
		}
		return &v, nil
	case InputPassportElementErrorSourceFileTypeID:
		// Decoding inputPassportElementErrorSourceFile#ee355dcb.
		v := InputPassportElementErrorSourceFile{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputPassportElementErrorSourceClass: %w", err)
		}
		return &v, nil
	case InputPassportElementErrorSourceFilesTypeID:
		// Decoding inputPassportElementErrorSourceFiles#673401d6.
		v := InputPassportElementErrorSourceFiles{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputPassportElementErrorSourceClass: %w", err)
		}
		return &v, nil
	default:
		return nil, fmt.Errorf("unable to decode InputPassportElementErrorSourceClass: %w", bin.NewUnexpectedID(id))
	}
}

// DecodeTDLibJSONInputPassportElementErrorSource implements binary de-serialization for InputPassportElementErrorSourceClass.
func DecodeTDLibJSONInputPassportElementErrorSource(buf tdjson.Decoder) (InputPassportElementErrorSourceClass, error) {
	id, err := buf.FindTypeID()
	if err != nil {
		return nil, err
	}
	switch id {
	case "inputPassportElementErrorSourceUnspecified":
		// Decoding inputPassportElementErrorSourceUnspecified#fed9c6f.
		v := InputPassportElementErrorSourceUnspecified{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputPassportElementErrorSourceClass: %w", err)
		}
		return &v, nil
	case "inputPassportElementErrorSourceDataField":
		// Decoding inputPassportElementErrorSourceDataField#e68fa006.
		v := InputPassportElementErrorSourceDataField{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputPassportElementErrorSourceClass: %w", err)
		}
		return &v, nil
	case "inputPassportElementErrorSourceFrontSide":
		// Decoding inputPassportElementErrorSourceFrontSide#230c87bd.
		v := InputPassportElementErrorSourceFrontSide{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputPassportElementErrorSourceClass: %w", err)
		}
		return &v, nil
	case "inputPassportElementErrorSourceReverseSide":
		// Decoding inputPassportElementErrorSourceReverseSide#189efdfb.
		v := InputPassportElementErrorSourceReverseSide{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputPassportElementErrorSourceClass: %w", err)
		}
		return &v, nil
	case "inputPassportElementErrorSourceSelfie":
		// Decoding inputPassportElementErrorSourceSelfie#d1e42c98.
		v := InputPassportElementErrorSourceSelfie{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputPassportElementErrorSourceClass: %w", err)
		}
		return &v, nil
	case "inputPassportElementErrorSourceTranslationFile":
		// Decoding inputPassportElementErrorSourceTranslationFile#1e268a7b.
		v := InputPassportElementErrorSourceTranslationFile{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputPassportElementErrorSourceClass: %w", err)
		}
		return &v, nil
	case "inputPassportElementErrorSourceTranslationFiles":
		// Decoding inputPassportElementErrorSourceTranslationFiles#ef54819b.
		v := InputPassportElementErrorSourceTranslationFiles{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputPassportElementErrorSourceClass: %w", err)
		}
		return &v, nil
	case "inputPassportElementErrorSourceFile":
		// Decoding inputPassportElementErrorSourceFile#ee355dcb.
		v := InputPassportElementErrorSourceFile{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputPassportElementErrorSourceClass: %w", err)
		}
		return &v, nil
	case "inputPassportElementErrorSourceFiles":
		// Decoding inputPassportElementErrorSourceFiles#673401d6.
		v := InputPassportElementErrorSourceFiles{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputPassportElementErrorSourceClass: %w", err)
		}
		return &v, nil
	default:
		return nil, fmt.Errorf("unable to decode InputPassportElementErrorSourceClass: %w", tdjson.NewUnexpectedID(id))
	}
}

// InputPassportElementErrorSource boxes the InputPassportElementErrorSourceClass providing a helper.
type InputPassportElementErrorSourceBox struct {
	InputPassportElementErrorSource InputPassportElementErrorSourceClass
}

// Decode implements bin.Decoder for InputPassportElementErrorSourceBox.
func (b *InputPassportElementErrorSourceBox) Decode(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("unable to decode InputPassportElementErrorSourceBox to nil")
	}
	v, err := DecodeInputPassportElementErrorSource(buf)
	if err != nil {
		return fmt.Errorf("unable to decode boxed value: %w", err)
	}
	b.InputPassportElementErrorSource = v
	return nil
}

// Encode implements bin.Encode for InputPassportElementErrorSourceBox.
func (b *InputPassportElementErrorSourceBox) Encode(buf *bin.Buffer) error {
	if b == nil || b.InputPassportElementErrorSource == nil {
		return fmt.Errorf("unable to encode InputPassportElementErrorSourceClass as nil")
	}
	return b.InputPassportElementErrorSource.Encode(buf)
}

// DecodeTDLibJSON implements bin.Decoder for InputPassportElementErrorSourceBox.
func (b *InputPassportElementErrorSourceBox) DecodeTDLibJSON(buf tdjson.Decoder) error {
	if b == nil {
		return fmt.Errorf("unable to decode InputPassportElementErrorSourceBox to nil")
	}
	v, err := DecodeTDLibJSONInputPassportElementErrorSource(buf)
	if err != nil {
		return fmt.Errorf("unable to decode boxed value: %w", err)
	}
	b.InputPassportElementErrorSource = v
	return nil
}

// EncodeTDLibJSON implements bin.Encode for InputPassportElementErrorSourceBox.
func (b *InputPassportElementErrorSourceBox) EncodeTDLibJSON(buf tdjson.Encoder) error {
	if b == nil || b.InputPassportElementErrorSource == nil {
		return fmt.Errorf("unable to encode InputPassportElementErrorSourceClass as nil")
	}
	return b.InputPassportElementErrorSource.EncodeTDLibJSON(buf)
}
