// Code generated by gotdgen, DO NOT EDIT.

package tdapi

import (
	"context"
	"errors"
	"fmt"
	"sort"
	"strings"

	"go.uber.org/multierr"

	"go.mau.fi/mautrix-telegram/pkg/gotd/bin"
	"go.mau.fi/mautrix-telegram/pkg/gotd/tdjson"
	"go.mau.fi/mautrix-telegram/pkg/gotd/tdp"
	"go.mau.fi/mautrix-telegram/pkg/gotd/tgerr"
)

// No-op definition for keeping imports.
var (
	_ = bin.Buffer{}
	_ = context.Background()
	_ = fmt.Stringer(nil)
	_ = strings.Builder{}
	_ = errors.Is
	_ = multierr.AppendInto
	_ = sort.Ints
	_ = tdp.Format
	_ = tgerr.Error{}
	_ = tdjson.Encoder{}
)

// SessionTypeAndroid represents TL type `sessionTypeAndroid#84836098`.
type SessionTypeAndroid struct {
}

// SessionTypeAndroidTypeID is TL type id of SessionTypeAndroid.
const SessionTypeAndroidTypeID = 0x84836098

// construct implements constructor of SessionTypeClass.
func (s SessionTypeAndroid) construct() SessionTypeClass { return &s }

// Ensuring interfaces in compile-time for SessionTypeAndroid.
var (
	_ bin.Encoder     = &SessionTypeAndroid{}
	_ bin.Decoder     = &SessionTypeAndroid{}
	_ bin.BareEncoder = &SessionTypeAndroid{}
	_ bin.BareDecoder = &SessionTypeAndroid{}

	_ SessionTypeClass = &SessionTypeAndroid{}
)

func (s *SessionTypeAndroid) Zero() bool {
	if s == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (s *SessionTypeAndroid) String() string {
	if s == nil {
		return "SessionTypeAndroid(nil)"
	}
	type Alias SessionTypeAndroid
	return fmt.Sprintf("SessionTypeAndroid%+v", Alias(*s))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*SessionTypeAndroid) TypeID() uint32 {
	return SessionTypeAndroidTypeID
}

// TypeName returns name of type in TL schema.
func (*SessionTypeAndroid) TypeName() string {
	return "sessionTypeAndroid"
}

// TypeInfo returns info about TL type.
func (s *SessionTypeAndroid) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "sessionTypeAndroid",
		ID:   SessionTypeAndroidTypeID,
	}
	if s == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (s *SessionTypeAndroid) Encode(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't encode sessionTypeAndroid#84836098 as nil")
	}
	b.PutID(SessionTypeAndroidTypeID)
	return s.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (s *SessionTypeAndroid) EncodeBare(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't encode sessionTypeAndroid#84836098 as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (s *SessionTypeAndroid) Decode(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't decode sessionTypeAndroid#84836098 to nil")
	}
	if err := b.ConsumeID(SessionTypeAndroidTypeID); err != nil {
		return fmt.Errorf("unable to decode sessionTypeAndroid#84836098: %w", err)
	}
	return s.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (s *SessionTypeAndroid) DecodeBare(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't decode sessionTypeAndroid#84836098 to nil")
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (s *SessionTypeAndroid) EncodeTDLibJSON(b tdjson.Encoder) error {
	if s == nil {
		return fmt.Errorf("can't encode sessionTypeAndroid#84836098 as nil")
	}
	b.ObjStart()
	b.PutID("sessionTypeAndroid")
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (s *SessionTypeAndroid) DecodeTDLibJSON(b tdjson.Decoder) error {
	if s == nil {
		return fmt.Errorf("can't decode sessionTypeAndroid#84836098 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("sessionTypeAndroid"); err != nil {
				return fmt.Errorf("unable to decode sessionTypeAndroid#84836098: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// SessionTypeApple represents TL type `sessionTypeApple#9399d24b`.
type SessionTypeApple struct {
}

// SessionTypeAppleTypeID is TL type id of SessionTypeApple.
const SessionTypeAppleTypeID = 0x9399d24b

// construct implements constructor of SessionTypeClass.
func (s SessionTypeApple) construct() SessionTypeClass { return &s }

// Ensuring interfaces in compile-time for SessionTypeApple.
var (
	_ bin.Encoder     = &SessionTypeApple{}
	_ bin.Decoder     = &SessionTypeApple{}
	_ bin.BareEncoder = &SessionTypeApple{}
	_ bin.BareDecoder = &SessionTypeApple{}

	_ SessionTypeClass = &SessionTypeApple{}
)

func (s *SessionTypeApple) Zero() bool {
	if s == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (s *SessionTypeApple) String() string {
	if s == nil {
		return "SessionTypeApple(nil)"
	}
	type Alias SessionTypeApple
	return fmt.Sprintf("SessionTypeApple%+v", Alias(*s))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*SessionTypeApple) TypeID() uint32 {
	return SessionTypeAppleTypeID
}

// TypeName returns name of type in TL schema.
func (*SessionTypeApple) TypeName() string {
	return "sessionTypeApple"
}

// TypeInfo returns info about TL type.
func (s *SessionTypeApple) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "sessionTypeApple",
		ID:   SessionTypeAppleTypeID,
	}
	if s == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (s *SessionTypeApple) Encode(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't encode sessionTypeApple#9399d24b as nil")
	}
	b.PutID(SessionTypeAppleTypeID)
	return s.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (s *SessionTypeApple) EncodeBare(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't encode sessionTypeApple#9399d24b as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (s *SessionTypeApple) Decode(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't decode sessionTypeApple#9399d24b to nil")
	}
	if err := b.ConsumeID(SessionTypeAppleTypeID); err != nil {
		return fmt.Errorf("unable to decode sessionTypeApple#9399d24b: %w", err)
	}
	return s.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (s *SessionTypeApple) DecodeBare(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't decode sessionTypeApple#9399d24b to nil")
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (s *SessionTypeApple) EncodeTDLibJSON(b tdjson.Encoder) error {
	if s == nil {
		return fmt.Errorf("can't encode sessionTypeApple#9399d24b as nil")
	}
	b.ObjStart()
	b.PutID("sessionTypeApple")
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (s *SessionTypeApple) DecodeTDLibJSON(b tdjson.Decoder) error {
	if s == nil {
		return fmt.Errorf("can't decode sessionTypeApple#9399d24b to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("sessionTypeApple"); err != nil {
				return fmt.Errorf("unable to decode sessionTypeApple#9399d24b: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// SessionTypeBrave represents TL type `sessionTypeBrave#b778e9ed`.
type SessionTypeBrave struct {
}

// SessionTypeBraveTypeID is TL type id of SessionTypeBrave.
const SessionTypeBraveTypeID = 0xb778e9ed

// construct implements constructor of SessionTypeClass.
func (s SessionTypeBrave) construct() SessionTypeClass { return &s }

// Ensuring interfaces in compile-time for SessionTypeBrave.
var (
	_ bin.Encoder     = &SessionTypeBrave{}
	_ bin.Decoder     = &SessionTypeBrave{}
	_ bin.BareEncoder = &SessionTypeBrave{}
	_ bin.BareDecoder = &SessionTypeBrave{}

	_ SessionTypeClass = &SessionTypeBrave{}
)

func (s *SessionTypeBrave) Zero() bool {
	if s == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (s *SessionTypeBrave) String() string {
	if s == nil {
		return "SessionTypeBrave(nil)"
	}
	type Alias SessionTypeBrave
	return fmt.Sprintf("SessionTypeBrave%+v", Alias(*s))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*SessionTypeBrave) TypeID() uint32 {
	return SessionTypeBraveTypeID
}

// TypeName returns name of type in TL schema.
func (*SessionTypeBrave) TypeName() string {
	return "sessionTypeBrave"
}

// TypeInfo returns info about TL type.
func (s *SessionTypeBrave) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "sessionTypeBrave",
		ID:   SessionTypeBraveTypeID,
	}
	if s == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (s *SessionTypeBrave) Encode(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't encode sessionTypeBrave#b778e9ed as nil")
	}
	b.PutID(SessionTypeBraveTypeID)
	return s.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (s *SessionTypeBrave) EncodeBare(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't encode sessionTypeBrave#b778e9ed as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (s *SessionTypeBrave) Decode(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't decode sessionTypeBrave#b778e9ed to nil")
	}
	if err := b.ConsumeID(SessionTypeBraveTypeID); err != nil {
		return fmt.Errorf("unable to decode sessionTypeBrave#b778e9ed: %w", err)
	}
	return s.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (s *SessionTypeBrave) DecodeBare(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't decode sessionTypeBrave#b778e9ed to nil")
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (s *SessionTypeBrave) EncodeTDLibJSON(b tdjson.Encoder) error {
	if s == nil {
		return fmt.Errorf("can't encode sessionTypeBrave#b778e9ed as nil")
	}
	b.ObjStart()
	b.PutID("sessionTypeBrave")
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (s *SessionTypeBrave) DecodeTDLibJSON(b tdjson.Decoder) error {
	if s == nil {
		return fmt.Errorf("can't decode sessionTypeBrave#b778e9ed to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("sessionTypeBrave"); err != nil {
				return fmt.Errorf("unable to decode sessionTypeBrave#b778e9ed: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// SessionTypeChrome represents TL type `sessionTypeChrome#5dc92969`.
type SessionTypeChrome struct {
}

// SessionTypeChromeTypeID is TL type id of SessionTypeChrome.
const SessionTypeChromeTypeID = 0x5dc92969

// construct implements constructor of SessionTypeClass.
func (s SessionTypeChrome) construct() SessionTypeClass { return &s }

// Ensuring interfaces in compile-time for SessionTypeChrome.
var (
	_ bin.Encoder     = &SessionTypeChrome{}
	_ bin.Decoder     = &SessionTypeChrome{}
	_ bin.BareEncoder = &SessionTypeChrome{}
	_ bin.BareDecoder = &SessionTypeChrome{}

	_ SessionTypeClass = &SessionTypeChrome{}
)

func (s *SessionTypeChrome) Zero() bool {
	if s == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (s *SessionTypeChrome) String() string {
	if s == nil {
		return "SessionTypeChrome(nil)"
	}
	type Alias SessionTypeChrome
	return fmt.Sprintf("SessionTypeChrome%+v", Alias(*s))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*SessionTypeChrome) TypeID() uint32 {
	return SessionTypeChromeTypeID
}

// TypeName returns name of type in TL schema.
func (*SessionTypeChrome) TypeName() string {
	return "sessionTypeChrome"
}

// TypeInfo returns info about TL type.
func (s *SessionTypeChrome) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "sessionTypeChrome",
		ID:   SessionTypeChromeTypeID,
	}
	if s == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (s *SessionTypeChrome) Encode(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't encode sessionTypeChrome#5dc92969 as nil")
	}
	b.PutID(SessionTypeChromeTypeID)
	return s.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (s *SessionTypeChrome) EncodeBare(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't encode sessionTypeChrome#5dc92969 as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (s *SessionTypeChrome) Decode(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't decode sessionTypeChrome#5dc92969 to nil")
	}
	if err := b.ConsumeID(SessionTypeChromeTypeID); err != nil {
		return fmt.Errorf("unable to decode sessionTypeChrome#5dc92969: %w", err)
	}
	return s.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (s *SessionTypeChrome) DecodeBare(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't decode sessionTypeChrome#5dc92969 to nil")
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (s *SessionTypeChrome) EncodeTDLibJSON(b tdjson.Encoder) error {
	if s == nil {
		return fmt.Errorf("can't encode sessionTypeChrome#5dc92969 as nil")
	}
	b.ObjStart()
	b.PutID("sessionTypeChrome")
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (s *SessionTypeChrome) DecodeTDLibJSON(b tdjson.Decoder) error {
	if s == nil {
		return fmt.Errorf("can't decode sessionTypeChrome#5dc92969 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("sessionTypeChrome"); err != nil {
				return fmt.Errorf("unable to decode sessionTypeChrome#5dc92969: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// SessionTypeEdge represents TL type `sessionTypeEdge#dfe0cb5b`.
type SessionTypeEdge struct {
}

// SessionTypeEdgeTypeID is TL type id of SessionTypeEdge.
const SessionTypeEdgeTypeID = 0xdfe0cb5b

// construct implements constructor of SessionTypeClass.
func (s SessionTypeEdge) construct() SessionTypeClass { return &s }

// Ensuring interfaces in compile-time for SessionTypeEdge.
var (
	_ bin.Encoder     = &SessionTypeEdge{}
	_ bin.Decoder     = &SessionTypeEdge{}
	_ bin.BareEncoder = &SessionTypeEdge{}
	_ bin.BareDecoder = &SessionTypeEdge{}

	_ SessionTypeClass = &SessionTypeEdge{}
)

func (s *SessionTypeEdge) Zero() bool {
	if s == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (s *SessionTypeEdge) String() string {
	if s == nil {
		return "SessionTypeEdge(nil)"
	}
	type Alias SessionTypeEdge
	return fmt.Sprintf("SessionTypeEdge%+v", Alias(*s))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*SessionTypeEdge) TypeID() uint32 {
	return SessionTypeEdgeTypeID
}

// TypeName returns name of type in TL schema.
func (*SessionTypeEdge) TypeName() string {
	return "sessionTypeEdge"
}

// TypeInfo returns info about TL type.
func (s *SessionTypeEdge) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "sessionTypeEdge",
		ID:   SessionTypeEdgeTypeID,
	}
	if s == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (s *SessionTypeEdge) Encode(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't encode sessionTypeEdge#dfe0cb5b as nil")
	}
	b.PutID(SessionTypeEdgeTypeID)
	return s.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (s *SessionTypeEdge) EncodeBare(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't encode sessionTypeEdge#dfe0cb5b as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (s *SessionTypeEdge) Decode(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't decode sessionTypeEdge#dfe0cb5b to nil")
	}
	if err := b.ConsumeID(SessionTypeEdgeTypeID); err != nil {
		return fmt.Errorf("unable to decode sessionTypeEdge#dfe0cb5b: %w", err)
	}
	return s.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (s *SessionTypeEdge) DecodeBare(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't decode sessionTypeEdge#dfe0cb5b to nil")
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (s *SessionTypeEdge) EncodeTDLibJSON(b tdjson.Encoder) error {
	if s == nil {
		return fmt.Errorf("can't encode sessionTypeEdge#dfe0cb5b as nil")
	}
	b.ObjStart()
	b.PutID("sessionTypeEdge")
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (s *SessionTypeEdge) DecodeTDLibJSON(b tdjson.Decoder) error {
	if s == nil {
		return fmt.Errorf("can't decode sessionTypeEdge#dfe0cb5b to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("sessionTypeEdge"); err != nil {
				return fmt.Errorf("unable to decode sessionTypeEdge#dfe0cb5b: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// SessionTypeFirefox represents TL type `sessionTypeFirefox#7e83fda4`.
type SessionTypeFirefox struct {
}

// SessionTypeFirefoxTypeID is TL type id of SessionTypeFirefox.
const SessionTypeFirefoxTypeID = 0x7e83fda4

// construct implements constructor of SessionTypeClass.
func (s SessionTypeFirefox) construct() SessionTypeClass { return &s }

// Ensuring interfaces in compile-time for SessionTypeFirefox.
var (
	_ bin.Encoder     = &SessionTypeFirefox{}
	_ bin.Decoder     = &SessionTypeFirefox{}
	_ bin.BareEncoder = &SessionTypeFirefox{}
	_ bin.BareDecoder = &SessionTypeFirefox{}

	_ SessionTypeClass = &SessionTypeFirefox{}
)

func (s *SessionTypeFirefox) Zero() bool {
	if s == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (s *SessionTypeFirefox) String() string {
	if s == nil {
		return "SessionTypeFirefox(nil)"
	}
	type Alias SessionTypeFirefox
	return fmt.Sprintf("SessionTypeFirefox%+v", Alias(*s))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*SessionTypeFirefox) TypeID() uint32 {
	return SessionTypeFirefoxTypeID
}

// TypeName returns name of type in TL schema.
func (*SessionTypeFirefox) TypeName() string {
	return "sessionTypeFirefox"
}

// TypeInfo returns info about TL type.
func (s *SessionTypeFirefox) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "sessionTypeFirefox",
		ID:   SessionTypeFirefoxTypeID,
	}
	if s == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (s *SessionTypeFirefox) Encode(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't encode sessionTypeFirefox#7e83fda4 as nil")
	}
	b.PutID(SessionTypeFirefoxTypeID)
	return s.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (s *SessionTypeFirefox) EncodeBare(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't encode sessionTypeFirefox#7e83fda4 as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (s *SessionTypeFirefox) Decode(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't decode sessionTypeFirefox#7e83fda4 to nil")
	}
	if err := b.ConsumeID(SessionTypeFirefoxTypeID); err != nil {
		return fmt.Errorf("unable to decode sessionTypeFirefox#7e83fda4: %w", err)
	}
	return s.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (s *SessionTypeFirefox) DecodeBare(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't decode sessionTypeFirefox#7e83fda4 to nil")
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (s *SessionTypeFirefox) EncodeTDLibJSON(b tdjson.Encoder) error {
	if s == nil {
		return fmt.Errorf("can't encode sessionTypeFirefox#7e83fda4 as nil")
	}
	b.ObjStart()
	b.PutID("sessionTypeFirefox")
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (s *SessionTypeFirefox) DecodeTDLibJSON(b tdjson.Decoder) error {
	if s == nil {
		return fmt.Errorf("can't decode sessionTypeFirefox#7e83fda4 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("sessionTypeFirefox"); err != nil {
				return fmt.Errorf("unable to decode sessionTypeFirefox#7e83fda4: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// SessionTypeIpad represents TL type `sessionTypeIpad#4d2abeef`.
type SessionTypeIpad struct {
}

// SessionTypeIpadTypeID is TL type id of SessionTypeIpad.
const SessionTypeIpadTypeID = 0x4d2abeef

// construct implements constructor of SessionTypeClass.
func (s SessionTypeIpad) construct() SessionTypeClass { return &s }

// Ensuring interfaces in compile-time for SessionTypeIpad.
var (
	_ bin.Encoder     = &SessionTypeIpad{}
	_ bin.Decoder     = &SessionTypeIpad{}
	_ bin.BareEncoder = &SessionTypeIpad{}
	_ bin.BareDecoder = &SessionTypeIpad{}

	_ SessionTypeClass = &SessionTypeIpad{}
)

func (s *SessionTypeIpad) Zero() bool {
	if s == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (s *SessionTypeIpad) String() string {
	if s == nil {
		return "SessionTypeIpad(nil)"
	}
	type Alias SessionTypeIpad
	return fmt.Sprintf("SessionTypeIpad%+v", Alias(*s))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*SessionTypeIpad) TypeID() uint32 {
	return SessionTypeIpadTypeID
}

// TypeName returns name of type in TL schema.
func (*SessionTypeIpad) TypeName() string {
	return "sessionTypeIpad"
}

// TypeInfo returns info about TL type.
func (s *SessionTypeIpad) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "sessionTypeIpad",
		ID:   SessionTypeIpadTypeID,
	}
	if s == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (s *SessionTypeIpad) Encode(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't encode sessionTypeIpad#4d2abeef as nil")
	}
	b.PutID(SessionTypeIpadTypeID)
	return s.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (s *SessionTypeIpad) EncodeBare(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't encode sessionTypeIpad#4d2abeef as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (s *SessionTypeIpad) Decode(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't decode sessionTypeIpad#4d2abeef to nil")
	}
	if err := b.ConsumeID(SessionTypeIpadTypeID); err != nil {
		return fmt.Errorf("unable to decode sessionTypeIpad#4d2abeef: %w", err)
	}
	return s.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (s *SessionTypeIpad) DecodeBare(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't decode sessionTypeIpad#4d2abeef to nil")
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (s *SessionTypeIpad) EncodeTDLibJSON(b tdjson.Encoder) error {
	if s == nil {
		return fmt.Errorf("can't encode sessionTypeIpad#4d2abeef as nil")
	}
	b.ObjStart()
	b.PutID("sessionTypeIpad")
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (s *SessionTypeIpad) DecodeTDLibJSON(b tdjson.Decoder) error {
	if s == nil {
		return fmt.Errorf("can't decode sessionTypeIpad#4d2abeef to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("sessionTypeIpad"); err != nil {
				return fmt.Errorf("unable to decode sessionTypeIpad#4d2abeef: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// SessionTypeIphone represents TL type `sessionTypeIphone#5d182bd`.
type SessionTypeIphone struct {
}

// SessionTypeIphoneTypeID is TL type id of SessionTypeIphone.
const SessionTypeIphoneTypeID = 0x5d182bd

// construct implements constructor of SessionTypeClass.
func (s SessionTypeIphone) construct() SessionTypeClass { return &s }

// Ensuring interfaces in compile-time for SessionTypeIphone.
var (
	_ bin.Encoder     = &SessionTypeIphone{}
	_ bin.Decoder     = &SessionTypeIphone{}
	_ bin.BareEncoder = &SessionTypeIphone{}
	_ bin.BareDecoder = &SessionTypeIphone{}

	_ SessionTypeClass = &SessionTypeIphone{}
)

func (s *SessionTypeIphone) Zero() bool {
	if s == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (s *SessionTypeIphone) String() string {
	if s == nil {
		return "SessionTypeIphone(nil)"
	}
	type Alias SessionTypeIphone
	return fmt.Sprintf("SessionTypeIphone%+v", Alias(*s))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*SessionTypeIphone) TypeID() uint32 {
	return SessionTypeIphoneTypeID
}

// TypeName returns name of type in TL schema.
func (*SessionTypeIphone) TypeName() string {
	return "sessionTypeIphone"
}

// TypeInfo returns info about TL type.
func (s *SessionTypeIphone) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "sessionTypeIphone",
		ID:   SessionTypeIphoneTypeID,
	}
	if s == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (s *SessionTypeIphone) Encode(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't encode sessionTypeIphone#5d182bd as nil")
	}
	b.PutID(SessionTypeIphoneTypeID)
	return s.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (s *SessionTypeIphone) EncodeBare(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't encode sessionTypeIphone#5d182bd as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (s *SessionTypeIphone) Decode(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't decode sessionTypeIphone#5d182bd to nil")
	}
	if err := b.ConsumeID(SessionTypeIphoneTypeID); err != nil {
		return fmt.Errorf("unable to decode sessionTypeIphone#5d182bd: %w", err)
	}
	return s.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (s *SessionTypeIphone) DecodeBare(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't decode sessionTypeIphone#5d182bd to nil")
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (s *SessionTypeIphone) EncodeTDLibJSON(b tdjson.Encoder) error {
	if s == nil {
		return fmt.Errorf("can't encode sessionTypeIphone#5d182bd as nil")
	}
	b.ObjStart()
	b.PutID("sessionTypeIphone")
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (s *SessionTypeIphone) DecodeTDLibJSON(b tdjson.Decoder) error {
	if s == nil {
		return fmt.Errorf("can't decode sessionTypeIphone#5d182bd to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("sessionTypeIphone"); err != nil {
				return fmt.Errorf("unable to decode sessionTypeIphone#5d182bd: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// SessionTypeLinux represents TL type `sessionTypeLinux#a757ba69`.
type SessionTypeLinux struct {
}

// SessionTypeLinuxTypeID is TL type id of SessionTypeLinux.
const SessionTypeLinuxTypeID = 0xa757ba69

// construct implements constructor of SessionTypeClass.
func (s SessionTypeLinux) construct() SessionTypeClass { return &s }

// Ensuring interfaces in compile-time for SessionTypeLinux.
var (
	_ bin.Encoder     = &SessionTypeLinux{}
	_ bin.Decoder     = &SessionTypeLinux{}
	_ bin.BareEncoder = &SessionTypeLinux{}
	_ bin.BareDecoder = &SessionTypeLinux{}

	_ SessionTypeClass = &SessionTypeLinux{}
)

func (s *SessionTypeLinux) Zero() bool {
	if s == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (s *SessionTypeLinux) String() string {
	if s == nil {
		return "SessionTypeLinux(nil)"
	}
	type Alias SessionTypeLinux
	return fmt.Sprintf("SessionTypeLinux%+v", Alias(*s))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*SessionTypeLinux) TypeID() uint32 {
	return SessionTypeLinuxTypeID
}

// TypeName returns name of type in TL schema.
func (*SessionTypeLinux) TypeName() string {
	return "sessionTypeLinux"
}

// TypeInfo returns info about TL type.
func (s *SessionTypeLinux) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "sessionTypeLinux",
		ID:   SessionTypeLinuxTypeID,
	}
	if s == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (s *SessionTypeLinux) Encode(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't encode sessionTypeLinux#a757ba69 as nil")
	}
	b.PutID(SessionTypeLinuxTypeID)
	return s.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (s *SessionTypeLinux) EncodeBare(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't encode sessionTypeLinux#a757ba69 as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (s *SessionTypeLinux) Decode(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't decode sessionTypeLinux#a757ba69 to nil")
	}
	if err := b.ConsumeID(SessionTypeLinuxTypeID); err != nil {
		return fmt.Errorf("unable to decode sessionTypeLinux#a757ba69: %w", err)
	}
	return s.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (s *SessionTypeLinux) DecodeBare(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't decode sessionTypeLinux#a757ba69 to nil")
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (s *SessionTypeLinux) EncodeTDLibJSON(b tdjson.Encoder) error {
	if s == nil {
		return fmt.Errorf("can't encode sessionTypeLinux#a757ba69 as nil")
	}
	b.ObjStart()
	b.PutID("sessionTypeLinux")
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (s *SessionTypeLinux) DecodeTDLibJSON(b tdjson.Decoder) error {
	if s == nil {
		return fmt.Errorf("can't decode sessionTypeLinux#a757ba69 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("sessionTypeLinux"); err != nil {
				return fmt.Errorf("unable to decode sessionTypeLinux#a757ba69: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// SessionTypeMAC represents TL type `sessionTypeMac#db81caa1`.
type SessionTypeMAC struct {
}

// SessionTypeMACTypeID is TL type id of SessionTypeMAC.
const SessionTypeMACTypeID = 0xdb81caa1

// construct implements constructor of SessionTypeClass.
func (s SessionTypeMAC) construct() SessionTypeClass { return &s }

// Ensuring interfaces in compile-time for SessionTypeMAC.
var (
	_ bin.Encoder     = &SessionTypeMAC{}
	_ bin.Decoder     = &SessionTypeMAC{}
	_ bin.BareEncoder = &SessionTypeMAC{}
	_ bin.BareDecoder = &SessionTypeMAC{}

	_ SessionTypeClass = &SessionTypeMAC{}
)

func (s *SessionTypeMAC) Zero() bool {
	if s == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (s *SessionTypeMAC) String() string {
	if s == nil {
		return "SessionTypeMAC(nil)"
	}
	type Alias SessionTypeMAC
	return fmt.Sprintf("SessionTypeMAC%+v", Alias(*s))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*SessionTypeMAC) TypeID() uint32 {
	return SessionTypeMACTypeID
}

// TypeName returns name of type in TL schema.
func (*SessionTypeMAC) TypeName() string {
	return "sessionTypeMac"
}

// TypeInfo returns info about TL type.
func (s *SessionTypeMAC) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "sessionTypeMac",
		ID:   SessionTypeMACTypeID,
	}
	if s == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (s *SessionTypeMAC) Encode(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't encode sessionTypeMac#db81caa1 as nil")
	}
	b.PutID(SessionTypeMACTypeID)
	return s.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (s *SessionTypeMAC) EncodeBare(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't encode sessionTypeMac#db81caa1 as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (s *SessionTypeMAC) Decode(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't decode sessionTypeMac#db81caa1 to nil")
	}
	if err := b.ConsumeID(SessionTypeMACTypeID); err != nil {
		return fmt.Errorf("unable to decode sessionTypeMac#db81caa1: %w", err)
	}
	return s.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (s *SessionTypeMAC) DecodeBare(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't decode sessionTypeMac#db81caa1 to nil")
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (s *SessionTypeMAC) EncodeTDLibJSON(b tdjson.Encoder) error {
	if s == nil {
		return fmt.Errorf("can't encode sessionTypeMac#db81caa1 as nil")
	}
	b.ObjStart()
	b.PutID("sessionTypeMac")
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (s *SessionTypeMAC) DecodeTDLibJSON(b tdjson.Decoder) error {
	if s == nil {
		return fmt.Errorf("can't decode sessionTypeMac#db81caa1 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("sessionTypeMac"); err != nil {
				return fmt.Errorf("unable to decode sessionTypeMac#db81caa1: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// SessionTypeOpera represents TL type `sessionTypeOpera#a8c21c7a`.
type SessionTypeOpera struct {
}

// SessionTypeOperaTypeID is TL type id of SessionTypeOpera.
const SessionTypeOperaTypeID = 0xa8c21c7a

// construct implements constructor of SessionTypeClass.
func (s SessionTypeOpera) construct() SessionTypeClass { return &s }

// Ensuring interfaces in compile-time for SessionTypeOpera.
var (
	_ bin.Encoder     = &SessionTypeOpera{}
	_ bin.Decoder     = &SessionTypeOpera{}
	_ bin.BareEncoder = &SessionTypeOpera{}
	_ bin.BareDecoder = &SessionTypeOpera{}

	_ SessionTypeClass = &SessionTypeOpera{}
)

func (s *SessionTypeOpera) Zero() bool {
	if s == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (s *SessionTypeOpera) String() string {
	if s == nil {
		return "SessionTypeOpera(nil)"
	}
	type Alias SessionTypeOpera
	return fmt.Sprintf("SessionTypeOpera%+v", Alias(*s))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*SessionTypeOpera) TypeID() uint32 {
	return SessionTypeOperaTypeID
}

// TypeName returns name of type in TL schema.
func (*SessionTypeOpera) TypeName() string {
	return "sessionTypeOpera"
}

// TypeInfo returns info about TL type.
func (s *SessionTypeOpera) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "sessionTypeOpera",
		ID:   SessionTypeOperaTypeID,
	}
	if s == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (s *SessionTypeOpera) Encode(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't encode sessionTypeOpera#a8c21c7a as nil")
	}
	b.PutID(SessionTypeOperaTypeID)
	return s.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (s *SessionTypeOpera) EncodeBare(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't encode sessionTypeOpera#a8c21c7a as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (s *SessionTypeOpera) Decode(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't decode sessionTypeOpera#a8c21c7a to nil")
	}
	if err := b.ConsumeID(SessionTypeOperaTypeID); err != nil {
		return fmt.Errorf("unable to decode sessionTypeOpera#a8c21c7a: %w", err)
	}
	return s.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (s *SessionTypeOpera) DecodeBare(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't decode sessionTypeOpera#a8c21c7a to nil")
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (s *SessionTypeOpera) EncodeTDLibJSON(b tdjson.Encoder) error {
	if s == nil {
		return fmt.Errorf("can't encode sessionTypeOpera#a8c21c7a as nil")
	}
	b.ObjStart()
	b.PutID("sessionTypeOpera")
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (s *SessionTypeOpera) DecodeTDLibJSON(b tdjson.Decoder) error {
	if s == nil {
		return fmt.Errorf("can't decode sessionTypeOpera#a8c21c7a to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("sessionTypeOpera"); err != nil {
				return fmt.Errorf("unable to decode sessionTypeOpera#a8c21c7a: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// SessionTypeSafari represents TL type `sessionTypeSafari#2a5b9c59`.
type SessionTypeSafari struct {
}

// SessionTypeSafariTypeID is TL type id of SessionTypeSafari.
const SessionTypeSafariTypeID = 0x2a5b9c59

// construct implements constructor of SessionTypeClass.
func (s SessionTypeSafari) construct() SessionTypeClass { return &s }

// Ensuring interfaces in compile-time for SessionTypeSafari.
var (
	_ bin.Encoder     = &SessionTypeSafari{}
	_ bin.Decoder     = &SessionTypeSafari{}
	_ bin.BareEncoder = &SessionTypeSafari{}
	_ bin.BareDecoder = &SessionTypeSafari{}

	_ SessionTypeClass = &SessionTypeSafari{}
)

func (s *SessionTypeSafari) Zero() bool {
	if s == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (s *SessionTypeSafari) String() string {
	if s == nil {
		return "SessionTypeSafari(nil)"
	}
	type Alias SessionTypeSafari
	return fmt.Sprintf("SessionTypeSafari%+v", Alias(*s))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*SessionTypeSafari) TypeID() uint32 {
	return SessionTypeSafariTypeID
}

// TypeName returns name of type in TL schema.
func (*SessionTypeSafari) TypeName() string {
	return "sessionTypeSafari"
}

// TypeInfo returns info about TL type.
func (s *SessionTypeSafari) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "sessionTypeSafari",
		ID:   SessionTypeSafariTypeID,
	}
	if s == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (s *SessionTypeSafari) Encode(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't encode sessionTypeSafari#2a5b9c59 as nil")
	}
	b.PutID(SessionTypeSafariTypeID)
	return s.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (s *SessionTypeSafari) EncodeBare(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't encode sessionTypeSafari#2a5b9c59 as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (s *SessionTypeSafari) Decode(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't decode sessionTypeSafari#2a5b9c59 to nil")
	}
	if err := b.ConsumeID(SessionTypeSafariTypeID); err != nil {
		return fmt.Errorf("unable to decode sessionTypeSafari#2a5b9c59: %w", err)
	}
	return s.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (s *SessionTypeSafari) DecodeBare(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't decode sessionTypeSafari#2a5b9c59 to nil")
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (s *SessionTypeSafari) EncodeTDLibJSON(b tdjson.Encoder) error {
	if s == nil {
		return fmt.Errorf("can't encode sessionTypeSafari#2a5b9c59 as nil")
	}
	b.ObjStart()
	b.PutID("sessionTypeSafari")
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (s *SessionTypeSafari) DecodeTDLibJSON(b tdjson.Decoder) error {
	if s == nil {
		return fmt.Errorf("can't decode sessionTypeSafari#2a5b9c59 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("sessionTypeSafari"); err != nil {
				return fmt.Errorf("unable to decode sessionTypeSafari#2a5b9c59: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// SessionTypeUbuntu represents TL type `sessionTypeUbuntu#5d8f6ac5`.
type SessionTypeUbuntu struct {
}

// SessionTypeUbuntuTypeID is TL type id of SessionTypeUbuntu.
const SessionTypeUbuntuTypeID = 0x5d8f6ac5

// construct implements constructor of SessionTypeClass.
func (s SessionTypeUbuntu) construct() SessionTypeClass { return &s }

// Ensuring interfaces in compile-time for SessionTypeUbuntu.
var (
	_ bin.Encoder     = &SessionTypeUbuntu{}
	_ bin.Decoder     = &SessionTypeUbuntu{}
	_ bin.BareEncoder = &SessionTypeUbuntu{}
	_ bin.BareDecoder = &SessionTypeUbuntu{}

	_ SessionTypeClass = &SessionTypeUbuntu{}
)

func (s *SessionTypeUbuntu) Zero() bool {
	if s == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (s *SessionTypeUbuntu) String() string {
	if s == nil {
		return "SessionTypeUbuntu(nil)"
	}
	type Alias SessionTypeUbuntu
	return fmt.Sprintf("SessionTypeUbuntu%+v", Alias(*s))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*SessionTypeUbuntu) TypeID() uint32 {
	return SessionTypeUbuntuTypeID
}

// TypeName returns name of type in TL schema.
func (*SessionTypeUbuntu) TypeName() string {
	return "sessionTypeUbuntu"
}

// TypeInfo returns info about TL type.
func (s *SessionTypeUbuntu) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "sessionTypeUbuntu",
		ID:   SessionTypeUbuntuTypeID,
	}
	if s == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (s *SessionTypeUbuntu) Encode(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't encode sessionTypeUbuntu#5d8f6ac5 as nil")
	}
	b.PutID(SessionTypeUbuntuTypeID)
	return s.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (s *SessionTypeUbuntu) EncodeBare(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't encode sessionTypeUbuntu#5d8f6ac5 as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (s *SessionTypeUbuntu) Decode(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't decode sessionTypeUbuntu#5d8f6ac5 to nil")
	}
	if err := b.ConsumeID(SessionTypeUbuntuTypeID); err != nil {
		return fmt.Errorf("unable to decode sessionTypeUbuntu#5d8f6ac5: %w", err)
	}
	return s.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (s *SessionTypeUbuntu) DecodeBare(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't decode sessionTypeUbuntu#5d8f6ac5 to nil")
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (s *SessionTypeUbuntu) EncodeTDLibJSON(b tdjson.Encoder) error {
	if s == nil {
		return fmt.Errorf("can't encode sessionTypeUbuntu#5d8f6ac5 as nil")
	}
	b.ObjStart()
	b.PutID("sessionTypeUbuntu")
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (s *SessionTypeUbuntu) DecodeTDLibJSON(b tdjson.Decoder) error {
	if s == nil {
		return fmt.Errorf("can't decode sessionTypeUbuntu#5d8f6ac5 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("sessionTypeUbuntu"); err != nil {
				return fmt.Errorf("unable to decode sessionTypeUbuntu#5d8f6ac5: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// SessionTypeUnknown represents TL type `sessionTypeUnknown#df17030`.
type SessionTypeUnknown struct {
}

// SessionTypeUnknownTypeID is TL type id of SessionTypeUnknown.
const SessionTypeUnknownTypeID = 0xdf17030

// construct implements constructor of SessionTypeClass.
func (s SessionTypeUnknown) construct() SessionTypeClass { return &s }

// Ensuring interfaces in compile-time for SessionTypeUnknown.
var (
	_ bin.Encoder     = &SessionTypeUnknown{}
	_ bin.Decoder     = &SessionTypeUnknown{}
	_ bin.BareEncoder = &SessionTypeUnknown{}
	_ bin.BareDecoder = &SessionTypeUnknown{}

	_ SessionTypeClass = &SessionTypeUnknown{}
)

func (s *SessionTypeUnknown) Zero() bool {
	if s == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (s *SessionTypeUnknown) String() string {
	if s == nil {
		return "SessionTypeUnknown(nil)"
	}
	type Alias SessionTypeUnknown
	return fmt.Sprintf("SessionTypeUnknown%+v", Alias(*s))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*SessionTypeUnknown) TypeID() uint32 {
	return SessionTypeUnknownTypeID
}

// TypeName returns name of type in TL schema.
func (*SessionTypeUnknown) TypeName() string {
	return "sessionTypeUnknown"
}

// TypeInfo returns info about TL type.
func (s *SessionTypeUnknown) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "sessionTypeUnknown",
		ID:   SessionTypeUnknownTypeID,
	}
	if s == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (s *SessionTypeUnknown) Encode(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't encode sessionTypeUnknown#df17030 as nil")
	}
	b.PutID(SessionTypeUnknownTypeID)
	return s.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (s *SessionTypeUnknown) EncodeBare(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't encode sessionTypeUnknown#df17030 as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (s *SessionTypeUnknown) Decode(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't decode sessionTypeUnknown#df17030 to nil")
	}
	if err := b.ConsumeID(SessionTypeUnknownTypeID); err != nil {
		return fmt.Errorf("unable to decode sessionTypeUnknown#df17030: %w", err)
	}
	return s.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (s *SessionTypeUnknown) DecodeBare(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't decode sessionTypeUnknown#df17030 to nil")
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (s *SessionTypeUnknown) EncodeTDLibJSON(b tdjson.Encoder) error {
	if s == nil {
		return fmt.Errorf("can't encode sessionTypeUnknown#df17030 as nil")
	}
	b.ObjStart()
	b.PutID("sessionTypeUnknown")
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (s *SessionTypeUnknown) DecodeTDLibJSON(b tdjson.Decoder) error {
	if s == nil {
		return fmt.Errorf("can't decode sessionTypeUnknown#df17030 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("sessionTypeUnknown"); err != nil {
				return fmt.Errorf("unable to decode sessionTypeUnknown#df17030: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// SessionTypeVivaldi represents TL type `sessionTypeVivaldi#42c985ef`.
type SessionTypeVivaldi struct {
}

// SessionTypeVivaldiTypeID is TL type id of SessionTypeVivaldi.
const SessionTypeVivaldiTypeID = 0x42c985ef

// construct implements constructor of SessionTypeClass.
func (s SessionTypeVivaldi) construct() SessionTypeClass { return &s }

// Ensuring interfaces in compile-time for SessionTypeVivaldi.
var (
	_ bin.Encoder     = &SessionTypeVivaldi{}
	_ bin.Decoder     = &SessionTypeVivaldi{}
	_ bin.BareEncoder = &SessionTypeVivaldi{}
	_ bin.BareDecoder = &SessionTypeVivaldi{}

	_ SessionTypeClass = &SessionTypeVivaldi{}
)

func (s *SessionTypeVivaldi) Zero() bool {
	if s == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (s *SessionTypeVivaldi) String() string {
	if s == nil {
		return "SessionTypeVivaldi(nil)"
	}
	type Alias SessionTypeVivaldi
	return fmt.Sprintf("SessionTypeVivaldi%+v", Alias(*s))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*SessionTypeVivaldi) TypeID() uint32 {
	return SessionTypeVivaldiTypeID
}

// TypeName returns name of type in TL schema.
func (*SessionTypeVivaldi) TypeName() string {
	return "sessionTypeVivaldi"
}

// TypeInfo returns info about TL type.
func (s *SessionTypeVivaldi) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "sessionTypeVivaldi",
		ID:   SessionTypeVivaldiTypeID,
	}
	if s == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (s *SessionTypeVivaldi) Encode(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't encode sessionTypeVivaldi#42c985ef as nil")
	}
	b.PutID(SessionTypeVivaldiTypeID)
	return s.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (s *SessionTypeVivaldi) EncodeBare(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't encode sessionTypeVivaldi#42c985ef as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (s *SessionTypeVivaldi) Decode(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't decode sessionTypeVivaldi#42c985ef to nil")
	}
	if err := b.ConsumeID(SessionTypeVivaldiTypeID); err != nil {
		return fmt.Errorf("unable to decode sessionTypeVivaldi#42c985ef: %w", err)
	}
	return s.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (s *SessionTypeVivaldi) DecodeBare(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't decode sessionTypeVivaldi#42c985ef to nil")
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (s *SessionTypeVivaldi) EncodeTDLibJSON(b tdjson.Encoder) error {
	if s == nil {
		return fmt.Errorf("can't encode sessionTypeVivaldi#42c985ef as nil")
	}
	b.ObjStart()
	b.PutID("sessionTypeVivaldi")
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (s *SessionTypeVivaldi) DecodeTDLibJSON(b tdjson.Decoder) error {
	if s == nil {
		return fmt.Errorf("can't decode sessionTypeVivaldi#42c985ef to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("sessionTypeVivaldi"); err != nil {
				return fmt.Errorf("unable to decode sessionTypeVivaldi#42c985ef: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// SessionTypeWindows represents TL type `sessionTypeWindows#9c1272a8`.
type SessionTypeWindows struct {
}

// SessionTypeWindowsTypeID is TL type id of SessionTypeWindows.
const SessionTypeWindowsTypeID = 0x9c1272a8

// construct implements constructor of SessionTypeClass.
func (s SessionTypeWindows) construct() SessionTypeClass { return &s }

// Ensuring interfaces in compile-time for SessionTypeWindows.
var (
	_ bin.Encoder     = &SessionTypeWindows{}
	_ bin.Decoder     = &SessionTypeWindows{}
	_ bin.BareEncoder = &SessionTypeWindows{}
	_ bin.BareDecoder = &SessionTypeWindows{}

	_ SessionTypeClass = &SessionTypeWindows{}
)

func (s *SessionTypeWindows) Zero() bool {
	if s == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (s *SessionTypeWindows) String() string {
	if s == nil {
		return "SessionTypeWindows(nil)"
	}
	type Alias SessionTypeWindows
	return fmt.Sprintf("SessionTypeWindows%+v", Alias(*s))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*SessionTypeWindows) TypeID() uint32 {
	return SessionTypeWindowsTypeID
}

// TypeName returns name of type in TL schema.
func (*SessionTypeWindows) TypeName() string {
	return "sessionTypeWindows"
}

// TypeInfo returns info about TL type.
func (s *SessionTypeWindows) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "sessionTypeWindows",
		ID:   SessionTypeWindowsTypeID,
	}
	if s == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (s *SessionTypeWindows) Encode(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't encode sessionTypeWindows#9c1272a8 as nil")
	}
	b.PutID(SessionTypeWindowsTypeID)
	return s.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (s *SessionTypeWindows) EncodeBare(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't encode sessionTypeWindows#9c1272a8 as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (s *SessionTypeWindows) Decode(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't decode sessionTypeWindows#9c1272a8 to nil")
	}
	if err := b.ConsumeID(SessionTypeWindowsTypeID); err != nil {
		return fmt.Errorf("unable to decode sessionTypeWindows#9c1272a8: %w", err)
	}
	return s.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (s *SessionTypeWindows) DecodeBare(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't decode sessionTypeWindows#9c1272a8 to nil")
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (s *SessionTypeWindows) EncodeTDLibJSON(b tdjson.Encoder) error {
	if s == nil {
		return fmt.Errorf("can't encode sessionTypeWindows#9c1272a8 as nil")
	}
	b.ObjStart()
	b.PutID("sessionTypeWindows")
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (s *SessionTypeWindows) DecodeTDLibJSON(b tdjson.Decoder) error {
	if s == nil {
		return fmt.Errorf("can't decode sessionTypeWindows#9c1272a8 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("sessionTypeWindows"); err != nil {
				return fmt.Errorf("unable to decode sessionTypeWindows#9c1272a8: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// SessionTypeXbox represents TL type `sessionTypeXbox#6ea39dac`.
type SessionTypeXbox struct {
}

// SessionTypeXboxTypeID is TL type id of SessionTypeXbox.
const SessionTypeXboxTypeID = 0x6ea39dac

// construct implements constructor of SessionTypeClass.
func (s SessionTypeXbox) construct() SessionTypeClass { return &s }

// Ensuring interfaces in compile-time for SessionTypeXbox.
var (
	_ bin.Encoder     = &SessionTypeXbox{}
	_ bin.Decoder     = &SessionTypeXbox{}
	_ bin.BareEncoder = &SessionTypeXbox{}
	_ bin.BareDecoder = &SessionTypeXbox{}

	_ SessionTypeClass = &SessionTypeXbox{}
)

func (s *SessionTypeXbox) Zero() bool {
	if s == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (s *SessionTypeXbox) String() string {
	if s == nil {
		return "SessionTypeXbox(nil)"
	}
	type Alias SessionTypeXbox
	return fmt.Sprintf("SessionTypeXbox%+v", Alias(*s))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*SessionTypeXbox) TypeID() uint32 {
	return SessionTypeXboxTypeID
}

// TypeName returns name of type in TL schema.
func (*SessionTypeXbox) TypeName() string {
	return "sessionTypeXbox"
}

// TypeInfo returns info about TL type.
func (s *SessionTypeXbox) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "sessionTypeXbox",
		ID:   SessionTypeXboxTypeID,
	}
	if s == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (s *SessionTypeXbox) Encode(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't encode sessionTypeXbox#6ea39dac as nil")
	}
	b.PutID(SessionTypeXboxTypeID)
	return s.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (s *SessionTypeXbox) EncodeBare(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't encode sessionTypeXbox#6ea39dac as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (s *SessionTypeXbox) Decode(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't decode sessionTypeXbox#6ea39dac to nil")
	}
	if err := b.ConsumeID(SessionTypeXboxTypeID); err != nil {
		return fmt.Errorf("unable to decode sessionTypeXbox#6ea39dac: %w", err)
	}
	return s.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (s *SessionTypeXbox) DecodeBare(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't decode sessionTypeXbox#6ea39dac to nil")
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (s *SessionTypeXbox) EncodeTDLibJSON(b tdjson.Encoder) error {
	if s == nil {
		return fmt.Errorf("can't encode sessionTypeXbox#6ea39dac as nil")
	}
	b.ObjStart()
	b.PutID("sessionTypeXbox")
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (s *SessionTypeXbox) DecodeTDLibJSON(b tdjson.Decoder) error {
	if s == nil {
		return fmt.Errorf("can't decode sessionTypeXbox#6ea39dac to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("sessionTypeXbox"); err != nil {
				return fmt.Errorf("unable to decode sessionTypeXbox#6ea39dac: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// SessionTypeClassName is schema name of SessionTypeClass.
const SessionTypeClassName = "SessionType"

// SessionTypeClass represents SessionType generic type.
//
// Example:
//
//	g, err := tdapi.DecodeSessionType(buf)
//	if err != nil {
//	    panic(err)
//	}
//	switch v := g.(type) {
//	case *tdapi.SessionTypeAndroid: // sessionTypeAndroid#84836098
//	case *tdapi.SessionTypeApple: // sessionTypeApple#9399d24b
//	case *tdapi.SessionTypeBrave: // sessionTypeBrave#b778e9ed
//	case *tdapi.SessionTypeChrome: // sessionTypeChrome#5dc92969
//	case *tdapi.SessionTypeEdge: // sessionTypeEdge#dfe0cb5b
//	case *tdapi.SessionTypeFirefox: // sessionTypeFirefox#7e83fda4
//	case *tdapi.SessionTypeIpad: // sessionTypeIpad#4d2abeef
//	case *tdapi.SessionTypeIphone: // sessionTypeIphone#5d182bd
//	case *tdapi.SessionTypeLinux: // sessionTypeLinux#a757ba69
//	case *tdapi.SessionTypeMAC: // sessionTypeMac#db81caa1
//	case *tdapi.SessionTypeOpera: // sessionTypeOpera#a8c21c7a
//	case *tdapi.SessionTypeSafari: // sessionTypeSafari#2a5b9c59
//	case *tdapi.SessionTypeUbuntu: // sessionTypeUbuntu#5d8f6ac5
//	case *tdapi.SessionTypeUnknown: // sessionTypeUnknown#df17030
//	case *tdapi.SessionTypeVivaldi: // sessionTypeVivaldi#42c985ef
//	case *tdapi.SessionTypeWindows: // sessionTypeWindows#9c1272a8
//	case *tdapi.SessionTypeXbox: // sessionTypeXbox#6ea39dac
//	default: panic(v)
//	}
type SessionTypeClass interface {
	bin.Encoder
	bin.Decoder
	bin.BareEncoder
	bin.BareDecoder
	construct() SessionTypeClass

	// TypeID returns type id in TL schema.
	//
	// See https://core.telegram.org/mtproto/TL-tl#remarks.
	TypeID() uint32
	// TypeName returns name of type in TL schema.
	TypeName() string
	// String implements fmt.Stringer.
	String() string
	// Zero returns true if current object has a zero value.
	Zero() bool

	EncodeTDLibJSON(b tdjson.Encoder) error
	DecodeTDLibJSON(b tdjson.Decoder) error
}

// DecodeSessionType implements binary de-serialization for SessionTypeClass.
func DecodeSessionType(buf *bin.Buffer) (SessionTypeClass, error) {
	id, err := buf.PeekID()
	if err != nil {
		return nil, err
	}
	switch id {
	case SessionTypeAndroidTypeID:
		// Decoding sessionTypeAndroid#84836098.
		v := SessionTypeAndroid{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode SessionTypeClass: %w", err)
		}
		return &v, nil
	case SessionTypeAppleTypeID:
		// Decoding sessionTypeApple#9399d24b.
		v := SessionTypeApple{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode SessionTypeClass: %w", err)
		}
		return &v, nil
	case SessionTypeBraveTypeID:
		// Decoding sessionTypeBrave#b778e9ed.
		v := SessionTypeBrave{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode SessionTypeClass: %w", err)
		}
		return &v, nil
	case SessionTypeChromeTypeID:
		// Decoding sessionTypeChrome#5dc92969.
		v := SessionTypeChrome{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode SessionTypeClass: %w", err)
		}
		return &v, nil
	case SessionTypeEdgeTypeID:
		// Decoding sessionTypeEdge#dfe0cb5b.
		v := SessionTypeEdge{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode SessionTypeClass: %w", err)
		}
		return &v, nil
	case SessionTypeFirefoxTypeID:
		// Decoding sessionTypeFirefox#7e83fda4.
		v := SessionTypeFirefox{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode SessionTypeClass: %w", err)
		}
		return &v, nil
	case SessionTypeIpadTypeID:
		// Decoding sessionTypeIpad#4d2abeef.
		v := SessionTypeIpad{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode SessionTypeClass: %w", err)
		}
		return &v, nil
	case SessionTypeIphoneTypeID:
		// Decoding sessionTypeIphone#5d182bd.
		v := SessionTypeIphone{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode SessionTypeClass: %w", err)
		}
		return &v, nil
	case SessionTypeLinuxTypeID:
		// Decoding sessionTypeLinux#a757ba69.
		v := SessionTypeLinux{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode SessionTypeClass: %w", err)
		}
		return &v, nil
	case SessionTypeMACTypeID:
		// Decoding sessionTypeMac#db81caa1.
		v := SessionTypeMAC{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode SessionTypeClass: %w", err)
		}
		return &v, nil
	case SessionTypeOperaTypeID:
		// Decoding sessionTypeOpera#a8c21c7a.
		v := SessionTypeOpera{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode SessionTypeClass: %w", err)
		}
		return &v, nil
	case SessionTypeSafariTypeID:
		// Decoding sessionTypeSafari#2a5b9c59.
		v := SessionTypeSafari{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode SessionTypeClass: %w", err)
		}
		return &v, nil
	case SessionTypeUbuntuTypeID:
		// Decoding sessionTypeUbuntu#5d8f6ac5.
		v := SessionTypeUbuntu{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode SessionTypeClass: %w", err)
		}
		return &v, nil
	case SessionTypeUnknownTypeID:
		// Decoding sessionTypeUnknown#df17030.
		v := SessionTypeUnknown{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode SessionTypeClass: %w", err)
		}
		return &v, nil
	case SessionTypeVivaldiTypeID:
		// Decoding sessionTypeVivaldi#42c985ef.
		v := SessionTypeVivaldi{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode SessionTypeClass: %w", err)
		}
		return &v, nil
	case SessionTypeWindowsTypeID:
		// Decoding sessionTypeWindows#9c1272a8.
		v := SessionTypeWindows{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode SessionTypeClass: %w", err)
		}
		return &v, nil
	case SessionTypeXboxTypeID:
		// Decoding sessionTypeXbox#6ea39dac.
		v := SessionTypeXbox{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode SessionTypeClass: %w", err)
		}
		return &v, nil
	default:
		return nil, fmt.Errorf("unable to decode SessionTypeClass: %w", bin.NewUnexpectedID(id))
	}
}

// DecodeTDLibJSONSessionType implements binary de-serialization for SessionTypeClass.
func DecodeTDLibJSONSessionType(buf tdjson.Decoder) (SessionTypeClass, error) {
	id, err := buf.FindTypeID()
	if err != nil {
		return nil, err
	}
	switch id {
	case "sessionTypeAndroid":
		// Decoding sessionTypeAndroid#84836098.
		v := SessionTypeAndroid{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode SessionTypeClass: %w", err)
		}
		return &v, nil
	case "sessionTypeApple":
		// Decoding sessionTypeApple#9399d24b.
		v := SessionTypeApple{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode SessionTypeClass: %w", err)
		}
		return &v, nil
	case "sessionTypeBrave":
		// Decoding sessionTypeBrave#b778e9ed.
		v := SessionTypeBrave{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode SessionTypeClass: %w", err)
		}
		return &v, nil
	case "sessionTypeChrome":
		// Decoding sessionTypeChrome#5dc92969.
		v := SessionTypeChrome{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode SessionTypeClass: %w", err)
		}
		return &v, nil
	case "sessionTypeEdge":
		// Decoding sessionTypeEdge#dfe0cb5b.
		v := SessionTypeEdge{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode SessionTypeClass: %w", err)
		}
		return &v, nil
	case "sessionTypeFirefox":
		// Decoding sessionTypeFirefox#7e83fda4.
		v := SessionTypeFirefox{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode SessionTypeClass: %w", err)
		}
		return &v, nil
	case "sessionTypeIpad":
		// Decoding sessionTypeIpad#4d2abeef.
		v := SessionTypeIpad{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode SessionTypeClass: %w", err)
		}
		return &v, nil
	case "sessionTypeIphone":
		// Decoding sessionTypeIphone#5d182bd.
		v := SessionTypeIphone{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode SessionTypeClass: %w", err)
		}
		return &v, nil
	case "sessionTypeLinux":
		// Decoding sessionTypeLinux#a757ba69.
		v := SessionTypeLinux{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode SessionTypeClass: %w", err)
		}
		return &v, nil
	case "sessionTypeMac":
		// Decoding sessionTypeMac#db81caa1.
		v := SessionTypeMAC{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode SessionTypeClass: %w", err)
		}
		return &v, nil
	case "sessionTypeOpera":
		// Decoding sessionTypeOpera#a8c21c7a.
		v := SessionTypeOpera{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode SessionTypeClass: %w", err)
		}
		return &v, nil
	case "sessionTypeSafari":
		// Decoding sessionTypeSafari#2a5b9c59.
		v := SessionTypeSafari{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode SessionTypeClass: %w", err)
		}
		return &v, nil
	case "sessionTypeUbuntu":
		// Decoding sessionTypeUbuntu#5d8f6ac5.
		v := SessionTypeUbuntu{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode SessionTypeClass: %w", err)
		}
		return &v, nil
	case "sessionTypeUnknown":
		// Decoding sessionTypeUnknown#df17030.
		v := SessionTypeUnknown{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode SessionTypeClass: %w", err)
		}
		return &v, nil
	case "sessionTypeVivaldi":
		// Decoding sessionTypeVivaldi#42c985ef.
		v := SessionTypeVivaldi{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode SessionTypeClass: %w", err)
		}
		return &v, nil
	case "sessionTypeWindows":
		// Decoding sessionTypeWindows#9c1272a8.
		v := SessionTypeWindows{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode SessionTypeClass: %w", err)
		}
		return &v, nil
	case "sessionTypeXbox":
		// Decoding sessionTypeXbox#6ea39dac.
		v := SessionTypeXbox{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode SessionTypeClass: %w", err)
		}
		return &v, nil
	default:
		return nil, fmt.Errorf("unable to decode SessionTypeClass: %w", tdjson.NewUnexpectedID(id))
	}
}

// SessionType boxes the SessionTypeClass providing a helper.
type SessionTypeBox struct {
	SessionType SessionTypeClass
}

// Decode implements bin.Decoder for SessionTypeBox.
func (b *SessionTypeBox) Decode(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("unable to decode SessionTypeBox to nil")
	}
	v, err := DecodeSessionType(buf)
	if err != nil {
		return fmt.Errorf("unable to decode boxed value: %w", err)
	}
	b.SessionType = v
	return nil
}

// Encode implements bin.Encode for SessionTypeBox.
func (b *SessionTypeBox) Encode(buf *bin.Buffer) error {
	if b == nil || b.SessionType == nil {
		return fmt.Errorf("unable to encode SessionTypeClass as nil")
	}
	return b.SessionType.Encode(buf)
}

// DecodeTDLibJSON implements bin.Decoder for SessionTypeBox.
func (b *SessionTypeBox) DecodeTDLibJSON(buf tdjson.Decoder) error {
	if b == nil {
		return fmt.Errorf("unable to decode SessionTypeBox to nil")
	}
	v, err := DecodeTDLibJSONSessionType(buf)
	if err != nil {
		return fmt.Errorf("unable to decode boxed value: %w", err)
	}
	b.SessionType = v
	return nil
}

// EncodeTDLibJSON implements bin.Encode for SessionTypeBox.
func (b *SessionTypeBox) EncodeTDLibJSON(buf tdjson.Encoder) error {
	if b == nil || b.SessionType == nil {
		return fmt.Errorf("unable to encode SessionTypeClass as nil")
	}
	return b.SessionType.EncodeTDLibJSON(buf)
}
