// Code generated by gotdgen, DO NOT EDIT.

package tdapi

import (
	"context"
	"errors"
	"fmt"
	"sort"
	"strings"

	"go.uber.org/multierr"

	"go.mau.fi/mautrix-telegram/pkg/gotd/bin"
	"go.mau.fi/mautrix-telegram/pkg/gotd/tdjson"
	"go.mau.fi/mautrix-telegram/pkg/gotd/tdp"
	"go.mau.fi/mautrix-telegram/pkg/gotd/tgerr"
)

// No-op definition for keeping imports.
var (
	_ = bin.Buffer{}
	_ = context.Background()
	_ = fmt.Stringer(nil)
	_ = strings.Builder{}
	_ = errors.Is
	_ = multierr.AppendInto
	_ = sort.Ints
	_ = tdp.Format
	_ = tgerr.Error{}
	_ = tdjson.Encoder{}
)

// InputMessageText represents TL type `inputMessageText#f350d894`.
type InputMessageText struct {
	// Formatted text to be sent; 0-getOption("message_text_length_max") characters. Only
	// Bold, Italic, Underline, Strikethrough, Spoiler, CustomEmoji, BlockQuote,
	// ExpandableBlockQuote,
	Text FormattedText
	// Options to be used for generation of a link preview; may be null if none; pass null to
	// use default link preview options
	LinkPreviewOptions LinkPreviewOptions
	// True, if a chat message draft must be deleted
	ClearDraft bool
}

// InputMessageTextTypeID is TL type id of InputMessageText.
const InputMessageTextTypeID = 0xf350d894

// construct implements constructor of InputMessageContentClass.
func (i InputMessageText) construct() InputMessageContentClass { return &i }

// Ensuring interfaces in compile-time for InputMessageText.
var (
	_ bin.Encoder     = &InputMessageText{}
	_ bin.Decoder     = &InputMessageText{}
	_ bin.BareEncoder = &InputMessageText{}
	_ bin.BareDecoder = &InputMessageText{}

	_ InputMessageContentClass = &InputMessageText{}
)

func (i *InputMessageText) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.Text.Zero()) {
		return false
	}
	if !(i.LinkPreviewOptions.Zero()) {
		return false
	}
	if !(i.ClearDraft == false) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputMessageText) String() string {
	if i == nil {
		return "InputMessageText(nil)"
	}
	type Alias InputMessageText
	return fmt.Sprintf("InputMessageText%+v", Alias(*i))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputMessageText) TypeID() uint32 {
	return InputMessageTextTypeID
}

// TypeName returns name of type in TL schema.
func (*InputMessageText) TypeName() string {
	return "inputMessageText"
}

// TypeInfo returns info about TL type.
func (i *InputMessageText) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputMessageText",
		ID:   InputMessageTextTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Text",
			SchemaName: "text",
		},
		{
			Name:       "LinkPreviewOptions",
			SchemaName: "link_preview_options",
		},
		{
			Name:       "ClearDraft",
			SchemaName: "clear_draft",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (i *InputMessageText) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageText#f350d894 as nil")
	}
	b.PutID(InputMessageTextTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputMessageText) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageText#f350d894 as nil")
	}
	if err := i.Text.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageText#f350d894: field text: %w", err)
	}
	if err := i.LinkPreviewOptions.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageText#f350d894: field link_preview_options: %w", err)
	}
	b.PutBool(i.ClearDraft)
	return nil
}

// Decode implements bin.Decoder.
func (i *InputMessageText) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageText#f350d894 to nil")
	}
	if err := b.ConsumeID(InputMessageTextTypeID); err != nil {
		return fmt.Errorf("unable to decode inputMessageText#f350d894: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputMessageText) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageText#f350d894 to nil")
	}
	{
		if err := i.Text.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputMessageText#f350d894: field text: %w", err)
		}
	}
	{
		if err := i.LinkPreviewOptions.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputMessageText#f350d894: field link_preview_options: %w", err)
		}
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageText#f350d894: field clear_draft: %w", err)
		}
		i.ClearDraft = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (i *InputMessageText) EncodeTDLibJSON(b tdjson.Encoder) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageText#f350d894 as nil")
	}
	b.ObjStart()
	b.PutID("inputMessageText")
	b.Comma()
	b.FieldStart("text")
	if err := i.Text.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageText#f350d894: field text: %w", err)
	}
	b.Comma()
	b.FieldStart("link_preview_options")
	if err := i.LinkPreviewOptions.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageText#f350d894: field link_preview_options: %w", err)
	}
	b.Comma()
	b.FieldStart("clear_draft")
	b.PutBool(i.ClearDraft)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (i *InputMessageText) DecodeTDLibJSON(b tdjson.Decoder) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageText#f350d894 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("inputMessageText"); err != nil {
				return fmt.Errorf("unable to decode inputMessageText#f350d894: %w", err)
			}
		case "text":
			if err := i.Text.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode inputMessageText#f350d894: field text: %w", err)
			}
		case "link_preview_options":
			if err := i.LinkPreviewOptions.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode inputMessageText#f350d894: field link_preview_options: %w", err)
			}
		case "clear_draft":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageText#f350d894: field clear_draft: %w", err)
			}
			i.ClearDraft = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetText returns value of Text field.
func (i *InputMessageText) GetText() (value FormattedText) {
	if i == nil {
		return
	}
	return i.Text
}

// GetLinkPreviewOptions returns value of LinkPreviewOptions field.
func (i *InputMessageText) GetLinkPreviewOptions() (value LinkPreviewOptions) {
	if i == nil {
		return
	}
	return i.LinkPreviewOptions
}

// GetClearDraft returns value of ClearDraft field.
func (i *InputMessageText) GetClearDraft() (value bool) {
	if i == nil {
		return
	}
	return i.ClearDraft
}

// InputMessageAnimation represents TL type `inputMessageAnimation#19fe563`.
type InputMessageAnimation struct {
	// Animation file to be sent
	Animation InputFileClass
	// Animation thumbnail; pass null to skip thumbnail uploading
	Thumbnail InputThumbnail
	// File identifiers of the stickers added to the animation, if applicable
	AddedStickerFileIDs []int32
	// Duration of the animation, in seconds
	Duration int32
	// Width of the animation; may be replaced by the server
	Width int32
	// Height of the animation; may be replaced by the server
	Height int32
	// Animation caption; pass null to use an empty caption;
	// 0-getOption("message_caption_length_max") characters
	Caption FormattedText
	// True, if the caption must be shown above the animation; otherwise, the caption must be
	// shown below the animation; not supported in secret chats
	ShowCaptionAboveMedia bool
	// True, if the animation preview must be covered by a spoiler animation; not supported
	// in secret chats
	HasSpoiler bool
}

// InputMessageAnimationTypeID is TL type id of InputMessageAnimation.
const InputMessageAnimationTypeID = 0x19fe563

// construct implements constructor of InputMessageContentClass.
func (i InputMessageAnimation) construct() InputMessageContentClass { return &i }

// Ensuring interfaces in compile-time for InputMessageAnimation.
var (
	_ bin.Encoder     = &InputMessageAnimation{}
	_ bin.Decoder     = &InputMessageAnimation{}
	_ bin.BareEncoder = &InputMessageAnimation{}
	_ bin.BareDecoder = &InputMessageAnimation{}

	_ InputMessageContentClass = &InputMessageAnimation{}
)

func (i *InputMessageAnimation) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.Animation == nil) {
		return false
	}
	if !(i.Thumbnail.Zero()) {
		return false
	}
	if !(i.AddedStickerFileIDs == nil) {
		return false
	}
	if !(i.Duration == 0) {
		return false
	}
	if !(i.Width == 0) {
		return false
	}
	if !(i.Height == 0) {
		return false
	}
	if !(i.Caption.Zero()) {
		return false
	}
	if !(i.ShowCaptionAboveMedia == false) {
		return false
	}
	if !(i.HasSpoiler == false) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputMessageAnimation) String() string {
	if i == nil {
		return "InputMessageAnimation(nil)"
	}
	type Alias InputMessageAnimation
	return fmt.Sprintf("InputMessageAnimation%+v", Alias(*i))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputMessageAnimation) TypeID() uint32 {
	return InputMessageAnimationTypeID
}

// TypeName returns name of type in TL schema.
func (*InputMessageAnimation) TypeName() string {
	return "inputMessageAnimation"
}

// TypeInfo returns info about TL type.
func (i *InputMessageAnimation) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputMessageAnimation",
		ID:   InputMessageAnimationTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Animation",
			SchemaName: "animation",
		},
		{
			Name:       "Thumbnail",
			SchemaName: "thumbnail",
		},
		{
			Name:       "AddedStickerFileIDs",
			SchemaName: "added_sticker_file_ids",
		},
		{
			Name:       "Duration",
			SchemaName: "duration",
		},
		{
			Name:       "Width",
			SchemaName: "width",
		},
		{
			Name:       "Height",
			SchemaName: "height",
		},
		{
			Name:       "Caption",
			SchemaName: "caption",
		},
		{
			Name:       "ShowCaptionAboveMedia",
			SchemaName: "show_caption_above_media",
		},
		{
			Name:       "HasSpoiler",
			SchemaName: "has_spoiler",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (i *InputMessageAnimation) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageAnimation#19fe563 as nil")
	}
	b.PutID(InputMessageAnimationTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputMessageAnimation) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageAnimation#19fe563 as nil")
	}
	if i.Animation == nil {
		return fmt.Errorf("unable to encode inputMessageAnimation#19fe563: field animation is nil")
	}
	if err := i.Animation.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageAnimation#19fe563: field animation: %w", err)
	}
	if err := i.Thumbnail.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageAnimation#19fe563: field thumbnail: %w", err)
	}
	b.PutInt(len(i.AddedStickerFileIDs))
	for _, v := range i.AddedStickerFileIDs {
		b.PutInt32(v)
	}
	b.PutInt32(i.Duration)
	b.PutInt32(i.Width)
	b.PutInt32(i.Height)
	if err := i.Caption.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageAnimation#19fe563: field caption: %w", err)
	}
	b.PutBool(i.ShowCaptionAboveMedia)
	b.PutBool(i.HasSpoiler)
	return nil
}

// Decode implements bin.Decoder.
func (i *InputMessageAnimation) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageAnimation#19fe563 to nil")
	}
	if err := b.ConsumeID(InputMessageAnimationTypeID); err != nil {
		return fmt.Errorf("unable to decode inputMessageAnimation#19fe563: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputMessageAnimation) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageAnimation#19fe563 to nil")
	}
	{
		value, err := DecodeInputFile(b)
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageAnimation#19fe563: field animation: %w", err)
		}
		i.Animation = value
	}
	{
		if err := i.Thumbnail.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputMessageAnimation#19fe563: field thumbnail: %w", err)
		}
	}
	{
		headerLen, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageAnimation#19fe563: field added_sticker_file_ids: %w", err)
		}

		if headerLen > 0 {
			i.AddedStickerFileIDs = make([]int32, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageAnimation#19fe563: field added_sticker_file_ids: %w", err)
			}
			i.AddedStickerFileIDs = append(i.AddedStickerFileIDs, value)
		}
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageAnimation#19fe563: field duration: %w", err)
		}
		i.Duration = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageAnimation#19fe563: field width: %w", err)
		}
		i.Width = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageAnimation#19fe563: field height: %w", err)
		}
		i.Height = value
	}
	{
		if err := i.Caption.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputMessageAnimation#19fe563: field caption: %w", err)
		}
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageAnimation#19fe563: field show_caption_above_media: %w", err)
		}
		i.ShowCaptionAboveMedia = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageAnimation#19fe563: field has_spoiler: %w", err)
		}
		i.HasSpoiler = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (i *InputMessageAnimation) EncodeTDLibJSON(b tdjson.Encoder) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageAnimation#19fe563 as nil")
	}
	b.ObjStart()
	b.PutID("inputMessageAnimation")
	b.Comma()
	b.FieldStart("animation")
	if i.Animation == nil {
		return fmt.Errorf("unable to encode inputMessageAnimation#19fe563: field animation is nil")
	}
	if err := i.Animation.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageAnimation#19fe563: field animation: %w", err)
	}
	b.Comma()
	b.FieldStart("thumbnail")
	if err := i.Thumbnail.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageAnimation#19fe563: field thumbnail: %w", err)
	}
	b.Comma()
	b.FieldStart("added_sticker_file_ids")
	b.ArrStart()
	for _, v := range i.AddedStickerFileIDs {
		b.PutInt32(v)
		b.Comma()
	}
	b.StripComma()
	b.ArrEnd()
	b.Comma()
	b.FieldStart("duration")
	b.PutInt32(i.Duration)
	b.Comma()
	b.FieldStart("width")
	b.PutInt32(i.Width)
	b.Comma()
	b.FieldStart("height")
	b.PutInt32(i.Height)
	b.Comma()
	b.FieldStart("caption")
	if err := i.Caption.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageAnimation#19fe563: field caption: %w", err)
	}
	b.Comma()
	b.FieldStart("show_caption_above_media")
	b.PutBool(i.ShowCaptionAboveMedia)
	b.Comma()
	b.FieldStart("has_spoiler")
	b.PutBool(i.HasSpoiler)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (i *InputMessageAnimation) DecodeTDLibJSON(b tdjson.Decoder) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageAnimation#19fe563 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("inputMessageAnimation"); err != nil {
				return fmt.Errorf("unable to decode inputMessageAnimation#19fe563: %w", err)
			}
		case "animation":
			value, err := DecodeTDLibJSONInputFile(b)
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageAnimation#19fe563: field animation: %w", err)
			}
			i.Animation = value
		case "thumbnail":
			if err := i.Thumbnail.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode inputMessageAnimation#19fe563: field thumbnail: %w", err)
			}
		case "added_sticker_file_ids":
			if err := b.Arr(func(b tdjson.Decoder) error {
				value, err := b.Int32()
				if err != nil {
					return fmt.Errorf("unable to decode inputMessageAnimation#19fe563: field added_sticker_file_ids: %w", err)
				}
				i.AddedStickerFileIDs = append(i.AddedStickerFileIDs, value)
				return nil
			}); err != nil {
				return fmt.Errorf("unable to decode inputMessageAnimation#19fe563: field added_sticker_file_ids: %w", err)
			}
		case "duration":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageAnimation#19fe563: field duration: %w", err)
			}
			i.Duration = value
		case "width":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageAnimation#19fe563: field width: %w", err)
			}
			i.Width = value
		case "height":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageAnimation#19fe563: field height: %w", err)
			}
			i.Height = value
		case "caption":
			if err := i.Caption.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode inputMessageAnimation#19fe563: field caption: %w", err)
			}
		case "show_caption_above_media":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageAnimation#19fe563: field show_caption_above_media: %w", err)
			}
			i.ShowCaptionAboveMedia = value
		case "has_spoiler":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageAnimation#19fe563: field has_spoiler: %w", err)
			}
			i.HasSpoiler = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetAnimation returns value of Animation field.
func (i *InputMessageAnimation) GetAnimation() (value InputFileClass) {
	if i == nil {
		return
	}
	return i.Animation
}

// GetThumbnail returns value of Thumbnail field.
func (i *InputMessageAnimation) GetThumbnail() (value InputThumbnail) {
	if i == nil {
		return
	}
	return i.Thumbnail
}

// GetAddedStickerFileIDs returns value of AddedStickerFileIDs field.
func (i *InputMessageAnimation) GetAddedStickerFileIDs() (value []int32) {
	if i == nil {
		return
	}
	return i.AddedStickerFileIDs
}

// GetDuration returns value of Duration field.
func (i *InputMessageAnimation) GetDuration() (value int32) {
	if i == nil {
		return
	}
	return i.Duration
}

// GetWidth returns value of Width field.
func (i *InputMessageAnimation) GetWidth() (value int32) {
	if i == nil {
		return
	}
	return i.Width
}

// GetHeight returns value of Height field.
func (i *InputMessageAnimation) GetHeight() (value int32) {
	if i == nil {
		return
	}
	return i.Height
}

// GetCaption returns value of Caption field.
func (i *InputMessageAnimation) GetCaption() (value FormattedText) {
	if i == nil {
		return
	}
	return i.Caption
}

// GetShowCaptionAboveMedia returns value of ShowCaptionAboveMedia field.
func (i *InputMessageAnimation) GetShowCaptionAboveMedia() (value bool) {
	if i == nil {
		return
	}
	return i.ShowCaptionAboveMedia
}

// GetHasSpoiler returns value of HasSpoiler field.
func (i *InputMessageAnimation) GetHasSpoiler() (value bool) {
	if i == nil {
		return
	}
	return i.HasSpoiler
}

// InputMessageAudio represents TL type `inputMessageAudio#daa400b2`.
type InputMessageAudio struct {
	// Audio file to be sent
	Audio InputFileClass
	// Thumbnail of the cover for the album; pass null to skip thumbnail uploading
	AlbumCoverThumbnail InputThumbnail
	// Duration of the audio, in seconds; may be replaced by the server
	Duration int32
	// Title of the audio; 0-64 characters; may be replaced by the server
	Title string
	// Performer of the audio; 0-64 characters, may be replaced by the server
	Performer string
	// Audio caption; pass null to use an empty caption;
	// 0-getOption("message_caption_length_max") characters
	Caption FormattedText
}

// InputMessageAudioTypeID is TL type id of InputMessageAudio.
const InputMessageAudioTypeID = 0xdaa400b2

// construct implements constructor of InputMessageContentClass.
func (i InputMessageAudio) construct() InputMessageContentClass { return &i }

// Ensuring interfaces in compile-time for InputMessageAudio.
var (
	_ bin.Encoder     = &InputMessageAudio{}
	_ bin.Decoder     = &InputMessageAudio{}
	_ bin.BareEncoder = &InputMessageAudio{}
	_ bin.BareDecoder = &InputMessageAudio{}

	_ InputMessageContentClass = &InputMessageAudio{}
)

func (i *InputMessageAudio) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.Audio == nil) {
		return false
	}
	if !(i.AlbumCoverThumbnail.Zero()) {
		return false
	}
	if !(i.Duration == 0) {
		return false
	}
	if !(i.Title == "") {
		return false
	}
	if !(i.Performer == "") {
		return false
	}
	if !(i.Caption.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputMessageAudio) String() string {
	if i == nil {
		return "InputMessageAudio(nil)"
	}
	type Alias InputMessageAudio
	return fmt.Sprintf("InputMessageAudio%+v", Alias(*i))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputMessageAudio) TypeID() uint32 {
	return InputMessageAudioTypeID
}

// TypeName returns name of type in TL schema.
func (*InputMessageAudio) TypeName() string {
	return "inputMessageAudio"
}

// TypeInfo returns info about TL type.
func (i *InputMessageAudio) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputMessageAudio",
		ID:   InputMessageAudioTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Audio",
			SchemaName: "audio",
		},
		{
			Name:       "AlbumCoverThumbnail",
			SchemaName: "album_cover_thumbnail",
		},
		{
			Name:       "Duration",
			SchemaName: "duration",
		},
		{
			Name:       "Title",
			SchemaName: "title",
		},
		{
			Name:       "Performer",
			SchemaName: "performer",
		},
		{
			Name:       "Caption",
			SchemaName: "caption",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (i *InputMessageAudio) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageAudio#daa400b2 as nil")
	}
	b.PutID(InputMessageAudioTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputMessageAudio) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageAudio#daa400b2 as nil")
	}
	if i.Audio == nil {
		return fmt.Errorf("unable to encode inputMessageAudio#daa400b2: field audio is nil")
	}
	if err := i.Audio.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageAudio#daa400b2: field audio: %w", err)
	}
	if err := i.AlbumCoverThumbnail.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageAudio#daa400b2: field album_cover_thumbnail: %w", err)
	}
	b.PutInt32(i.Duration)
	b.PutString(i.Title)
	b.PutString(i.Performer)
	if err := i.Caption.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageAudio#daa400b2: field caption: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (i *InputMessageAudio) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageAudio#daa400b2 to nil")
	}
	if err := b.ConsumeID(InputMessageAudioTypeID); err != nil {
		return fmt.Errorf("unable to decode inputMessageAudio#daa400b2: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputMessageAudio) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageAudio#daa400b2 to nil")
	}
	{
		value, err := DecodeInputFile(b)
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageAudio#daa400b2: field audio: %w", err)
		}
		i.Audio = value
	}
	{
		if err := i.AlbumCoverThumbnail.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputMessageAudio#daa400b2: field album_cover_thumbnail: %w", err)
		}
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageAudio#daa400b2: field duration: %w", err)
		}
		i.Duration = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageAudio#daa400b2: field title: %w", err)
		}
		i.Title = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageAudio#daa400b2: field performer: %w", err)
		}
		i.Performer = value
	}
	{
		if err := i.Caption.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputMessageAudio#daa400b2: field caption: %w", err)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (i *InputMessageAudio) EncodeTDLibJSON(b tdjson.Encoder) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageAudio#daa400b2 as nil")
	}
	b.ObjStart()
	b.PutID("inputMessageAudio")
	b.Comma()
	b.FieldStart("audio")
	if i.Audio == nil {
		return fmt.Errorf("unable to encode inputMessageAudio#daa400b2: field audio is nil")
	}
	if err := i.Audio.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageAudio#daa400b2: field audio: %w", err)
	}
	b.Comma()
	b.FieldStart("album_cover_thumbnail")
	if err := i.AlbumCoverThumbnail.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageAudio#daa400b2: field album_cover_thumbnail: %w", err)
	}
	b.Comma()
	b.FieldStart("duration")
	b.PutInt32(i.Duration)
	b.Comma()
	b.FieldStart("title")
	b.PutString(i.Title)
	b.Comma()
	b.FieldStart("performer")
	b.PutString(i.Performer)
	b.Comma()
	b.FieldStart("caption")
	if err := i.Caption.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageAudio#daa400b2: field caption: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (i *InputMessageAudio) DecodeTDLibJSON(b tdjson.Decoder) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageAudio#daa400b2 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("inputMessageAudio"); err != nil {
				return fmt.Errorf("unable to decode inputMessageAudio#daa400b2: %w", err)
			}
		case "audio":
			value, err := DecodeTDLibJSONInputFile(b)
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageAudio#daa400b2: field audio: %w", err)
			}
			i.Audio = value
		case "album_cover_thumbnail":
			if err := i.AlbumCoverThumbnail.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode inputMessageAudio#daa400b2: field album_cover_thumbnail: %w", err)
			}
		case "duration":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageAudio#daa400b2: field duration: %w", err)
			}
			i.Duration = value
		case "title":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageAudio#daa400b2: field title: %w", err)
			}
			i.Title = value
		case "performer":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageAudio#daa400b2: field performer: %w", err)
			}
			i.Performer = value
		case "caption":
			if err := i.Caption.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode inputMessageAudio#daa400b2: field caption: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetAudio returns value of Audio field.
func (i *InputMessageAudio) GetAudio() (value InputFileClass) {
	if i == nil {
		return
	}
	return i.Audio
}

// GetAlbumCoverThumbnail returns value of AlbumCoverThumbnail field.
func (i *InputMessageAudio) GetAlbumCoverThumbnail() (value InputThumbnail) {
	if i == nil {
		return
	}
	return i.AlbumCoverThumbnail
}

// GetDuration returns value of Duration field.
func (i *InputMessageAudio) GetDuration() (value int32) {
	if i == nil {
		return
	}
	return i.Duration
}

// GetTitle returns value of Title field.
func (i *InputMessageAudio) GetTitle() (value string) {
	if i == nil {
		return
	}
	return i.Title
}

// GetPerformer returns value of Performer field.
func (i *InputMessageAudio) GetPerformer() (value string) {
	if i == nil {
		return
	}
	return i.Performer
}

// GetCaption returns value of Caption field.
func (i *InputMessageAudio) GetCaption() (value FormattedText) {
	if i == nil {
		return
	}
	return i.Caption
}

// InputMessageDocument represents TL type `inputMessageDocument#615b72b9`.
type InputMessageDocument struct {
	// Document to be sent
	Document InputFileClass
	// Document thumbnail; pass null to skip thumbnail uploading
	Thumbnail InputThumbnail
	// Pass true to disable automatic file type detection and send the document as a file.
	// Always true for files sent to secret chats
	DisableContentTypeDetection bool
	// Document caption; pass null to use an empty caption;
	// 0-getOption("message_caption_length_max") characters
	Caption FormattedText
}

// InputMessageDocumentTypeID is TL type id of InputMessageDocument.
const InputMessageDocumentTypeID = 0x615b72b9

// construct implements constructor of InputMessageContentClass.
func (i InputMessageDocument) construct() InputMessageContentClass { return &i }

// Ensuring interfaces in compile-time for InputMessageDocument.
var (
	_ bin.Encoder     = &InputMessageDocument{}
	_ bin.Decoder     = &InputMessageDocument{}
	_ bin.BareEncoder = &InputMessageDocument{}
	_ bin.BareDecoder = &InputMessageDocument{}

	_ InputMessageContentClass = &InputMessageDocument{}
)

func (i *InputMessageDocument) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.Document == nil) {
		return false
	}
	if !(i.Thumbnail.Zero()) {
		return false
	}
	if !(i.DisableContentTypeDetection == false) {
		return false
	}
	if !(i.Caption.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputMessageDocument) String() string {
	if i == nil {
		return "InputMessageDocument(nil)"
	}
	type Alias InputMessageDocument
	return fmt.Sprintf("InputMessageDocument%+v", Alias(*i))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputMessageDocument) TypeID() uint32 {
	return InputMessageDocumentTypeID
}

// TypeName returns name of type in TL schema.
func (*InputMessageDocument) TypeName() string {
	return "inputMessageDocument"
}

// TypeInfo returns info about TL type.
func (i *InputMessageDocument) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputMessageDocument",
		ID:   InputMessageDocumentTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Document",
			SchemaName: "document",
		},
		{
			Name:       "Thumbnail",
			SchemaName: "thumbnail",
		},
		{
			Name:       "DisableContentTypeDetection",
			SchemaName: "disable_content_type_detection",
		},
		{
			Name:       "Caption",
			SchemaName: "caption",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (i *InputMessageDocument) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageDocument#615b72b9 as nil")
	}
	b.PutID(InputMessageDocumentTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputMessageDocument) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageDocument#615b72b9 as nil")
	}
	if i.Document == nil {
		return fmt.Errorf("unable to encode inputMessageDocument#615b72b9: field document is nil")
	}
	if err := i.Document.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageDocument#615b72b9: field document: %w", err)
	}
	if err := i.Thumbnail.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageDocument#615b72b9: field thumbnail: %w", err)
	}
	b.PutBool(i.DisableContentTypeDetection)
	if err := i.Caption.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageDocument#615b72b9: field caption: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (i *InputMessageDocument) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageDocument#615b72b9 to nil")
	}
	if err := b.ConsumeID(InputMessageDocumentTypeID); err != nil {
		return fmt.Errorf("unable to decode inputMessageDocument#615b72b9: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputMessageDocument) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageDocument#615b72b9 to nil")
	}
	{
		value, err := DecodeInputFile(b)
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageDocument#615b72b9: field document: %w", err)
		}
		i.Document = value
	}
	{
		if err := i.Thumbnail.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputMessageDocument#615b72b9: field thumbnail: %w", err)
		}
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageDocument#615b72b9: field disable_content_type_detection: %w", err)
		}
		i.DisableContentTypeDetection = value
	}
	{
		if err := i.Caption.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputMessageDocument#615b72b9: field caption: %w", err)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (i *InputMessageDocument) EncodeTDLibJSON(b tdjson.Encoder) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageDocument#615b72b9 as nil")
	}
	b.ObjStart()
	b.PutID("inputMessageDocument")
	b.Comma()
	b.FieldStart("document")
	if i.Document == nil {
		return fmt.Errorf("unable to encode inputMessageDocument#615b72b9: field document is nil")
	}
	if err := i.Document.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageDocument#615b72b9: field document: %w", err)
	}
	b.Comma()
	b.FieldStart("thumbnail")
	if err := i.Thumbnail.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageDocument#615b72b9: field thumbnail: %w", err)
	}
	b.Comma()
	b.FieldStart("disable_content_type_detection")
	b.PutBool(i.DisableContentTypeDetection)
	b.Comma()
	b.FieldStart("caption")
	if err := i.Caption.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageDocument#615b72b9: field caption: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (i *InputMessageDocument) DecodeTDLibJSON(b tdjson.Decoder) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageDocument#615b72b9 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("inputMessageDocument"); err != nil {
				return fmt.Errorf("unable to decode inputMessageDocument#615b72b9: %w", err)
			}
		case "document":
			value, err := DecodeTDLibJSONInputFile(b)
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageDocument#615b72b9: field document: %w", err)
			}
			i.Document = value
		case "thumbnail":
			if err := i.Thumbnail.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode inputMessageDocument#615b72b9: field thumbnail: %w", err)
			}
		case "disable_content_type_detection":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageDocument#615b72b9: field disable_content_type_detection: %w", err)
			}
			i.DisableContentTypeDetection = value
		case "caption":
			if err := i.Caption.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode inputMessageDocument#615b72b9: field caption: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetDocument returns value of Document field.
func (i *InputMessageDocument) GetDocument() (value InputFileClass) {
	if i == nil {
		return
	}
	return i.Document
}

// GetThumbnail returns value of Thumbnail field.
func (i *InputMessageDocument) GetThumbnail() (value InputThumbnail) {
	if i == nil {
		return
	}
	return i.Thumbnail
}

// GetDisableContentTypeDetection returns value of DisableContentTypeDetection field.
func (i *InputMessageDocument) GetDisableContentTypeDetection() (value bool) {
	if i == nil {
		return
	}
	return i.DisableContentTypeDetection
}

// GetCaption returns value of Caption field.
func (i *InputMessageDocument) GetCaption() (value FormattedText) {
	if i == nil {
		return
	}
	return i.Caption
}

// InputMessagePaidMedia represents TL type `inputMessagePaidMedia#370c4490`.
type InputMessagePaidMedia struct {
	// The number of Telegram Stars that must be paid to see the media;
	// 1-getOption("paid_media_message_star_count_max")
	StarCount int64
	// The content of the paid media
	PaidMedia []InputPaidMedia
	// Message caption; pass null to use an empty caption;
	// 0-getOption("message_caption_length_max") characters
	Caption FormattedText
	// True, if the caption must be shown above the media; otherwise, the caption must be
	// shown below the media; not supported in secret chats
	ShowCaptionAboveMedia bool
	// Bot-provided data for the paid media; bots only
	Payload string
}

// InputMessagePaidMediaTypeID is TL type id of InputMessagePaidMedia.
const InputMessagePaidMediaTypeID = 0x370c4490

// construct implements constructor of InputMessageContentClass.
func (i InputMessagePaidMedia) construct() InputMessageContentClass { return &i }

// Ensuring interfaces in compile-time for InputMessagePaidMedia.
var (
	_ bin.Encoder     = &InputMessagePaidMedia{}
	_ bin.Decoder     = &InputMessagePaidMedia{}
	_ bin.BareEncoder = &InputMessagePaidMedia{}
	_ bin.BareDecoder = &InputMessagePaidMedia{}

	_ InputMessageContentClass = &InputMessagePaidMedia{}
)

func (i *InputMessagePaidMedia) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.StarCount == 0) {
		return false
	}
	if !(i.PaidMedia == nil) {
		return false
	}
	if !(i.Caption.Zero()) {
		return false
	}
	if !(i.ShowCaptionAboveMedia == false) {
		return false
	}
	if !(i.Payload == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputMessagePaidMedia) String() string {
	if i == nil {
		return "InputMessagePaidMedia(nil)"
	}
	type Alias InputMessagePaidMedia
	return fmt.Sprintf("InputMessagePaidMedia%+v", Alias(*i))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputMessagePaidMedia) TypeID() uint32 {
	return InputMessagePaidMediaTypeID
}

// TypeName returns name of type in TL schema.
func (*InputMessagePaidMedia) TypeName() string {
	return "inputMessagePaidMedia"
}

// TypeInfo returns info about TL type.
func (i *InputMessagePaidMedia) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputMessagePaidMedia",
		ID:   InputMessagePaidMediaTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "StarCount",
			SchemaName: "star_count",
		},
		{
			Name:       "PaidMedia",
			SchemaName: "paid_media",
		},
		{
			Name:       "Caption",
			SchemaName: "caption",
		},
		{
			Name:       "ShowCaptionAboveMedia",
			SchemaName: "show_caption_above_media",
		},
		{
			Name:       "Payload",
			SchemaName: "payload",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (i *InputMessagePaidMedia) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessagePaidMedia#370c4490 as nil")
	}
	b.PutID(InputMessagePaidMediaTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputMessagePaidMedia) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessagePaidMedia#370c4490 as nil")
	}
	b.PutInt53(i.StarCount)
	b.PutInt(len(i.PaidMedia))
	for idx, v := range i.PaidMedia {
		if err := v.EncodeBare(b); err != nil {
			return fmt.Errorf("unable to encode bare inputMessagePaidMedia#370c4490: field paid_media element with index %d: %w", idx, err)
		}
	}
	if err := i.Caption.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMessagePaidMedia#370c4490: field caption: %w", err)
	}
	b.PutBool(i.ShowCaptionAboveMedia)
	b.PutString(i.Payload)
	return nil
}

// Decode implements bin.Decoder.
func (i *InputMessagePaidMedia) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessagePaidMedia#370c4490 to nil")
	}
	if err := b.ConsumeID(InputMessagePaidMediaTypeID); err != nil {
		return fmt.Errorf("unable to decode inputMessagePaidMedia#370c4490: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputMessagePaidMedia) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessagePaidMedia#370c4490 to nil")
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessagePaidMedia#370c4490: field star_count: %w", err)
		}
		i.StarCount = value
	}
	{
		headerLen, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessagePaidMedia#370c4490: field paid_media: %w", err)
		}

		if headerLen > 0 {
			i.PaidMedia = make([]InputPaidMedia, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			var value InputPaidMedia
			if err := value.DecodeBare(b); err != nil {
				return fmt.Errorf("unable to decode bare inputMessagePaidMedia#370c4490: field paid_media: %w", err)
			}
			i.PaidMedia = append(i.PaidMedia, value)
		}
	}
	{
		if err := i.Caption.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputMessagePaidMedia#370c4490: field caption: %w", err)
		}
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessagePaidMedia#370c4490: field show_caption_above_media: %w", err)
		}
		i.ShowCaptionAboveMedia = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessagePaidMedia#370c4490: field payload: %w", err)
		}
		i.Payload = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (i *InputMessagePaidMedia) EncodeTDLibJSON(b tdjson.Encoder) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessagePaidMedia#370c4490 as nil")
	}
	b.ObjStart()
	b.PutID("inputMessagePaidMedia")
	b.Comma()
	b.FieldStart("star_count")
	b.PutInt53(i.StarCount)
	b.Comma()
	b.FieldStart("paid_media")
	b.ArrStart()
	for idx, v := range i.PaidMedia {
		if err := v.EncodeTDLibJSON(b); err != nil {
			return fmt.Errorf("unable to encode inputMessagePaidMedia#370c4490: field paid_media element with index %d: %w", idx, err)
		}
		b.Comma()
	}
	b.StripComma()
	b.ArrEnd()
	b.Comma()
	b.FieldStart("caption")
	if err := i.Caption.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode inputMessagePaidMedia#370c4490: field caption: %w", err)
	}
	b.Comma()
	b.FieldStart("show_caption_above_media")
	b.PutBool(i.ShowCaptionAboveMedia)
	b.Comma()
	b.FieldStart("payload")
	b.PutString(i.Payload)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (i *InputMessagePaidMedia) DecodeTDLibJSON(b tdjson.Decoder) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessagePaidMedia#370c4490 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("inputMessagePaidMedia"); err != nil {
				return fmt.Errorf("unable to decode inputMessagePaidMedia#370c4490: %w", err)
			}
		case "star_count":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessagePaidMedia#370c4490: field star_count: %w", err)
			}
			i.StarCount = value
		case "paid_media":
			if err := b.Arr(func(b tdjson.Decoder) error {
				var value InputPaidMedia
				if err := value.DecodeTDLibJSON(b); err != nil {
					return fmt.Errorf("unable to decode inputMessagePaidMedia#370c4490: field paid_media: %w", err)
				}
				i.PaidMedia = append(i.PaidMedia, value)
				return nil
			}); err != nil {
				return fmt.Errorf("unable to decode inputMessagePaidMedia#370c4490: field paid_media: %w", err)
			}
		case "caption":
			if err := i.Caption.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode inputMessagePaidMedia#370c4490: field caption: %w", err)
			}
		case "show_caption_above_media":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessagePaidMedia#370c4490: field show_caption_above_media: %w", err)
			}
			i.ShowCaptionAboveMedia = value
		case "payload":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessagePaidMedia#370c4490: field payload: %w", err)
			}
			i.Payload = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetStarCount returns value of StarCount field.
func (i *InputMessagePaidMedia) GetStarCount() (value int64) {
	if i == nil {
		return
	}
	return i.StarCount
}

// GetPaidMedia returns value of PaidMedia field.
func (i *InputMessagePaidMedia) GetPaidMedia() (value []InputPaidMedia) {
	if i == nil {
		return
	}
	return i.PaidMedia
}

// GetCaption returns value of Caption field.
func (i *InputMessagePaidMedia) GetCaption() (value FormattedText) {
	if i == nil {
		return
	}
	return i.Caption
}

// GetShowCaptionAboveMedia returns value of ShowCaptionAboveMedia field.
func (i *InputMessagePaidMedia) GetShowCaptionAboveMedia() (value bool) {
	if i == nil {
		return
	}
	return i.ShowCaptionAboveMedia
}

// GetPayload returns value of Payload field.
func (i *InputMessagePaidMedia) GetPayload() (value string) {
	if i == nil {
		return
	}
	return i.Payload
}

// InputMessagePhoto represents TL type `inputMessagePhoto#bc78dbcc`.
type InputMessagePhoto struct {
	// Photo to send. The photo must be at most 10 MB in size. The photo's width and height
	// must not exceed 10000 in total. Width and height ratio must be at most 20
	Photo InputFileClass
	// Photo thumbnail to be sent; pass null to skip thumbnail uploading. The thumbnail is
	// sent to the other party only in secret chats
	Thumbnail InputThumbnail
	// File identifiers of the stickers added to the photo, if applicable
	AddedStickerFileIDs []int32
	// Photo width
	Width int32
	// Photo height
	Height int32
	// Photo caption; pass null to use an empty caption;
	// 0-getOption("message_caption_length_max") characters
	Caption FormattedText
	// True, if the caption must be shown above the photo; otherwise, the caption must be
	// shown below the photo; not supported in secret chats
	ShowCaptionAboveMedia bool
	// Photo self-destruct type; pass null if none; private chats only
	SelfDestructType MessageSelfDestructTypeClass
	// True, if the photo preview must be covered by a spoiler animation; not supported in
	// secret chats
	HasSpoiler bool
}

// InputMessagePhotoTypeID is TL type id of InputMessagePhoto.
const InputMessagePhotoTypeID = 0xbc78dbcc

// construct implements constructor of InputMessageContentClass.
func (i InputMessagePhoto) construct() InputMessageContentClass { return &i }

// Ensuring interfaces in compile-time for InputMessagePhoto.
var (
	_ bin.Encoder     = &InputMessagePhoto{}
	_ bin.Decoder     = &InputMessagePhoto{}
	_ bin.BareEncoder = &InputMessagePhoto{}
	_ bin.BareDecoder = &InputMessagePhoto{}

	_ InputMessageContentClass = &InputMessagePhoto{}
)

func (i *InputMessagePhoto) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.Photo == nil) {
		return false
	}
	if !(i.Thumbnail.Zero()) {
		return false
	}
	if !(i.AddedStickerFileIDs == nil) {
		return false
	}
	if !(i.Width == 0) {
		return false
	}
	if !(i.Height == 0) {
		return false
	}
	if !(i.Caption.Zero()) {
		return false
	}
	if !(i.ShowCaptionAboveMedia == false) {
		return false
	}
	if !(i.SelfDestructType == nil) {
		return false
	}
	if !(i.HasSpoiler == false) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputMessagePhoto) String() string {
	if i == nil {
		return "InputMessagePhoto(nil)"
	}
	type Alias InputMessagePhoto
	return fmt.Sprintf("InputMessagePhoto%+v", Alias(*i))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputMessagePhoto) TypeID() uint32 {
	return InputMessagePhotoTypeID
}

// TypeName returns name of type in TL schema.
func (*InputMessagePhoto) TypeName() string {
	return "inputMessagePhoto"
}

// TypeInfo returns info about TL type.
func (i *InputMessagePhoto) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputMessagePhoto",
		ID:   InputMessagePhotoTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Photo",
			SchemaName: "photo",
		},
		{
			Name:       "Thumbnail",
			SchemaName: "thumbnail",
		},
		{
			Name:       "AddedStickerFileIDs",
			SchemaName: "added_sticker_file_ids",
		},
		{
			Name:       "Width",
			SchemaName: "width",
		},
		{
			Name:       "Height",
			SchemaName: "height",
		},
		{
			Name:       "Caption",
			SchemaName: "caption",
		},
		{
			Name:       "ShowCaptionAboveMedia",
			SchemaName: "show_caption_above_media",
		},
		{
			Name:       "SelfDestructType",
			SchemaName: "self_destruct_type",
		},
		{
			Name:       "HasSpoiler",
			SchemaName: "has_spoiler",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (i *InputMessagePhoto) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessagePhoto#bc78dbcc as nil")
	}
	b.PutID(InputMessagePhotoTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputMessagePhoto) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessagePhoto#bc78dbcc as nil")
	}
	if i.Photo == nil {
		return fmt.Errorf("unable to encode inputMessagePhoto#bc78dbcc: field photo is nil")
	}
	if err := i.Photo.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMessagePhoto#bc78dbcc: field photo: %w", err)
	}
	if err := i.Thumbnail.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMessagePhoto#bc78dbcc: field thumbnail: %w", err)
	}
	b.PutInt(len(i.AddedStickerFileIDs))
	for _, v := range i.AddedStickerFileIDs {
		b.PutInt32(v)
	}
	b.PutInt32(i.Width)
	b.PutInt32(i.Height)
	if err := i.Caption.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMessagePhoto#bc78dbcc: field caption: %w", err)
	}
	b.PutBool(i.ShowCaptionAboveMedia)
	if i.SelfDestructType == nil {
		return fmt.Errorf("unable to encode inputMessagePhoto#bc78dbcc: field self_destruct_type is nil")
	}
	if err := i.SelfDestructType.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMessagePhoto#bc78dbcc: field self_destruct_type: %w", err)
	}
	b.PutBool(i.HasSpoiler)
	return nil
}

// Decode implements bin.Decoder.
func (i *InputMessagePhoto) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessagePhoto#bc78dbcc to nil")
	}
	if err := b.ConsumeID(InputMessagePhotoTypeID); err != nil {
		return fmt.Errorf("unable to decode inputMessagePhoto#bc78dbcc: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputMessagePhoto) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessagePhoto#bc78dbcc to nil")
	}
	{
		value, err := DecodeInputFile(b)
		if err != nil {
			return fmt.Errorf("unable to decode inputMessagePhoto#bc78dbcc: field photo: %w", err)
		}
		i.Photo = value
	}
	{
		if err := i.Thumbnail.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputMessagePhoto#bc78dbcc: field thumbnail: %w", err)
		}
	}
	{
		headerLen, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessagePhoto#bc78dbcc: field added_sticker_file_ids: %w", err)
		}

		if headerLen > 0 {
			i.AddedStickerFileIDs = make([]int32, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessagePhoto#bc78dbcc: field added_sticker_file_ids: %w", err)
			}
			i.AddedStickerFileIDs = append(i.AddedStickerFileIDs, value)
		}
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessagePhoto#bc78dbcc: field width: %w", err)
		}
		i.Width = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessagePhoto#bc78dbcc: field height: %w", err)
		}
		i.Height = value
	}
	{
		if err := i.Caption.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputMessagePhoto#bc78dbcc: field caption: %w", err)
		}
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessagePhoto#bc78dbcc: field show_caption_above_media: %w", err)
		}
		i.ShowCaptionAboveMedia = value
	}
	{
		value, err := DecodeMessageSelfDestructType(b)
		if err != nil {
			return fmt.Errorf("unable to decode inputMessagePhoto#bc78dbcc: field self_destruct_type: %w", err)
		}
		i.SelfDestructType = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessagePhoto#bc78dbcc: field has_spoiler: %w", err)
		}
		i.HasSpoiler = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (i *InputMessagePhoto) EncodeTDLibJSON(b tdjson.Encoder) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessagePhoto#bc78dbcc as nil")
	}
	b.ObjStart()
	b.PutID("inputMessagePhoto")
	b.Comma()
	b.FieldStart("photo")
	if i.Photo == nil {
		return fmt.Errorf("unable to encode inputMessagePhoto#bc78dbcc: field photo is nil")
	}
	if err := i.Photo.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode inputMessagePhoto#bc78dbcc: field photo: %w", err)
	}
	b.Comma()
	b.FieldStart("thumbnail")
	if err := i.Thumbnail.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode inputMessagePhoto#bc78dbcc: field thumbnail: %w", err)
	}
	b.Comma()
	b.FieldStart("added_sticker_file_ids")
	b.ArrStart()
	for _, v := range i.AddedStickerFileIDs {
		b.PutInt32(v)
		b.Comma()
	}
	b.StripComma()
	b.ArrEnd()
	b.Comma()
	b.FieldStart("width")
	b.PutInt32(i.Width)
	b.Comma()
	b.FieldStart("height")
	b.PutInt32(i.Height)
	b.Comma()
	b.FieldStart("caption")
	if err := i.Caption.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode inputMessagePhoto#bc78dbcc: field caption: %w", err)
	}
	b.Comma()
	b.FieldStart("show_caption_above_media")
	b.PutBool(i.ShowCaptionAboveMedia)
	b.Comma()
	b.FieldStart("self_destruct_type")
	if i.SelfDestructType == nil {
		return fmt.Errorf("unable to encode inputMessagePhoto#bc78dbcc: field self_destruct_type is nil")
	}
	if err := i.SelfDestructType.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode inputMessagePhoto#bc78dbcc: field self_destruct_type: %w", err)
	}
	b.Comma()
	b.FieldStart("has_spoiler")
	b.PutBool(i.HasSpoiler)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (i *InputMessagePhoto) DecodeTDLibJSON(b tdjson.Decoder) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessagePhoto#bc78dbcc to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("inputMessagePhoto"); err != nil {
				return fmt.Errorf("unable to decode inputMessagePhoto#bc78dbcc: %w", err)
			}
		case "photo":
			value, err := DecodeTDLibJSONInputFile(b)
			if err != nil {
				return fmt.Errorf("unable to decode inputMessagePhoto#bc78dbcc: field photo: %w", err)
			}
			i.Photo = value
		case "thumbnail":
			if err := i.Thumbnail.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode inputMessagePhoto#bc78dbcc: field thumbnail: %w", err)
			}
		case "added_sticker_file_ids":
			if err := b.Arr(func(b tdjson.Decoder) error {
				value, err := b.Int32()
				if err != nil {
					return fmt.Errorf("unable to decode inputMessagePhoto#bc78dbcc: field added_sticker_file_ids: %w", err)
				}
				i.AddedStickerFileIDs = append(i.AddedStickerFileIDs, value)
				return nil
			}); err != nil {
				return fmt.Errorf("unable to decode inputMessagePhoto#bc78dbcc: field added_sticker_file_ids: %w", err)
			}
		case "width":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessagePhoto#bc78dbcc: field width: %w", err)
			}
			i.Width = value
		case "height":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessagePhoto#bc78dbcc: field height: %w", err)
			}
			i.Height = value
		case "caption":
			if err := i.Caption.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode inputMessagePhoto#bc78dbcc: field caption: %w", err)
			}
		case "show_caption_above_media":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessagePhoto#bc78dbcc: field show_caption_above_media: %w", err)
			}
			i.ShowCaptionAboveMedia = value
		case "self_destruct_type":
			value, err := DecodeTDLibJSONMessageSelfDestructType(b)
			if err != nil {
				return fmt.Errorf("unable to decode inputMessagePhoto#bc78dbcc: field self_destruct_type: %w", err)
			}
			i.SelfDestructType = value
		case "has_spoiler":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessagePhoto#bc78dbcc: field has_spoiler: %w", err)
			}
			i.HasSpoiler = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetPhoto returns value of Photo field.
func (i *InputMessagePhoto) GetPhoto() (value InputFileClass) {
	if i == nil {
		return
	}
	return i.Photo
}

// GetThumbnail returns value of Thumbnail field.
func (i *InputMessagePhoto) GetThumbnail() (value InputThumbnail) {
	if i == nil {
		return
	}
	return i.Thumbnail
}

// GetAddedStickerFileIDs returns value of AddedStickerFileIDs field.
func (i *InputMessagePhoto) GetAddedStickerFileIDs() (value []int32) {
	if i == nil {
		return
	}
	return i.AddedStickerFileIDs
}

// GetWidth returns value of Width field.
func (i *InputMessagePhoto) GetWidth() (value int32) {
	if i == nil {
		return
	}
	return i.Width
}

// GetHeight returns value of Height field.
func (i *InputMessagePhoto) GetHeight() (value int32) {
	if i == nil {
		return
	}
	return i.Height
}

// GetCaption returns value of Caption field.
func (i *InputMessagePhoto) GetCaption() (value FormattedText) {
	if i == nil {
		return
	}
	return i.Caption
}

// GetShowCaptionAboveMedia returns value of ShowCaptionAboveMedia field.
func (i *InputMessagePhoto) GetShowCaptionAboveMedia() (value bool) {
	if i == nil {
		return
	}
	return i.ShowCaptionAboveMedia
}

// GetSelfDestructType returns value of SelfDestructType field.
func (i *InputMessagePhoto) GetSelfDestructType() (value MessageSelfDestructTypeClass) {
	if i == nil {
		return
	}
	return i.SelfDestructType
}

// GetHasSpoiler returns value of HasSpoiler field.
func (i *InputMessagePhoto) GetHasSpoiler() (value bool) {
	if i == nil {
		return
	}
	return i.HasSpoiler
}

// InputMessageSticker represents TL type `inputMessageSticker#3ff1b6f9`.
type InputMessageSticker struct {
	// Sticker to be sent
	Sticker InputFileClass
	// Sticker thumbnail; pass null to skip thumbnail uploading
	Thumbnail InputThumbnail
	// Sticker width
	Width int32
	// Sticker height
	Height int32
	// Emoji used to choose the sticker
	Emoji string
}

// InputMessageStickerTypeID is TL type id of InputMessageSticker.
const InputMessageStickerTypeID = 0x3ff1b6f9

// construct implements constructor of InputMessageContentClass.
func (i InputMessageSticker) construct() InputMessageContentClass { return &i }

// Ensuring interfaces in compile-time for InputMessageSticker.
var (
	_ bin.Encoder     = &InputMessageSticker{}
	_ bin.Decoder     = &InputMessageSticker{}
	_ bin.BareEncoder = &InputMessageSticker{}
	_ bin.BareDecoder = &InputMessageSticker{}

	_ InputMessageContentClass = &InputMessageSticker{}
)

func (i *InputMessageSticker) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.Sticker == nil) {
		return false
	}
	if !(i.Thumbnail.Zero()) {
		return false
	}
	if !(i.Width == 0) {
		return false
	}
	if !(i.Height == 0) {
		return false
	}
	if !(i.Emoji == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputMessageSticker) String() string {
	if i == nil {
		return "InputMessageSticker(nil)"
	}
	type Alias InputMessageSticker
	return fmt.Sprintf("InputMessageSticker%+v", Alias(*i))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputMessageSticker) TypeID() uint32 {
	return InputMessageStickerTypeID
}

// TypeName returns name of type in TL schema.
func (*InputMessageSticker) TypeName() string {
	return "inputMessageSticker"
}

// TypeInfo returns info about TL type.
func (i *InputMessageSticker) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputMessageSticker",
		ID:   InputMessageStickerTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Sticker",
			SchemaName: "sticker",
		},
		{
			Name:       "Thumbnail",
			SchemaName: "thumbnail",
		},
		{
			Name:       "Width",
			SchemaName: "width",
		},
		{
			Name:       "Height",
			SchemaName: "height",
		},
		{
			Name:       "Emoji",
			SchemaName: "emoji",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (i *InputMessageSticker) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageSticker#3ff1b6f9 as nil")
	}
	b.PutID(InputMessageStickerTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputMessageSticker) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageSticker#3ff1b6f9 as nil")
	}
	if i.Sticker == nil {
		return fmt.Errorf("unable to encode inputMessageSticker#3ff1b6f9: field sticker is nil")
	}
	if err := i.Sticker.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageSticker#3ff1b6f9: field sticker: %w", err)
	}
	if err := i.Thumbnail.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageSticker#3ff1b6f9: field thumbnail: %w", err)
	}
	b.PutInt32(i.Width)
	b.PutInt32(i.Height)
	b.PutString(i.Emoji)
	return nil
}

// Decode implements bin.Decoder.
func (i *InputMessageSticker) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageSticker#3ff1b6f9 to nil")
	}
	if err := b.ConsumeID(InputMessageStickerTypeID); err != nil {
		return fmt.Errorf("unable to decode inputMessageSticker#3ff1b6f9: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputMessageSticker) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageSticker#3ff1b6f9 to nil")
	}
	{
		value, err := DecodeInputFile(b)
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageSticker#3ff1b6f9: field sticker: %w", err)
		}
		i.Sticker = value
	}
	{
		if err := i.Thumbnail.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputMessageSticker#3ff1b6f9: field thumbnail: %w", err)
		}
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageSticker#3ff1b6f9: field width: %w", err)
		}
		i.Width = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageSticker#3ff1b6f9: field height: %w", err)
		}
		i.Height = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageSticker#3ff1b6f9: field emoji: %w", err)
		}
		i.Emoji = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (i *InputMessageSticker) EncodeTDLibJSON(b tdjson.Encoder) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageSticker#3ff1b6f9 as nil")
	}
	b.ObjStart()
	b.PutID("inputMessageSticker")
	b.Comma()
	b.FieldStart("sticker")
	if i.Sticker == nil {
		return fmt.Errorf("unable to encode inputMessageSticker#3ff1b6f9: field sticker is nil")
	}
	if err := i.Sticker.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageSticker#3ff1b6f9: field sticker: %w", err)
	}
	b.Comma()
	b.FieldStart("thumbnail")
	if err := i.Thumbnail.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageSticker#3ff1b6f9: field thumbnail: %w", err)
	}
	b.Comma()
	b.FieldStart("width")
	b.PutInt32(i.Width)
	b.Comma()
	b.FieldStart("height")
	b.PutInt32(i.Height)
	b.Comma()
	b.FieldStart("emoji")
	b.PutString(i.Emoji)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (i *InputMessageSticker) DecodeTDLibJSON(b tdjson.Decoder) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageSticker#3ff1b6f9 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("inputMessageSticker"); err != nil {
				return fmt.Errorf("unable to decode inputMessageSticker#3ff1b6f9: %w", err)
			}
		case "sticker":
			value, err := DecodeTDLibJSONInputFile(b)
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageSticker#3ff1b6f9: field sticker: %w", err)
			}
			i.Sticker = value
		case "thumbnail":
			if err := i.Thumbnail.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode inputMessageSticker#3ff1b6f9: field thumbnail: %w", err)
			}
		case "width":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageSticker#3ff1b6f9: field width: %w", err)
			}
			i.Width = value
		case "height":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageSticker#3ff1b6f9: field height: %w", err)
			}
			i.Height = value
		case "emoji":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageSticker#3ff1b6f9: field emoji: %w", err)
			}
			i.Emoji = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetSticker returns value of Sticker field.
func (i *InputMessageSticker) GetSticker() (value InputFileClass) {
	if i == nil {
		return
	}
	return i.Sticker
}

// GetThumbnail returns value of Thumbnail field.
func (i *InputMessageSticker) GetThumbnail() (value InputThumbnail) {
	if i == nil {
		return
	}
	return i.Thumbnail
}

// GetWidth returns value of Width field.
func (i *InputMessageSticker) GetWidth() (value int32) {
	if i == nil {
		return
	}
	return i.Width
}

// GetHeight returns value of Height field.
func (i *InputMessageSticker) GetHeight() (value int32) {
	if i == nil {
		return
	}
	return i.Height
}

// GetEmoji returns value of Emoji field.
func (i *InputMessageSticker) GetEmoji() (value string) {
	if i == nil {
		return
	}
	return i.Emoji
}

// InputMessageVideo represents TL type `inputMessageVideo#74f09b52`.
type InputMessageVideo struct {
	// Video to be sent. The video is expected to be re-encoded to MPEG4 format with H.264
	// codec by the sender
	Video InputFileClass
	// Video thumbnail; pass null to skip thumbnail uploading
	Thumbnail InputThumbnail
	// Cover of the video; pass null to skip cover uploading; not supported in secret chats
	// and for self-destructing messages
	Cover InputFileClass
	// Timestamp from which the video playing must start, in seconds
	StartTimestamp int32
	// File identifiers of the stickers added to the video, if applicable
	AddedStickerFileIDs []int32
	// Duration of the video, in seconds
	Duration int32
	// Video width
	Width int32
	// Video height
	Height int32
	// True, if the video is expected to be streamed
	SupportsStreaming bool
	// Video caption; pass null to use an empty caption;
	// 0-getOption("message_caption_length_max") characters
	Caption FormattedText
	// True, if the caption must be shown above the video; otherwise, the caption must be
	// shown below the video; not supported in secret chats
	ShowCaptionAboveMedia bool
	// Video self-destruct type; pass null if none; private chats only
	SelfDestructType MessageSelfDestructTypeClass
	// True, if the video preview must be covered by a spoiler animation; not supported in
	// secret chats
	HasSpoiler bool
}

// InputMessageVideoTypeID is TL type id of InputMessageVideo.
const InputMessageVideoTypeID = 0x74f09b52

// construct implements constructor of InputMessageContentClass.
func (i InputMessageVideo) construct() InputMessageContentClass { return &i }

// Ensuring interfaces in compile-time for InputMessageVideo.
var (
	_ bin.Encoder     = &InputMessageVideo{}
	_ bin.Decoder     = &InputMessageVideo{}
	_ bin.BareEncoder = &InputMessageVideo{}
	_ bin.BareDecoder = &InputMessageVideo{}

	_ InputMessageContentClass = &InputMessageVideo{}
)

func (i *InputMessageVideo) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.Video == nil) {
		return false
	}
	if !(i.Thumbnail.Zero()) {
		return false
	}
	if !(i.Cover == nil) {
		return false
	}
	if !(i.StartTimestamp == 0) {
		return false
	}
	if !(i.AddedStickerFileIDs == nil) {
		return false
	}
	if !(i.Duration == 0) {
		return false
	}
	if !(i.Width == 0) {
		return false
	}
	if !(i.Height == 0) {
		return false
	}
	if !(i.SupportsStreaming == false) {
		return false
	}
	if !(i.Caption.Zero()) {
		return false
	}
	if !(i.ShowCaptionAboveMedia == false) {
		return false
	}
	if !(i.SelfDestructType == nil) {
		return false
	}
	if !(i.HasSpoiler == false) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputMessageVideo) String() string {
	if i == nil {
		return "InputMessageVideo(nil)"
	}
	type Alias InputMessageVideo
	return fmt.Sprintf("InputMessageVideo%+v", Alias(*i))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputMessageVideo) TypeID() uint32 {
	return InputMessageVideoTypeID
}

// TypeName returns name of type in TL schema.
func (*InputMessageVideo) TypeName() string {
	return "inputMessageVideo"
}

// TypeInfo returns info about TL type.
func (i *InputMessageVideo) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputMessageVideo",
		ID:   InputMessageVideoTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Video",
			SchemaName: "video",
		},
		{
			Name:       "Thumbnail",
			SchemaName: "thumbnail",
		},
		{
			Name:       "Cover",
			SchemaName: "cover",
		},
		{
			Name:       "StartTimestamp",
			SchemaName: "start_timestamp",
		},
		{
			Name:       "AddedStickerFileIDs",
			SchemaName: "added_sticker_file_ids",
		},
		{
			Name:       "Duration",
			SchemaName: "duration",
		},
		{
			Name:       "Width",
			SchemaName: "width",
		},
		{
			Name:       "Height",
			SchemaName: "height",
		},
		{
			Name:       "SupportsStreaming",
			SchemaName: "supports_streaming",
		},
		{
			Name:       "Caption",
			SchemaName: "caption",
		},
		{
			Name:       "ShowCaptionAboveMedia",
			SchemaName: "show_caption_above_media",
		},
		{
			Name:       "SelfDestructType",
			SchemaName: "self_destruct_type",
		},
		{
			Name:       "HasSpoiler",
			SchemaName: "has_spoiler",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (i *InputMessageVideo) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageVideo#74f09b52 as nil")
	}
	b.PutID(InputMessageVideoTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputMessageVideo) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageVideo#74f09b52 as nil")
	}
	if i.Video == nil {
		return fmt.Errorf("unable to encode inputMessageVideo#74f09b52: field video is nil")
	}
	if err := i.Video.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageVideo#74f09b52: field video: %w", err)
	}
	if err := i.Thumbnail.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageVideo#74f09b52: field thumbnail: %w", err)
	}
	if i.Cover == nil {
		return fmt.Errorf("unable to encode inputMessageVideo#74f09b52: field cover is nil")
	}
	if err := i.Cover.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageVideo#74f09b52: field cover: %w", err)
	}
	b.PutInt32(i.StartTimestamp)
	b.PutInt(len(i.AddedStickerFileIDs))
	for _, v := range i.AddedStickerFileIDs {
		b.PutInt32(v)
	}
	b.PutInt32(i.Duration)
	b.PutInt32(i.Width)
	b.PutInt32(i.Height)
	b.PutBool(i.SupportsStreaming)
	if err := i.Caption.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageVideo#74f09b52: field caption: %w", err)
	}
	b.PutBool(i.ShowCaptionAboveMedia)
	if i.SelfDestructType == nil {
		return fmt.Errorf("unable to encode inputMessageVideo#74f09b52: field self_destruct_type is nil")
	}
	if err := i.SelfDestructType.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageVideo#74f09b52: field self_destruct_type: %w", err)
	}
	b.PutBool(i.HasSpoiler)
	return nil
}

// Decode implements bin.Decoder.
func (i *InputMessageVideo) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageVideo#74f09b52 to nil")
	}
	if err := b.ConsumeID(InputMessageVideoTypeID); err != nil {
		return fmt.Errorf("unable to decode inputMessageVideo#74f09b52: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputMessageVideo) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageVideo#74f09b52 to nil")
	}
	{
		value, err := DecodeInputFile(b)
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageVideo#74f09b52: field video: %w", err)
		}
		i.Video = value
	}
	{
		if err := i.Thumbnail.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputMessageVideo#74f09b52: field thumbnail: %w", err)
		}
	}
	{
		value, err := DecodeInputFile(b)
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageVideo#74f09b52: field cover: %w", err)
		}
		i.Cover = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageVideo#74f09b52: field start_timestamp: %w", err)
		}
		i.StartTimestamp = value
	}
	{
		headerLen, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageVideo#74f09b52: field added_sticker_file_ids: %w", err)
		}

		if headerLen > 0 {
			i.AddedStickerFileIDs = make([]int32, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageVideo#74f09b52: field added_sticker_file_ids: %w", err)
			}
			i.AddedStickerFileIDs = append(i.AddedStickerFileIDs, value)
		}
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageVideo#74f09b52: field duration: %w", err)
		}
		i.Duration = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageVideo#74f09b52: field width: %w", err)
		}
		i.Width = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageVideo#74f09b52: field height: %w", err)
		}
		i.Height = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageVideo#74f09b52: field supports_streaming: %w", err)
		}
		i.SupportsStreaming = value
	}
	{
		if err := i.Caption.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputMessageVideo#74f09b52: field caption: %w", err)
		}
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageVideo#74f09b52: field show_caption_above_media: %w", err)
		}
		i.ShowCaptionAboveMedia = value
	}
	{
		value, err := DecodeMessageSelfDestructType(b)
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageVideo#74f09b52: field self_destruct_type: %w", err)
		}
		i.SelfDestructType = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageVideo#74f09b52: field has_spoiler: %w", err)
		}
		i.HasSpoiler = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (i *InputMessageVideo) EncodeTDLibJSON(b tdjson.Encoder) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageVideo#74f09b52 as nil")
	}
	b.ObjStart()
	b.PutID("inputMessageVideo")
	b.Comma()
	b.FieldStart("video")
	if i.Video == nil {
		return fmt.Errorf("unable to encode inputMessageVideo#74f09b52: field video is nil")
	}
	if err := i.Video.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageVideo#74f09b52: field video: %w", err)
	}
	b.Comma()
	b.FieldStart("thumbnail")
	if err := i.Thumbnail.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageVideo#74f09b52: field thumbnail: %w", err)
	}
	b.Comma()
	b.FieldStart("cover")
	if i.Cover == nil {
		return fmt.Errorf("unable to encode inputMessageVideo#74f09b52: field cover is nil")
	}
	if err := i.Cover.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageVideo#74f09b52: field cover: %w", err)
	}
	b.Comma()
	b.FieldStart("start_timestamp")
	b.PutInt32(i.StartTimestamp)
	b.Comma()
	b.FieldStart("added_sticker_file_ids")
	b.ArrStart()
	for _, v := range i.AddedStickerFileIDs {
		b.PutInt32(v)
		b.Comma()
	}
	b.StripComma()
	b.ArrEnd()
	b.Comma()
	b.FieldStart("duration")
	b.PutInt32(i.Duration)
	b.Comma()
	b.FieldStart("width")
	b.PutInt32(i.Width)
	b.Comma()
	b.FieldStart("height")
	b.PutInt32(i.Height)
	b.Comma()
	b.FieldStart("supports_streaming")
	b.PutBool(i.SupportsStreaming)
	b.Comma()
	b.FieldStart("caption")
	if err := i.Caption.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageVideo#74f09b52: field caption: %w", err)
	}
	b.Comma()
	b.FieldStart("show_caption_above_media")
	b.PutBool(i.ShowCaptionAboveMedia)
	b.Comma()
	b.FieldStart("self_destruct_type")
	if i.SelfDestructType == nil {
		return fmt.Errorf("unable to encode inputMessageVideo#74f09b52: field self_destruct_type is nil")
	}
	if err := i.SelfDestructType.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageVideo#74f09b52: field self_destruct_type: %w", err)
	}
	b.Comma()
	b.FieldStart("has_spoiler")
	b.PutBool(i.HasSpoiler)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (i *InputMessageVideo) DecodeTDLibJSON(b tdjson.Decoder) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageVideo#74f09b52 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("inputMessageVideo"); err != nil {
				return fmt.Errorf("unable to decode inputMessageVideo#74f09b52: %w", err)
			}
		case "video":
			value, err := DecodeTDLibJSONInputFile(b)
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageVideo#74f09b52: field video: %w", err)
			}
			i.Video = value
		case "thumbnail":
			if err := i.Thumbnail.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode inputMessageVideo#74f09b52: field thumbnail: %w", err)
			}
		case "cover":
			value, err := DecodeTDLibJSONInputFile(b)
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageVideo#74f09b52: field cover: %w", err)
			}
			i.Cover = value
		case "start_timestamp":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageVideo#74f09b52: field start_timestamp: %w", err)
			}
			i.StartTimestamp = value
		case "added_sticker_file_ids":
			if err := b.Arr(func(b tdjson.Decoder) error {
				value, err := b.Int32()
				if err != nil {
					return fmt.Errorf("unable to decode inputMessageVideo#74f09b52: field added_sticker_file_ids: %w", err)
				}
				i.AddedStickerFileIDs = append(i.AddedStickerFileIDs, value)
				return nil
			}); err != nil {
				return fmt.Errorf("unable to decode inputMessageVideo#74f09b52: field added_sticker_file_ids: %w", err)
			}
		case "duration":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageVideo#74f09b52: field duration: %w", err)
			}
			i.Duration = value
		case "width":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageVideo#74f09b52: field width: %w", err)
			}
			i.Width = value
		case "height":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageVideo#74f09b52: field height: %w", err)
			}
			i.Height = value
		case "supports_streaming":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageVideo#74f09b52: field supports_streaming: %w", err)
			}
			i.SupportsStreaming = value
		case "caption":
			if err := i.Caption.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode inputMessageVideo#74f09b52: field caption: %w", err)
			}
		case "show_caption_above_media":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageVideo#74f09b52: field show_caption_above_media: %w", err)
			}
			i.ShowCaptionAboveMedia = value
		case "self_destruct_type":
			value, err := DecodeTDLibJSONMessageSelfDestructType(b)
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageVideo#74f09b52: field self_destruct_type: %w", err)
			}
			i.SelfDestructType = value
		case "has_spoiler":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageVideo#74f09b52: field has_spoiler: %w", err)
			}
			i.HasSpoiler = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetVideo returns value of Video field.
func (i *InputMessageVideo) GetVideo() (value InputFileClass) {
	if i == nil {
		return
	}
	return i.Video
}

// GetThumbnail returns value of Thumbnail field.
func (i *InputMessageVideo) GetThumbnail() (value InputThumbnail) {
	if i == nil {
		return
	}
	return i.Thumbnail
}

// GetCover returns value of Cover field.
func (i *InputMessageVideo) GetCover() (value InputFileClass) {
	if i == nil {
		return
	}
	return i.Cover
}

// GetStartTimestamp returns value of StartTimestamp field.
func (i *InputMessageVideo) GetStartTimestamp() (value int32) {
	if i == nil {
		return
	}
	return i.StartTimestamp
}

// GetAddedStickerFileIDs returns value of AddedStickerFileIDs field.
func (i *InputMessageVideo) GetAddedStickerFileIDs() (value []int32) {
	if i == nil {
		return
	}
	return i.AddedStickerFileIDs
}

// GetDuration returns value of Duration field.
func (i *InputMessageVideo) GetDuration() (value int32) {
	if i == nil {
		return
	}
	return i.Duration
}

// GetWidth returns value of Width field.
func (i *InputMessageVideo) GetWidth() (value int32) {
	if i == nil {
		return
	}
	return i.Width
}

// GetHeight returns value of Height field.
func (i *InputMessageVideo) GetHeight() (value int32) {
	if i == nil {
		return
	}
	return i.Height
}

// GetSupportsStreaming returns value of SupportsStreaming field.
func (i *InputMessageVideo) GetSupportsStreaming() (value bool) {
	if i == nil {
		return
	}
	return i.SupportsStreaming
}

// GetCaption returns value of Caption field.
func (i *InputMessageVideo) GetCaption() (value FormattedText) {
	if i == nil {
		return
	}
	return i.Caption
}

// GetShowCaptionAboveMedia returns value of ShowCaptionAboveMedia field.
func (i *InputMessageVideo) GetShowCaptionAboveMedia() (value bool) {
	if i == nil {
		return
	}
	return i.ShowCaptionAboveMedia
}

// GetSelfDestructType returns value of SelfDestructType field.
func (i *InputMessageVideo) GetSelfDestructType() (value MessageSelfDestructTypeClass) {
	if i == nil {
		return
	}
	return i.SelfDestructType
}

// GetHasSpoiler returns value of HasSpoiler field.
func (i *InputMessageVideo) GetHasSpoiler() (value bool) {
	if i == nil {
		return
	}
	return i.HasSpoiler
}

// InputMessageVideoNote represents TL type `inputMessageVideoNote#d56816dd`.
type InputMessageVideoNote struct {
	// Video note to be sent. The video is expected to be encoded to MPEG4 format with H.264
	// codec and have no data outside of the visible circle
	VideoNote InputFileClass
	// Video thumbnail; may be null if empty; pass null to skip thumbnail uploading
	Thumbnail InputThumbnail
	// Duration of the video, in seconds; 0-60
	Duration int32
	// Video width and height; must be positive and not greater than 640
	Length int32
	// Video note self-destruct type; may be null if none; pass null if none; private chats
	// only
	SelfDestructType MessageSelfDestructTypeClass
}

// InputMessageVideoNoteTypeID is TL type id of InputMessageVideoNote.
const InputMessageVideoNoteTypeID = 0xd56816dd

// construct implements constructor of InputMessageContentClass.
func (i InputMessageVideoNote) construct() InputMessageContentClass { return &i }

// Ensuring interfaces in compile-time for InputMessageVideoNote.
var (
	_ bin.Encoder     = &InputMessageVideoNote{}
	_ bin.Decoder     = &InputMessageVideoNote{}
	_ bin.BareEncoder = &InputMessageVideoNote{}
	_ bin.BareDecoder = &InputMessageVideoNote{}

	_ InputMessageContentClass = &InputMessageVideoNote{}
)

func (i *InputMessageVideoNote) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.VideoNote == nil) {
		return false
	}
	if !(i.Thumbnail.Zero()) {
		return false
	}
	if !(i.Duration == 0) {
		return false
	}
	if !(i.Length == 0) {
		return false
	}
	if !(i.SelfDestructType == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputMessageVideoNote) String() string {
	if i == nil {
		return "InputMessageVideoNote(nil)"
	}
	type Alias InputMessageVideoNote
	return fmt.Sprintf("InputMessageVideoNote%+v", Alias(*i))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputMessageVideoNote) TypeID() uint32 {
	return InputMessageVideoNoteTypeID
}

// TypeName returns name of type in TL schema.
func (*InputMessageVideoNote) TypeName() string {
	return "inputMessageVideoNote"
}

// TypeInfo returns info about TL type.
func (i *InputMessageVideoNote) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputMessageVideoNote",
		ID:   InputMessageVideoNoteTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "VideoNote",
			SchemaName: "video_note",
		},
		{
			Name:       "Thumbnail",
			SchemaName: "thumbnail",
		},
		{
			Name:       "Duration",
			SchemaName: "duration",
		},
		{
			Name:       "Length",
			SchemaName: "length",
		},
		{
			Name:       "SelfDestructType",
			SchemaName: "self_destruct_type",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (i *InputMessageVideoNote) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageVideoNote#d56816dd as nil")
	}
	b.PutID(InputMessageVideoNoteTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputMessageVideoNote) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageVideoNote#d56816dd as nil")
	}
	if i.VideoNote == nil {
		return fmt.Errorf("unable to encode inputMessageVideoNote#d56816dd: field video_note is nil")
	}
	if err := i.VideoNote.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageVideoNote#d56816dd: field video_note: %w", err)
	}
	if err := i.Thumbnail.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageVideoNote#d56816dd: field thumbnail: %w", err)
	}
	b.PutInt32(i.Duration)
	b.PutInt32(i.Length)
	if i.SelfDestructType == nil {
		return fmt.Errorf("unable to encode inputMessageVideoNote#d56816dd: field self_destruct_type is nil")
	}
	if err := i.SelfDestructType.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageVideoNote#d56816dd: field self_destruct_type: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (i *InputMessageVideoNote) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageVideoNote#d56816dd to nil")
	}
	if err := b.ConsumeID(InputMessageVideoNoteTypeID); err != nil {
		return fmt.Errorf("unable to decode inputMessageVideoNote#d56816dd: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputMessageVideoNote) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageVideoNote#d56816dd to nil")
	}
	{
		value, err := DecodeInputFile(b)
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageVideoNote#d56816dd: field video_note: %w", err)
		}
		i.VideoNote = value
	}
	{
		if err := i.Thumbnail.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputMessageVideoNote#d56816dd: field thumbnail: %w", err)
		}
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageVideoNote#d56816dd: field duration: %w", err)
		}
		i.Duration = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageVideoNote#d56816dd: field length: %w", err)
		}
		i.Length = value
	}
	{
		value, err := DecodeMessageSelfDestructType(b)
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageVideoNote#d56816dd: field self_destruct_type: %w", err)
		}
		i.SelfDestructType = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (i *InputMessageVideoNote) EncodeTDLibJSON(b tdjson.Encoder) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageVideoNote#d56816dd as nil")
	}
	b.ObjStart()
	b.PutID("inputMessageVideoNote")
	b.Comma()
	b.FieldStart("video_note")
	if i.VideoNote == nil {
		return fmt.Errorf("unable to encode inputMessageVideoNote#d56816dd: field video_note is nil")
	}
	if err := i.VideoNote.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageVideoNote#d56816dd: field video_note: %w", err)
	}
	b.Comma()
	b.FieldStart("thumbnail")
	if err := i.Thumbnail.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageVideoNote#d56816dd: field thumbnail: %w", err)
	}
	b.Comma()
	b.FieldStart("duration")
	b.PutInt32(i.Duration)
	b.Comma()
	b.FieldStart("length")
	b.PutInt32(i.Length)
	b.Comma()
	b.FieldStart("self_destruct_type")
	if i.SelfDestructType == nil {
		return fmt.Errorf("unable to encode inputMessageVideoNote#d56816dd: field self_destruct_type is nil")
	}
	if err := i.SelfDestructType.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageVideoNote#d56816dd: field self_destruct_type: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (i *InputMessageVideoNote) DecodeTDLibJSON(b tdjson.Decoder) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageVideoNote#d56816dd to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("inputMessageVideoNote"); err != nil {
				return fmt.Errorf("unable to decode inputMessageVideoNote#d56816dd: %w", err)
			}
		case "video_note":
			value, err := DecodeTDLibJSONInputFile(b)
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageVideoNote#d56816dd: field video_note: %w", err)
			}
			i.VideoNote = value
		case "thumbnail":
			if err := i.Thumbnail.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode inputMessageVideoNote#d56816dd: field thumbnail: %w", err)
			}
		case "duration":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageVideoNote#d56816dd: field duration: %w", err)
			}
			i.Duration = value
		case "length":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageVideoNote#d56816dd: field length: %w", err)
			}
			i.Length = value
		case "self_destruct_type":
			value, err := DecodeTDLibJSONMessageSelfDestructType(b)
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageVideoNote#d56816dd: field self_destruct_type: %w", err)
			}
			i.SelfDestructType = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetVideoNote returns value of VideoNote field.
func (i *InputMessageVideoNote) GetVideoNote() (value InputFileClass) {
	if i == nil {
		return
	}
	return i.VideoNote
}

// GetThumbnail returns value of Thumbnail field.
func (i *InputMessageVideoNote) GetThumbnail() (value InputThumbnail) {
	if i == nil {
		return
	}
	return i.Thumbnail
}

// GetDuration returns value of Duration field.
func (i *InputMessageVideoNote) GetDuration() (value int32) {
	if i == nil {
		return
	}
	return i.Duration
}

// GetLength returns value of Length field.
func (i *InputMessageVideoNote) GetLength() (value int32) {
	if i == nil {
		return
	}
	return i.Length
}

// GetSelfDestructType returns value of SelfDestructType field.
func (i *InputMessageVideoNote) GetSelfDestructType() (value MessageSelfDestructTypeClass) {
	if i == nil {
		return
	}
	return i.SelfDestructType
}

// InputMessageVoiceNote represents TL type `inputMessageVoiceNote#5723ffac`.
type InputMessageVoiceNote struct {
	// Voice note to be sent. The voice note must be encoded with the Opus codec and stored
	// inside an OGG container with a single audio channel, or be in MP3 or M4A format as
	// regular audio
	VoiceNote InputFileClass
	// Duration of the voice note, in seconds
	Duration int32
	// Waveform representation of the voice note in 5-bit format
	Waveform []byte
	// Voice note caption; may be null if empty; pass null to use an empty caption;
	// 0-getOption("message_caption_length_max") characters
	Caption FormattedText
	// Voice note self-destruct type; may be null if none; pass null if none; private chats
	// only
	SelfDestructType MessageSelfDestructTypeClass
}

// InputMessageVoiceNoteTypeID is TL type id of InputMessageVoiceNote.
const InputMessageVoiceNoteTypeID = 0x5723ffac

// construct implements constructor of InputMessageContentClass.
func (i InputMessageVoiceNote) construct() InputMessageContentClass { return &i }

// Ensuring interfaces in compile-time for InputMessageVoiceNote.
var (
	_ bin.Encoder     = &InputMessageVoiceNote{}
	_ bin.Decoder     = &InputMessageVoiceNote{}
	_ bin.BareEncoder = &InputMessageVoiceNote{}
	_ bin.BareDecoder = &InputMessageVoiceNote{}

	_ InputMessageContentClass = &InputMessageVoiceNote{}
)

func (i *InputMessageVoiceNote) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.VoiceNote == nil) {
		return false
	}
	if !(i.Duration == 0) {
		return false
	}
	if !(i.Waveform == nil) {
		return false
	}
	if !(i.Caption.Zero()) {
		return false
	}
	if !(i.SelfDestructType == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputMessageVoiceNote) String() string {
	if i == nil {
		return "InputMessageVoiceNote(nil)"
	}
	type Alias InputMessageVoiceNote
	return fmt.Sprintf("InputMessageVoiceNote%+v", Alias(*i))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputMessageVoiceNote) TypeID() uint32 {
	return InputMessageVoiceNoteTypeID
}

// TypeName returns name of type in TL schema.
func (*InputMessageVoiceNote) TypeName() string {
	return "inputMessageVoiceNote"
}

// TypeInfo returns info about TL type.
func (i *InputMessageVoiceNote) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputMessageVoiceNote",
		ID:   InputMessageVoiceNoteTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "VoiceNote",
			SchemaName: "voice_note",
		},
		{
			Name:       "Duration",
			SchemaName: "duration",
		},
		{
			Name:       "Waveform",
			SchemaName: "waveform",
		},
		{
			Name:       "Caption",
			SchemaName: "caption",
		},
		{
			Name:       "SelfDestructType",
			SchemaName: "self_destruct_type",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (i *InputMessageVoiceNote) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageVoiceNote#5723ffac as nil")
	}
	b.PutID(InputMessageVoiceNoteTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputMessageVoiceNote) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageVoiceNote#5723ffac as nil")
	}
	if i.VoiceNote == nil {
		return fmt.Errorf("unable to encode inputMessageVoiceNote#5723ffac: field voice_note is nil")
	}
	if err := i.VoiceNote.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageVoiceNote#5723ffac: field voice_note: %w", err)
	}
	b.PutInt32(i.Duration)
	b.PutBytes(i.Waveform)
	if err := i.Caption.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageVoiceNote#5723ffac: field caption: %w", err)
	}
	if i.SelfDestructType == nil {
		return fmt.Errorf("unable to encode inputMessageVoiceNote#5723ffac: field self_destruct_type is nil")
	}
	if err := i.SelfDestructType.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageVoiceNote#5723ffac: field self_destruct_type: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (i *InputMessageVoiceNote) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageVoiceNote#5723ffac to nil")
	}
	if err := b.ConsumeID(InputMessageVoiceNoteTypeID); err != nil {
		return fmt.Errorf("unable to decode inputMessageVoiceNote#5723ffac: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputMessageVoiceNote) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageVoiceNote#5723ffac to nil")
	}
	{
		value, err := DecodeInputFile(b)
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageVoiceNote#5723ffac: field voice_note: %w", err)
		}
		i.VoiceNote = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageVoiceNote#5723ffac: field duration: %w", err)
		}
		i.Duration = value
	}
	{
		value, err := b.Bytes()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageVoiceNote#5723ffac: field waveform: %w", err)
		}
		i.Waveform = value
	}
	{
		if err := i.Caption.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputMessageVoiceNote#5723ffac: field caption: %w", err)
		}
	}
	{
		value, err := DecodeMessageSelfDestructType(b)
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageVoiceNote#5723ffac: field self_destruct_type: %w", err)
		}
		i.SelfDestructType = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (i *InputMessageVoiceNote) EncodeTDLibJSON(b tdjson.Encoder) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageVoiceNote#5723ffac as nil")
	}
	b.ObjStart()
	b.PutID("inputMessageVoiceNote")
	b.Comma()
	b.FieldStart("voice_note")
	if i.VoiceNote == nil {
		return fmt.Errorf("unable to encode inputMessageVoiceNote#5723ffac: field voice_note is nil")
	}
	if err := i.VoiceNote.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageVoiceNote#5723ffac: field voice_note: %w", err)
	}
	b.Comma()
	b.FieldStart("duration")
	b.PutInt32(i.Duration)
	b.Comma()
	b.FieldStart("waveform")
	b.PutBytes(i.Waveform)
	b.Comma()
	b.FieldStart("caption")
	if err := i.Caption.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageVoiceNote#5723ffac: field caption: %w", err)
	}
	b.Comma()
	b.FieldStart("self_destruct_type")
	if i.SelfDestructType == nil {
		return fmt.Errorf("unable to encode inputMessageVoiceNote#5723ffac: field self_destruct_type is nil")
	}
	if err := i.SelfDestructType.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageVoiceNote#5723ffac: field self_destruct_type: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (i *InputMessageVoiceNote) DecodeTDLibJSON(b tdjson.Decoder) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageVoiceNote#5723ffac to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("inputMessageVoiceNote"); err != nil {
				return fmt.Errorf("unable to decode inputMessageVoiceNote#5723ffac: %w", err)
			}
		case "voice_note":
			value, err := DecodeTDLibJSONInputFile(b)
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageVoiceNote#5723ffac: field voice_note: %w", err)
			}
			i.VoiceNote = value
		case "duration":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageVoiceNote#5723ffac: field duration: %w", err)
			}
			i.Duration = value
		case "waveform":
			value, err := b.Bytes()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageVoiceNote#5723ffac: field waveform: %w", err)
			}
			i.Waveform = value
		case "caption":
			if err := i.Caption.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode inputMessageVoiceNote#5723ffac: field caption: %w", err)
			}
		case "self_destruct_type":
			value, err := DecodeTDLibJSONMessageSelfDestructType(b)
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageVoiceNote#5723ffac: field self_destruct_type: %w", err)
			}
			i.SelfDestructType = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetVoiceNote returns value of VoiceNote field.
func (i *InputMessageVoiceNote) GetVoiceNote() (value InputFileClass) {
	if i == nil {
		return
	}
	return i.VoiceNote
}

// GetDuration returns value of Duration field.
func (i *InputMessageVoiceNote) GetDuration() (value int32) {
	if i == nil {
		return
	}
	return i.Duration
}

// GetWaveform returns value of Waveform field.
func (i *InputMessageVoiceNote) GetWaveform() (value []byte) {
	if i == nil {
		return
	}
	return i.Waveform
}

// GetCaption returns value of Caption field.
func (i *InputMessageVoiceNote) GetCaption() (value FormattedText) {
	if i == nil {
		return
	}
	return i.Caption
}

// GetSelfDestructType returns value of SelfDestructType field.
func (i *InputMessageVoiceNote) GetSelfDestructType() (value MessageSelfDestructTypeClass) {
	if i == nil {
		return
	}
	return i.SelfDestructType
}

// InputMessageLocation represents TL type `inputMessageLocation#26aae970`.
type InputMessageLocation struct {
	// Location to be sent
	Location Location
	// Period for which the location can be updated, in seconds; must be between 60 and 86400
	// for a temporary live location, 0x7FFFFFFF for permanent live location, and 0 otherwise
	LivePeriod int32
	// For live locations, a direction in which the location moves, in degrees; 1-360. Pass 0
	// if unknown
	Heading int32
	// For live locations, a maximum distance to another chat member for proximity alerts, in
	// meters (0-100000). Pass 0 if the notification is disabled. Can't be enabled in
	// channels and Saved Messages
	ProximityAlertRadius int32
}

// InputMessageLocationTypeID is TL type id of InputMessageLocation.
const InputMessageLocationTypeID = 0x26aae970

// construct implements constructor of InputMessageContentClass.
func (i InputMessageLocation) construct() InputMessageContentClass { return &i }

// Ensuring interfaces in compile-time for InputMessageLocation.
var (
	_ bin.Encoder     = &InputMessageLocation{}
	_ bin.Decoder     = &InputMessageLocation{}
	_ bin.BareEncoder = &InputMessageLocation{}
	_ bin.BareDecoder = &InputMessageLocation{}

	_ InputMessageContentClass = &InputMessageLocation{}
)

func (i *InputMessageLocation) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.Location.Zero()) {
		return false
	}
	if !(i.LivePeriod == 0) {
		return false
	}
	if !(i.Heading == 0) {
		return false
	}
	if !(i.ProximityAlertRadius == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputMessageLocation) String() string {
	if i == nil {
		return "InputMessageLocation(nil)"
	}
	type Alias InputMessageLocation
	return fmt.Sprintf("InputMessageLocation%+v", Alias(*i))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputMessageLocation) TypeID() uint32 {
	return InputMessageLocationTypeID
}

// TypeName returns name of type in TL schema.
func (*InputMessageLocation) TypeName() string {
	return "inputMessageLocation"
}

// TypeInfo returns info about TL type.
func (i *InputMessageLocation) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputMessageLocation",
		ID:   InputMessageLocationTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Location",
			SchemaName: "location",
		},
		{
			Name:       "LivePeriod",
			SchemaName: "live_period",
		},
		{
			Name:       "Heading",
			SchemaName: "heading",
		},
		{
			Name:       "ProximityAlertRadius",
			SchemaName: "proximity_alert_radius",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (i *InputMessageLocation) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageLocation#26aae970 as nil")
	}
	b.PutID(InputMessageLocationTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputMessageLocation) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageLocation#26aae970 as nil")
	}
	if err := i.Location.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageLocation#26aae970: field location: %w", err)
	}
	b.PutInt32(i.LivePeriod)
	b.PutInt32(i.Heading)
	b.PutInt32(i.ProximityAlertRadius)
	return nil
}

// Decode implements bin.Decoder.
func (i *InputMessageLocation) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageLocation#26aae970 to nil")
	}
	if err := b.ConsumeID(InputMessageLocationTypeID); err != nil {
		return fmt.Errorf("unable to decode inputMessageLocation#26aae970: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputMessageLocation) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageLocation#26aae970 to nil")
	}
	{
		if err := i.Location.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputMessageLocation#26aae970: field location: %w", err)
		}
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageLocation#26aae970: field live_period: %w", err)
		}
		i.LivePeriod = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageLocation#26aae970: field heading: %w", err)
		}
		i.Heading = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageLocation#26aae970: field proximity_alert_radius: %w", err)
		}
		i.ProximityAlertRadius = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (i *InputMessageLocation) EncodeTDLibJSON(b tdjson.Encoder) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageLocation#26aae970 as nil")
	}
	b.ObjStart()
	b.PutID("inputMessageLocation")
	b.Comma()
	b.FieldStart("location")
	if err := i.Location.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageLocation#26aae970: field location: %w", err)
	}
	b.Comma()
	b.FieldStart("live_period")
	b.PutInt32(i.LivePeriod)
	b.Comma()
	b.FieldStart("heading")
	b.PutInt32(i.Heading)
	b.Comma()
	b.FieldStart("proximity_alert_radius")
	b.PutInt32(i.ProximityAlertRadius)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (i *InputMessageLocation) DecodeTDLibJSON(b tdjson.Decoder) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageLocation#26aae970 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("inputMessageLocation"); err != nil {
				return fmt.Errorf("unable to decode inputMessageLocation#26aae970: %w", err)
			}
		case "location":
			if err := i.Location.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode inputMessageLocation#26aae970: field location: %w", err)
			}
		case "live_period":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageLocation#26aae970: field live_period: %w", err)
			}
			i.LivePeriod = value
		case "heading":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageLocation#26aae970: field heading: %w", err)
			}
			i.Heading = value
		case "proximity_alert_radius":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageLocation#26aae970: field proximity_alert_radius: %w", err)
			}
			i.ProximityAlertRadius = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetLocation returns value of Location field.
func (i *InputMessageLocation) GetLocation() (value Location) {
	if i == nil {
		return
	}
	return i.Location
}

// GetLivePeriod returns value of LivePeriod field.
func (i *InputMessageLocation) GetLivePeriod() (value int32) {
	if i == nil {
		return
	}
	return i.LivePeriod
}

// GetHeading returns value of Heading field.
func (i *InputMessageLocation) GetHeading() (value int32) {
	if i == nil {
		return
	}
	return i.Heading
}

// GetProximityAlertRadius returns value of ProximityAlertRadius field.
func (i *InputMessageLocation) GetProximityAlertRadius() (value int32) {
	if i == nil {
		return
	}
	return i.ProximityAlertRadius
}

// InputMessageVenue represents TL type `inputMessageVenue#564d99fd`.
type InputMessageVenue struct {
	// Venue to send
	Venue Venue
}

// InputMessageVenueTypeID is TL type id of InputMessageVenue.
const InputMessageVenueTypeID = 0x564d99fd

// construct implements constructor of InputMessageContentClass.
func (i InputMessageVenue) construct() InputMessageContentClass { return &i }

// Ensuring interfaces in compile-time for InputMessageVenue.
var (
	_ bin.Encoder     = &InputMessageVenue{}
	_ bin.Decoder     = &InputMessageVenue{}
	_ bin.BareEncoder = &InputMessageVenue{}
	_ bin.BareDecoder = &InputMessageVenue{}

	_ InputMessageContentClass = &InputMessageVenue{}
)

func (i *InputMessageVenue) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.Venue.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputMessageVenue) String() string {
	if i == nil {
		return "InputMessageVenue(nil)"
	}
	type Alias InputMessageVenue
	return fmt.Sprintf("InputMessageVenue%+v", Alias(*i))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputMessageVenue) TypeID() uint32 {
	return InputMessageVenueTypeID
}

// TypeName returns name of type in TL schema.
func (*InputMessageVenue) TypeName() string {
	return "inputMessageVenue"
}

// TypeInfo returns info about TL type.
func (i *InputMessageVenue) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputMessageVenue",
		ID:   InputMessageVenueTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Venue",
			SchemaName: "venue",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (i *InputMessageVenue) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageVenue#564d99fd as nil")
	}
	b.PutID(InputMessageVenueTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputMessageVenue) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageVenue#564d99fd as nil")
	}
	if err := i.Venue.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageVenue#564d99fd: field venue: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (i *InputMessageVenue) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageVenue#564d99fd to nil")
	}
	if err := b.ConsumeID(InputMessageVenueTypeID); err != nil {
		return fmt.Errorf("unable to decode inputMessageVenue#564d99fd: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputMessageVenue) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageVenue#564d99fd to nil")
	}
	{
		if err := i.Venue.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputMessageVenue#564d99fd: field venue: %w", err)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (i *InputMessageVenue) EncodeTDLibJSON(b tdjson.Encoder) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageVenue#564d99fd as nil")
	}
	b.ObjStart()
	b.PutID("inputMessageVenue")
	b.Comma()
	b.FieldStart("venue")
	if err := i.Venue.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageVenue#564d99fd: field venue: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (i *InputMessageVenue) DecodeTDLibJSON(b tdjson.Decoder) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageVenue#564d99fd to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("inputMessageVenue"); err != nil {
				return fmt.Errorf("unable to decode inputMessageVenue#564d99fd: %w", err)
			}
		case "venue":
			if err := i.Venue.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode inputMessageVenue#564d99fd: field venue: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetVenue returns value of Venue field.
func (i *InputMessageVenue) GetVenue() (value Venue) {
	if i == nil {
		return
	}
	return i.Venue
}

// InputMessageContact represents TL type `inputMessageContact#c5710cff`.
type InputMessageContact struct {
	// Contact to send
	Contact Contact
}

// InputMessageContactTypeID is TL type id of InputMessageContact.
const InputMessageContactTypeID = 0xc5710cff

// construct implements constructor of InputMessageContentClass.
func (i InputMessageContact) construct() InputMessageContentClass { return &i }

// Ensuring interfaces in compile-time for InputMessageContact.
var (
	_ bin.Encoder     = &InputMessageContact{}
	_ bin.Decoder     = &InputMessageContact{}
	_ bin.BareEncoder = &InputMessageContact{}
	_ bin.BareDecoder = &InputMessageContact{}

	_ InputMessageContentClass = &InputMessageContact{}
)

func (i *InputMessageContact) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.Contact.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputMessageContact) String() string {
	if i == nil {
		return "InputMessageContact(nil)"
	}
	type Alias InputMessageContact
	return fmt.Sprintf("InputMessageContact%+v", Alias(*i))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputMessageContact) TypeID() uint32 {
	return InputMessageContactTypeID
}

// TypeName returns name of type in TL schema.
func (*InputMessageContact) TypeName() string {
	return "inputMessageContact"
}

// TypeInfo returns info about TL type.
func (i *InputMessageContact) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputMessageContact",
		ID:   InputMessageContactTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Contact",
			SchemaName: "contact",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (i *InputMessageContact) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageContact#c5710cff as nil")
	}
	b.PutID(InputMessageContactTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputMessageContact) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageContact#c5710cff as nil")
	}
	if err := i.Contact.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageContact#c5710cff: field contact: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (i *InputMessageContact) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageContact#c5710cff to nil")
	}
	if err := b.ConsumeID(InputMessageContactTypeID); err != nil {
		return fmt.Errorf("unable to decode inputMessageContact#c5710cff: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputMessageContact) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageContact#c5710cff to nil")
	}
	{
		if err := i.Contact.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputMessageContact#c5710cff: field contact: %w", err)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (i *InputMessageContact) EncodeTDLibJSON(b tdjson.Encoder) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageContact#c5710cff as nil")
	}
	b.ObjStart()
	b.PutID("inputMessageContact")
	b.Comma()
	b.FieldStart("contact")
	if err := i.Contact.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageContact#c5710cff: field contact: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (i *InputMessageContact) DecodeTDLibJSON(b tdjson.Decoder) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageContact#c5710cff to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("inputMessageContact"); err != nil {
				return fmt.Errorf("unable to decode inputMessageContact#c5710cff: %w", err)
			}
		case "contact":
			if err := i.Contact.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode inputMessageContact#c5710cff: field contact: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetContact returns value of Contact field.
func (i *InputMessageContact) GetContact() (value Contact) {
	if i == nil {
		return
	}
	return i.Contact
}

// InputMessageDice represents TL type `inputMessageDice#322967a9`.
type InputMessageDice struct {
	// Emoji on which the dice throw animation is based
	Emoji string
	// True, if the chat message draft must be deleted
	ClearDraft bool
}

// InputMessageDiceTypeID is TL type id of InputMessageDice.
const InputMessageDiceTypeID = 0x322967a9

// construct implements constructor of InputMessageContentClass.
func (i InputMessageDice) construct() InputMessageContentClass { return &i }

// Ensuring interfaces in compile-time for InputMessageDice.
var (
	_ bin.Encoder     = &InputMessageDice{}
	_ bin.Decoder     = &InputMessageDice{}
	_ bin.BareEncoder = &InputMessageDice{}
	_ bin.BareDecoder = &InputMessageDice{}

	_ InputMessageContentClass = &InputMessageDice{}
)

func (i *InputMessageDice) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.Emoji == "") {
		return false
	}
	if !(i.ClearDraft == false) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputMessageDice) String() string {
	if i == nil {
		return "InputMessageDice(nil)"
	}
	type Alias InputMessageDice
	return fmt.Sprintf("InputMessageDice%+v", Alias(*i))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputMessageDice) TypeID() uint32 {
	return InputMessageDiceTypeID
}

// TypeName returns name of type in TL schema.
func (*InputMessageDice) TypeName() string {
	return "inputMessageDice"
}

// TypeInfo returns info about TL type.
func (i *InputMessageDice) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputMessageDice",
		ID:   InputMessageDiceTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Emoji",
			SchemaName: "emoji",
		},
		{
			Name:       "ClearDraft",
			SchemaName: "clear_draft",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (i *InputMessageDice) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageDice#322967a9 as nil")
	}
	b.PutID(InputMessageDiceTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputMessageDice) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageDice#322967a9 as nil")
	}
	b.PutString(i.Emoji)
	b.PutBool(i.ClearDraft)
	return nil
}

// Decode implements bin.Decoder.
func (i *InputMessageDice) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageDice#322967a9 to nil")
	}
	if err := b.ConsumeID(InputMessageDiceTypeID); err != nil {
		return fmt.Errorf("unable to decode inputMessageDice#322967a9: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputMessageDice) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageDice#322967a9 to nil")
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageDice#322967a9: field emoji: %w", err)
		}
		i.Emoji = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageDice#322967a9: field clear_draft: %w", err)
		}
		i.ClearDraft = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (i *InputMessageDice) EncodeTDLibJSON(b tdjson.Encoder) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageDice#322967a9 as nil")
	}
	b.ObjStart()
	b.PutID("inputMessageDice")
	b.Comma()
	b.FieldStart("emoji")
	b.PutString(i.Emoji)
	b.Comma()
	b.FieldStart("clear_draft")
	b.PutBool(i.ClearDraft)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (i *InputMessageDice) DecodeTDLibJSON(b tdjson.Decoder) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageDice#322967a9 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("inputMessageDice"); err != nil {
				return fmt.Errorf("unable to decode inputMessageDice#322967a9: %w", err)
			}
		case "emoji":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageDice#322967a9: field emoji: %w", err)
			}
			i.Emoji = value
		case "clear_draft":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageDice#322967a9: field clear_draft: %w", err)
			}
			i.ClearDraft = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetEmoji returns value of Emoji field.
func (i *InputMessageDice) GetEmoji() (value string) {
	if i == nil {
		return
	}
	return i.Emoji
}

// GetClearDraft returns value of ClearDraft field.
func (i *InputMessageDice) GetClearDraft() (value bool) {
	if i == nil {
		return
	}
	return i.ClearDraft
}

// InputMessageGame represents TL type `inputMessageGame#4aae6ae2`.
type InputMessageGame struct {
	// User identifier of the bot that owns the game
	BotUserID int64
	// Short name of the game
	GameShortName string
}

// InputMessageGameTypeID is TL type id of InputMessageGame.
const InputMessageGameTypeID = 0x4aae6ae2

// construct implements constructor of InputMessageContentClass.
func (i InputMessageGame) construct() InputMessageContentClass { return &i }

// Ensuring interfaces in compile-time for InputMessageGame.
var (
	_ bin.Encoder     = &InputMessageGame{}
	_ bin.Decoder     = &InputMessageGame{}
	_ bin.BareEncoder = &InputMessageGame{}
	_ bin.BareDecoder = &InputMessageGame{}

	_ InputMessageContentClass = &InputMessageGame{}
)

func (i *InputMessageGame) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.BotUserID == 0) {
		return false
	}
	if !(i.GameShortName == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputMessageGame) String() string {
	if i == nil {
		return "InputMessageGame(nil)"
	}
	type Alias InputMessageGame
	return fmt.Sprintf("InputMessageGame%+v", Alias(*i))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputMessageGame) TypeID() uint32 {
	return InputMessageGameTypeID
}

// TypeName returns name of type in TL schema.
func (*InputMessageGame) TypeName() string {
	return "inputMessageGame"
}

// TypeInfo returns info about TL type.
func (i *InputMessageGame) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputMessageGame",
		ID:   InputMessageGameTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "BotUserID",
			SchemaName: "bot_user_id",
		},
		{
			Name:       "GameShortName",
			SchemaName: "game_short_name",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (i *InputMessageGame) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageGame#4aae6ae2 as nil")
	}
	b.PutID(InputMessageGameTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputMessageGame) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageGame#4aae6ae2 as nil")
	}
	b.PutInt53(i.BotUserID)
	b.PutString(i.GameShortName)
	return nil
}

// Decode implements bin.Decoder.
func (i *InputMessageGame) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageGame#4aae6ae2 to nil")
	}
	if err := b.ConsumeID(InputMessageGameTypeID); err != nil {
		return fmt.Errorf("unable to decode inputMessageGame#4aae6ae2: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputMessageGame) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageGame#4aae6ae2 to nil")
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageGame#4aae6ae2: field bot_user_id: %w", err)
		}
		i.BotUserID = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageGame#4aae6ae2: field game_short_name: %w", err)
		}
		i.GameShortName = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (i *InputMessageGame) EncodeTDLibJSON(b tdjson.Encoder) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageGame#4aae6ae2 as nil")
	}
	b.ObjStart()
	b.PutID("inputMessageGame")
	b.Comma()
	b.FieldStart("bot_user_id")
	b.PutInt53(i.BotUserID)
	b.Comma()
	b.FieldStart("game_short_name")
	b.PutString(i.GameShortName)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (i *InputMessageGame) DecodeTDLibJSON(b tdjson.Decoder) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageGame#4aae6ae2 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("inputMessageGame"); err != nil {
				return fmt.Errorf("unable to decode inputMessageGame#4aae6ae2: %w", err)
			}
		case "bot_user_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageGame#4aae6ae2: field bot_user_id: %w", err)
			}
			i.BotUserID = value
		case "game_short_name":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageGame#4aae6ae2: field game_short_name: %w", err)
			}
			i.GameShortName = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetBotUserID returns value of BotUserID field.
func (i *InputMessageGame) GetBotUserID() (value int64) {
	if i == nil {
		return
	}
	return i.BotUserID
}

// GetGameShortName returns value of GameShortName field.
func (i *InputMessageGame) GetGameShortName() (value string) {
	if i == nil {
		return
	}
	return i.GameShortName
}

// InputMessageInvoice represents TL type `inputMessageInvoice#babc8f71`.
type InputMessageInvoice struct {
	// Invoice
	Invoice Invoice
	// Product title; 1-32 characters
	Title string
	// A message with an invoice; can be used only by bots
	Description string
	// Product photo URL; optional
	PhotoURL string
	// Product photo size
	PhotoSize int32
	// Product photo width
	PhotoWidth int32
	// Product photo height
	PhotoHeight int32
	// The invoice payload
	Payload []byte
	// Payment provider token; may be empty for payments in Telegram Stars
	ProviderToken string
	// JSON-encoded data about the invoice, which will be shared with the payment provider
	ProviderData string
	// Unique invoice bot deep link parameter for the generation of this invoice. If empty,
	// it would be possible to pay directly from forwards of the invoice message
	StartParameter string
	// The content of paid media attached to the invoice; pass null if none
	PaidMedia InputPaidMedia
	// Paid media caption; pass null to use an empty caption;
	// 0-getOption("message_caption_length_max") characters
	PaidMediaCaption FormattedText
}

// InputMessageInvoiceTypeID is TL type id of InputMessageInvoice.
const InputMessageInvoiceTypeID = 0xbabc8f71

// construct implements constructor of InputMessageContentClass.
func (i InputMessageInvoice) construct() InputMessageContentClass { return &i }

// Ensuring interfaces in compile-time for InputMessageInvoice.
var (
	_ bin.Encoder     = &InputMessageInvoice{}
	_ bin.Decoder     = &InputMessageInvoice{}
	_ bin.BareEncoder = &InputMessageInvoice{}
	_ bin.BareDecoder = &InputMessageInvoice{}

	_ InputMessageContentClass = &InputMessageInvoice{}
)

func (i *InputMessageInvoice) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.Invoice.Zero()) {
		return false
	}
	if !(i.Title == "") {
		return false
	}
	if !(i.Description == "") {
		return false
	}
	if !(i.PhotoURL == "") {
		return false
	}
	if !(i.PhotoSize == 0) {
		return false
	}
	if !(i.PhotoWidth == 0) {
		return false
	}
	if !(i.PhotoHeight == 0) {
		return false
	}
	if !(i.Payload == nil) {
		return false
	}
	if !(i.ProviderToken == "") {
		return false
	}
	if !(i.ProviderData == "") {
		return false
	}
	if !(i.StartParameter == "") {
		return false
	}
	if !(i.PaidMedia.Zero()) {
		return false
	}
	if !(i.PaidMediaCaption.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputMessageInvoice) String() string {
	if i == nil {
		return "InputMessageInvoice(nil)"
	}
	type Alias InputMessageInvoice
	return fmt.Sprintf("InputMessageInvoice%+v", Alias(*i))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputMessageInvoice) TypeID() uint32 {
	return InputMessageInvoiceTypeID
}

// TypeName returns name of type in TL schema.
func (*InputMessageInvoice) TypeName() string {
	return "inputMessageInvoice"
}

// TypeInfo returns info about TL type.
func (i *InputMessageInvoice) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputMessageInvoice",
		ID:   InputMessageInvoiceTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Invoice",
			SchemaName: "invoice",
		},
		{
			Name:       "Title",
			SchemaName: "title",
		},
		{
			Name:       "Description",
			SchemaName: "description",
		},
		{
			Name:       "PhotoURL",
			SchemaName: "photo_url",
		},
		{
			Name:       "PhotoSize",
			SchemaName: "photo_size",
		},
		{
			Name:       "PhotoWidth",
			SchemaName: "photo_width",
		},
		{
			Name:       "PhotoHeight",
			SchemaName: "photo_height",
		},
		{
			Name:       "Payload",
			SchemaName: "payload",
		},
		{
			Name:       "ProviderToken",
			SchemaName: "provider_token",
		},
		{
			Name:       "ProviderData",
			SchemaName: "provider_data",
		},
		{
			Name:       "StartParameter",
			SchemaName: "start_parameter",
		},
		{
			Name:       "PaidMedia",
			SchemaName: "paid_media",
		},
		{
			Name:       "PaidMediaCaption",
			SchemaName: "paid_media_caption",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (i *InputMessageInvoice) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageInvoice#babc8f71 as nil")
	}
	b.PutID(InputMessageInvoiceTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputMessageInvoice) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageInvoice#babc8f71 as nil")
	}
	if err := i.Invoice.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageInvoice#babc8f71: field invoice: %w", err)
	}
	b.PutString(i.Title)
	b.PutString(i.Description)
	b.PutString(i.PhotoURL)
	b.PutInt32(i.PhotoSize)
	b.PutInt32(i.PhotoWidth)
	b.PutInt32(i.PhotoHeight)
	b.PutBytes(i.Payload)
	b.PutString(i.ProviderToken)
	b.PutString(i.ProviderData)
	b.PutString(i.StartParameter)
	if err := i.PaidMedia.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageInvoice#babc8f71: field paid_media: %w", err)
	}
	if err := i.PaidMediaCaption.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageInvoice#babc8f71: field paid_media_caption: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (i *InputMessageInvoice) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageInvoice#babc8f71 to nil")
	}
	if err := b.ConsumeID(InputMessageInvoiceTypeID); err != nil {
		return fmt.Errorf("unable to decode inputMessageInvoice#babc8f71: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputMessageInvoice) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageInvoice#babc8f71 to nil")
	}
	{
		if err := i.Invoice.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputMessageInvoice#babc8f71: field invoice: %w", err)
		}
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageInvoice#babc8f71: field title: %w", err)
		}
		i.Title = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageInvoice#babc8f71: field description: %w", err)
		}
		i.Description = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageInvoice#babc8f71: field photo_url: %w", err)
		}
		i.PhotoURL = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageInvoice#babc8f71: field photo_size: %w", err)
		}
		i.PhotoSize = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageInvoice#babc8f71: field photo_width: %w", err)
		}
		i.PhotoWidth = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageInvoice#babc8f71: field photo_height: %w", err)
		}
		i.PhotoHeight = value
	}
	{
		value, err := b.Bytes()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageInvoice#babc8f71: field payload: %w", err)
		}
		i.Payload = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageInvoice#babc8f71: field provider_token: %w", err)
		}
		i.ProviderToken = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageInvoice#babc8f71: field provider_data: %w", err)
		}
		i.ProviderData = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageInvoice#babc8f71: field start_parameter: %w", err)
		}
		i.StartParameter = value
	}
	{
		if err := i.PaidMedia.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputMessageInvoice#babc8f71: field paid_media: %w", err)
		}
	}
	{
		if err := i.PaidMediaCaption.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputMessageInvoice#babc8f71: field paid_media_caption: %w", err)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (i *InputMessageInvoice) EncodeTDLibJSON(b tdjson.Encoder) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageInvoice#babc8f71 as nil")
	}
	b.ObjStart()
	b.PutID("inputMessageInvoice")
	b.Comma()
	b.FieldStart("invoice")
	if err := i.Invoice.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageInvoice#babc8f71: field invoice: %w", err)
	}
	b.Comma()
	b.FieldStart("title")
	b.PutString(i.Title)
	b.Comma()
	b.FieldStart("description")
	b.PutString(i.Description)
	b.Comma()
	b.FieldStart("photo_url")
	b.PutString(i.PhotoURL)
	b.Comma()
	b.FieldStart("photo_size")
	b.PutInt32(i.PhotoSize)
	b.Comma()
	b.FieldStart("photo_width")
	b.PutInt32(i.PhotoWidth)
	b.Comma()
	b.FieldStart("photo_height")
	b.PutInt32(i.PhotoHeight)
	b.Comma()
	b.FieldStart("payload")
	b.PutBytes(i.Payload)
	b.Comma()
	b.FieldStart("provider_token")
	b.PutString(i.ProviderToken)
	b.Comma()
	b.FieldStart("provider_data")
	b.PutString(i.ProviderData)
	b.Comma()
	b.FieldStart("start_parameter")
	b.PutString(i.StartParameter)
	b.Comma()
	b.FieldStart("paid_media")
	if err := i.PaidMedia.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageInvoice#babc8f71: field paid_media: %w", err)
	}
	b.Comma()
	b.FieldStart("paid_media_caption")
	if err := i.PaidMediaCaption.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageInvoice#babc8f71: field paid_media_caption: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (i *InputMessageInvoice) DecodeTDLibJSON(b tdjson.Decoder) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageInvoice#babc8f71 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("inputMessageInvoice"); err != nil {
				return fmt.Errorf("unable to decode inputMessageInvoice#babc8f71: %w", err)
			}
		case "invoice":
			if err := i.Invoice.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode inputMessageInvoice#babc8f71: field invoice: %w", err)
			}
		case "title":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageInvoice#babc8f71: field title: %w", err)
			}
			i.Title = value
		case "description":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageInvoice#babc8f71: field description: %w", err)
			}
			i.Description = value
		case "photo_url":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageInvoice#babc8f71: field photo_url: %w", err)
			}
			i.PhotoURL = value
		case "photo_size":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageInvoice#babc8f71: field photo_size: %w", err)
			}
			i.PhotoSize = value
		case "photo_width":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageInvoice#babc8f71: field photo_width: %w", err)
			}
			i.PhotoWidth = value
		case "photo_height":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageInvoice#babc8f71: field photo_height: %w", err)
			}
			i.PhotoHeight = value
		case "payload":
			value, err := b.Bytes()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageInvoice#babc8f71: field payload: %w", err)
			}
			i.Payload = value
		case "provider_token":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageInvoice#babc8f71: field provider_token: %w", err)
			}
			i.ProviderToken = value
		case "provider_data":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageInvoice#babc8f71: field provider_data: %w", err)
			}
			i.ProviderData = value
		case "start_parameter":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageInvoice#babc8f71: field start_parameter: %w", err)
			}
			i.StartParameter = value
		case "paid_media":
			if err := i.PaidMedia.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode inputMessageInvoice#babc8f71: field paid_media: %w", err)
			}
		case "paid_media_caption":
			if err := i.PaidMediaCaption.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode inputMessageInvoice#babc8f71: field paid_media_caption: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetInvoice returns value of Invoice field.
func (i *InputMessageInvoice) GetInvoice() (value Invoice) {
	if i == nil {
		return
	}
	return i.Invoice
}

// GetTitle returns value of Title field.
func (i *InputMessageInvoice) GetTitle() (value string) {
	if i == nil {
		return
	}
	return i.Title
}

// GetDescription returns value of Description field.
func (i *InputMessageInvoice) GetDescription() (value string) {
	if i == nil {
		return
	}
	return i.Description
}

// GetPhotoURL returns value of PhotoURL field.
func (i *InputMessageInvoice) GetPhotoURL() (value string) {
	if i == nil {
		return
	}
	return i.PhotoURL
}

// GetPhotoSize returns value of PhotoSize field.
func (i *InputMessageInvoice) GetPhotoSize() (value int32) {
	if i == nil {
		return
	}
	return i.PhotoSize
}

// GetPhotoWidth returns value of PhotoWidth field.
func (i *InputMessageInvoice) GetPhotoWidth() (value int32) {
	if i == nil {
		return
	}
	return i.PhotoWidth
}

// GetPhotoHeight returns value of PhotoHeight field.
func (i *InputMessageInvoice) GetPhotoHeight() (value int32) {
	if i == nil {
		return
	}
	return i.PhotoHeight
}

// GetPayload returns value of Payload field.
func (i *InputMessageInvoice) GetPayload() (value []byte) {
	if i == nil {
		return
	}
	return i.Payload
}

// GetProviderToken returns value of ProviderToken field.
func (i *InputMessageInvoice) GetProviderToken() (value string) {
	if i == nil {
		return
	}
	return i.ProviderToken
}

// GetProviderData returns value of ProviderData field.
func (i *InputMessageInvoice) GetProviderData() (value string) {
	if i == nil {
		return
	}
	return i.ProviderData
}

// GetStartParameter returns value of StartParameter field.
func (i *InputMessageInvoice) GetStartParameter() (value string) {
	if i == nil {
		return
	}
	return i.StartParameter
}

// GetPaidMedia returns value of PaidMedia field.
func (i *InputMessageInvoice) GetPaidMedia() (value InputPaidMedia) {
	if i == nil {
		return
	}
	return i.PaidMedia
}

// GetPaidMediaCaption returns value of PaidMediaCaption field.
func (i *InputMessageInvoice) GetPaidMediaCaption() (value FormattedText) {
	if i == nil {
		return
	}
	return i.PaidMediaCaption
}

// InputMessagePoll represents TL type `inputMessagePoll#9046c716`.
type InputMessagePoll struct {
	// Poll question; 1-255 characters (up to 300 characters for bots). Only custom emoji
	// entities are allowed to be added and only by Premium users
	Question FormattedText
	// List of poll answer options, 2-getOption("poll_answer_count_max") strings 1-100
	// characters each. Only custom emoji entities are allowed to be added and only by
	// Premium users
	Options []FormattedText
	// True, if the poll voters are anonymous. Non-anonymous polls can't be sent or forwarded
	// to channels
	IsAnonymous bool
	// Type of the poll
	Type PollTypeClass
	// Amount of time the poll will be active after creation, in seconds; for bots only
	OpenPeriod int32
	// Point in time (Unix timestamp) when the poll will automatically be closed; for bots
	// only
	CloseDate int32
	// True, if the poll needs to be sent already closed; for bots only
	IsClosed bool
}

// InputMessagePollTypeID is TL type id of InputMessagePoll.
const InputMessagePollTypeID = 0x9046c716

// construct implements constructor of InputMessageContentClass.
func (i InputMessagePoll) construct() InputMessageContentClass { return &i }

// Ensuring interfaces in compile-time for InputMessagePoll.
var (
	_ bin.Encoder     = &InputMessagePoll{}
	_ bin.Decoder     = &InputMessagePoll{}
	_ bin.BareEncoder = &InputMessagePoll{}
	_ bin.BareDecoder = &InputMessagePoll{}

	_ InputMessageContentClass = &InputMessagePoll{}
)

func (i *InputMessagePoll) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.Question.Zero()) {
		return false
	}
	if !(i.Options == nil) {
		return false
	}
	if !(i.IsAnonymous == false) {
		return false
	}
	if !(i.Type == nil) {
		return false
	}
	if !(i.OpenPeriod == 0) {
		return false
	}
	if !(i.CloseDate == 0) {
		return false
	}
	if !(i.IsClosed == false) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputMessagePoll) String() string {
	if i == nil {
		return "InputMessagePoll(nil)"
	}
	type Alias InputMessagePoll
	return fmt.Sprintf("InputMessagePoll%+v", Alias(*i))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputMessagePoll) TypeID() uint32 {
	return InputMessagePollTypeID
}

// TypeName returns name of type in TL schema.
func (*InputMessagePoll) TypeName() string {
	return "inputMessagePoll"
}

// TypeInfo returns info about TL type.
func (i *InputMessagePoll) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputMessagePoll",
		ID:   InputMessagePollTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Question",
			SchemaName: "question",
		},
		{
			Name:       "Options",
			SchemaName: "options",
		},
		{
			Name:       "IsAnonymous",
			SchemaName: "is_anonymous",
		},
		{
			Name:       "Type",
			SchemaName: "type",
		},
		{
			Name:       "OpenPeriod",
			SchemaName: "open_period",
		},
		{
			Name:       "CloseDate",
			SchemaName: "close_date",
		},
		{
			Name:       "IsClosed",
			SchemaName: "is_closed",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (i *InputMessagePoll) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessagePoll#9046c716 as nil")
	}
	b.PutID(InputMessagePollTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputMessagePoll) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessagePoll#9046c716 as nil")
	}
	if err := i.Question.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMessagePoll#9046c716: field question: %w", err)
	}
	b.PutInt(len(i.Options))
	for idx, v := range i.Options {
		if err := v.EncodeBare(b); err != nil {
			return fmt.Errorf("unable to encode bare inputMessagePoll#9046c716: field options element with index %d: %w", idx, err)
		}
	}
	b.PutBool(i.IsAnonymous)
	if i.Type == nil {
		return fmt.Errorf("unable to encode inputMessagePoll#9046c716: field type is nil")
	}
	if err := i.Type.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMessagePoll#9046c716: field type: %w", err)
	}
	b.PutInt32(i.OpenPeriod)
	b.PutInt32(i.CloseDate)
	b.PutBool(i.IsClosed)
	return nil
}

// Decode implements bin.Decoder.
func (i *InputMessagePoll) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessagePoll#9046c716 to nil")
	}
	if err := b.ConsumeID(InputMessagePollTypeID); err != nil {
		return fmt.Errorf("unable to decode inputMessagePoll#9046c716: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputMessagePoll) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessagePoll#9046c716 to nil")
	}
	{
		if err := i.Question.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputMessagePoll#9046c716: field question: %w", err)
		}
	}
	{
		headerLen, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessagePoll#9046c716: field options: %w", err)
		}

		if headerLen > 0 {
			i.Options = make([]FormattedText, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			var value FormattedText
			if err := value.DecodeBare(b); err != nil {
				return fmt.Errorf("unable to decode bare inputMessagePoll#9046c716: field options: %w", err)
			}
			i.Options = append(i.Options, value)
		}
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessagePoll#9046c716: field is_anonymous: %w", err)
		}
		i.IsAnonymous = value
	}
	{
		value, err := DecodePollType(b)
		if err != nil {
			return fmt.Errorf("unable to decode inputMessagePoll#9046c716: field type: %w", err)
		}
		i.Type = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessagePoll#9046c716: field open_period: %w", err)
		}
		i.OpenPeriod = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessagePoll#9046c716: field close_date: %w", err)
		}
		i.CloseDate = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessagePoll#9046c716: field is_closed: %w", err)
		}
		i.IsClosed = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (i *InputMessagePoll) EncodeTDLibJSON(b tdjson.Encoder) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessagePoll#9046c716 as nil")
	}
	b.ObjStart()
	b.PutID("inputMessagePoll")
	b.Comma()
	b.FieldStart("question")
	if err := i.Question.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode inputMessagePoll#9046c716: field question: %w", err)
	}
	b.Comma()
	b.FieldStart("options")
	b.ArrStart()
	for idx, v := range i.Options {
		if err := v.EncodeTDLibJSON(b); err != nil {
			return fmt.Errorf("unable to encode inputMessagePoll#9046c716: field options element with index %d: %w", idx, err)
		}
		b.Comma()
	}
	b.StripComma()
	b.ArrEnd()
	b.Comma()
	b.FieldStart("is_anonymous")
	b.PutBool(i.IsAnonymous)
	b.Comma()
	b.FieldStart("type")
	if i.Type == nil {
		return fmt.Errorf("unable to encode inputMessagePoll#9046c716: field type is nil")
	}
	if err := i.Type.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode inputMessagePoll#9046c716: field type: %w", err)
	}
	b.Comma()
	b.FieldStart("open_period")
	b.PutInt32(i.OpenPeriod)
	b.Comma()
	b.FieldStart("close_date")
	b.PutInt32(i.CloseDate)
	b.Comma()
	b.FieldStart("is_closed")
	b.PutBool(i.IsClosed)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (i *InputMessagePoll) DecodeTDLibJSON(b tdjson.Decoder) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessagePoll#9046c716 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("inputMessagePoll"); err != nil {
				return fmt.Errorf("unable to decode inputMessagePoll#9046c716: %w", err)
			}
		case "question":
			if err := i.Question.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode inputMessagePoll#9046c716: field question: %w", err)
			}
		case "options":
			if err := b.Arr(func(b tdjson.Decoder) error {
				var value FormattedText
				if err := value.DecodeTDLibJSON(b); err != nil {
					return fmt.Errorf("unable to decode inputMessagePoll#9046c716: field options: %w", err)
				}
				i.Options = append(i.Options, value)
				return nil
			}); err != nil {
				return fmt.Errorf("unable to decode inputMessagePoll#9046c716: field options: %w", err)
			}
		case "is_anonymous":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessagePoll#9046c716: field is_anonymous: %w", err)
			}
			i.IsAnonymous = value
		case "type":
			value, err := DecodeTDLibJSONPollType(b)
			if err != nil {
				return fmt.Errorf("unable to decode inputMessagePoll#9046c716: field type: %w", err)
			}
			i.Type = value
		case "open_period":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessagePoll#9046c716: field open_period: %w", err)
			}
			i.OpenPeriod = value
		case "close_date":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessagePoll#9046c716: field close_date: %w", err)
			}
			i.CloseDate = value
		case "is_closed":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessagePoll#9046c716: field is_closed: %w", err)
			}
			i.IsClosed = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetQuestion returns value of Question field.
func (i *InputMessagePoll) GetQuestion() (value FormattedText) {
	if i == nil {
		return
	}
	return i.Question
}

// GetOptions returns value of Options field.
func (i *InputMessagePoll) GetOptions() (value []FormattedText) {
	if i == nil {
		return
	}
	return i.Options
}

// GetIsAnonymous returns value of IsAnonymous field.
func (i *InputMessagePoll) GetIsAnonymous() (value bool) {
	if i == nil {
		return
	}
	return i.IsAnonymous
}

// GetType returns value of Type field.
func (i *InputMessagePoll) GetType() (value PollTypeClass) {
	if i == nil {
		return
	}
	return i.Type
}

// GetOpenPeriod returns value of OpenPeriod field.
func (i *InputMessagePoll) GetOpenPeriod() (value int32) {
	if i == nil {
		return
	}
	return i.OpenPeriod
}

// GetCloseDate returns value of CloseDate field.
func (i *InputMessagePoll) GetCloseDate() (value int32) {
	if i == nil {
		return
	}
	return i.CloseDate
}

// GetIsClosed returns value of IsClosed field.
func (i *InputMessagePoll) GetIsClosed() (value bool) {
	if i == nil {
		return
	}
	return i.IsClosed
}

// InputMessageStory represents TL type `inputMessageStory#e9e713eb`.
type InputMessageStory struct {
	// Identifier of the chat that posted the story
	StoryPosterChatID int64
	// Story identifier
	StoryID int32
}

// InputMessageStoryTypeID is TL type id of InputMessageStory.
const InputMessageStoryTypeID = 0xe9e713eb

// construct implements constructor of InputMessageContentClass.
func (i InputMessageStory) construct() InputMessageContentClass { return &i }

// Ensuring interfaces in compile-time for InputMessageStory.
var (
	_ bin.Encoder     = &InputMessageStory{}
	_ bin.Decoder     = &InputMessageStory{}
	_ bin.BareEncoder = &InputMessageStory{}
	_ bin.BareDecoder = &InputMessageStory{}

	_ InputMessageContentClass = &InputMessageStory{}
)

func (i *InputMessageStory) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.StoryPosterChatID == 0) {
		return false
	}
	if !(i.StoryID == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputMessageStory) String() string {
	if i == nil {
		return "InputMessageStory(nil)"
	}
	type Alias InputMessageStory
	return fmt.Sprintf("InputMessageStory%+v", Alias(*i))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputMessageStory) TypeID() uint32 {
	return InputMessageStoryTypeID
}

// TypeName returns name of type in TL schema.
func (*InputMessageStory) TypeName() string {
	return "inputMessageStory"
}

// TypeInfo returns info about TL type.
func (i *InputMessageStory) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputMessageStory",
		ID:   InputMessageStoryTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "StoryPosterChatID",
			SchemaName: "story_poster_chat_id",
		},
		{
			Name:       "StoryID",
			SchemaName: "story_id",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (i *InputMessageStory) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageStory#e9e713eb as nil")
	}
	b.PutID(InputMessageStoryTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputMessageStory) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageStory#e9e713eb as nil")
	}
	b.PutInt53(i.StoryPosterChatID)
	b.PutInt32(i.StoryID)
	return nil
}

// Decode implements bin.Decoder.
func (i *InputMessageStory) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageStory#e9e713eb to nil")
	}
	if err := b.ConsumeID(InputMessageStoryTypeID); err != nil {
		return fmt.Errorf("unable to decode inputMessageStory#e9e713eb: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputMessageStory) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageStory#e9e713eb to nil")
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageStory#e9e713eb: field story_poster_chat_id: %w", err)
		}
		i.StoryPosterChatID = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageStory#e9e713eb: field story_id: %w", err)
		}
		i.StoryID = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (i *InputMessageStory) EncodeTDLibJSON(b tdjson.Encoder) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageStory#e9e713eb as nil")
	}
	b.ObjStart()
	b.PutID("inputMessageStory")
	b.Comma()
	b.FieldStart("story_poster_chat_id")
	b.PutInt53(i.StoryPosterChatID)
	b.Comma()
	b.FieldStart("story_id")
	b.PutInt32(i.StoryID)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (i *InputMessageStory) DecodeTDLibJSON(b tdjson.Decoder) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageStory#e9e713eb to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("inputMessageStory"); err != nil {
				return fmt.Errorf("unable to decode inputMessageStory#e9e713eb: %w", err)
			}
		case "story_poster_chat_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageStory#e9e713eb: field story_poster_chat_id: %w", err)
			}
			i.StoryPosterChatID = value
		case "story_id":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageStory#e9e713eb: field story_id: %w", err)
			}
			i.StoryID = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetStoryPosterChatID returns value of StoryPosterChatID field.
func (i *InputMessageStory) GetStoryPosterChatID() (value int64) {
	if i == nil {
		return
	}
	return i.StoryPosterChatID
}

// GetStoryID returns value of StoryID field.
func (i *InputMessageStory) GetStoryID() (value int32) {
	if i == nil {
		return
	}
	return i.StoryID
}

// InputMessageForwarded represents TL type `inputMessageForwarded#bfd5d134`.
type InputMessageForwarded struct {
	// Identifier for the chat this forwarded message came from
	FromChatID int64
	// Identifier of the message to forward. A message can be forwarded only if
	// messageProperties.can_be_forwarded
	MessageID int64
	// Pass true if a game message is being shared from a launched game; applies only to game
	// messages
	InGameShare bool
	// Pass true to replace video start timestamp in the forwarded message
	ReplaceVideoStartTimestamp bool
	// The new video start timestamp; ignored if replace_video_start_timestamp == false
	NewVideoStartTimestamp int32
	// Options to be used to copy content of the message without reference to the original
	// sender; pass null to forward the message as usual
	CopyOptions MessageCopyOptions
}

// InputMessageForwardedTypeID is TL type id of InputMessageForwarded.
const InputMessageForwardedTypeID = 0xbfd5d134

// construct implements constructor of InputMessageContentClass.
func (i InputMessageForwarded) construct() InputMessageContentClass { return &i }

// Ensuring interfaces in compile-time for InputMessageForwarded.
var (
	_ bin.Encoder     = &InputMessageForwarded{}
	_ bin.Decoder     = &InputMessageForwarded{}
	_ bin.BareEncoder = &InputMessageForwarded{}
	_ bin.BareDecoder = &InputMessageForwarded{}

	_ InputMessageContentClass = &InputMessageForwarded{}
)

func (i *InputMessageForwarded) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.FromChatID == 0) {
		return false
	}
	if !(i.MessageID == 0) {
		return false
	}
	if !(i.InGameShare == false) {
		return false
	}
	if !(i.ReplaceVideoStartTimestamp == false) {
		return false
	}
	if !(i.NewVideoStartTimestamp == 0) {
		return false
	}
	if !(i.CopyOptions.Zero()) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputMessageForwarded) String() string {
	if i == nil {
		return "InputMessageForwarded(nil)"
	}
	type Alias InputMessageForwarded
	return fmt.Sprintf("InputMessageForwarded%+v", Alias(*i))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputMessageForwarded) TypeID() uint32 {
	return InputMessageForwardedTypeID
}

// TypeName returns name of type in TL schema.
func (*InputMessageForwarded) TypeName() string {
	return "inputMessageForwarded"
}

// TypeInfo returns info about TL type.
func (i *InputMessageForwarded) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputMessageForwarded",
		ID:   InputMessageForwardedTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "FromChatID",
			SchemaName: "from_chat_id",
		},
		{
			Name:       "MessageID",
			SchemaName: "message_id",
		},
		{
			Name:       "InGameShare",
			SchemaName: "in_game_share",
		},
		{
			Name:       "ReplaceVideoStartTimestamp",
			SchemaName: "replace_video_start_timestamp",
		},
		{
			Name:       "NewVideoStartTimestamp",
			SchemaName: "new_video_start_timestamp",
		},
		{
			Name:       "CopyOptions",
			SchemaName: "copy_options",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (i *InputMessageForwarded) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageForwarded#bfd5d134 as nil")
	}
	b.PutID(InputMessageForwardedTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputMessageForwarded) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageForwarded#bfd5d134 as nil")
	}
	b.PutInt53(i.FromChatID)
	b.PutInt53(i.MessageID)
	b.PutBool(i.InGameShare)
	b.PutBool(i.ReplaceVideoStartTimestamp)
	b.PutInt32(i.NewVideoStartTimestamp)
	if err := i.CopyOptions.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageForwarded#bfd5d134: field copy_options: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (i *InputMessageForwarded) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageForwarded#bfd5d134 to nil")
	}
	if err := b.ConsumeID(InputMessageForwardedTypeID); err != nil {
		return fmt.Errorf("unable to decode inputMessageForwarded#bfd5d134: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputMessageForwarded) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageForwarded#bfd5d134 to nil")
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageForwarded#bfd5d134: field from_chat_id: %w", err)
		}
		i.FromChatID = value
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageForwarded#bfd5d134: field message_id: %w", err)
		}
		i.MessageID = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageForwarded#bfd5d134: field in_game_share: %w", err)
		}
		i.InGameShare = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageForwarded#bfd5d134: field replace_video_start_timestamp: %w", err)
		}
		i.ReplaceVideoStartTimestamp = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode inputMessageForwarded#bfd5d134: field new_video_start_timestamp: %w", err)
		}
		i.NewVideoStartTimestamp = value
	}
	{
		if err := i.CopyOptions.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputMessageForwarded#bfd5d134: field copy_options: %w", err)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (i *InputMessageForwarded) EncodeTDLibJSON(b tdjson.Encoder) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMessageForwarded#bfd5d134 as nil")
	}
	b.ObjStart()
	b.PutID("inputMessageForwarded")
	b.Comma()
	b.FieldStart("from_chat_id")
	b.PutInt53(i.FromChatID)
	b.Comma()
	b.FieldStart("message_id")
	b.PutInt53(i.MessageID)
	b.Comma()
	b.FieldStart("in_game_share")
	b.PutBool(i.InGameShare)
	b.Comma()
	b.FieldStart("replace_video_start_timestamp")
	b.PutBool(i.ReplaceVideoStartTimestamp)
	b.Comma()
	b.FieldStart("new_video_start_timestamp")
	b.PutInt32(i.NewVideoStartTimestamp)
	b.Comma()
	b.FieldStart("copy_options")
	if err := i.CopyOptions.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode inputMessageForwarded#bfd5d134: field copy_options: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (i *InputMessageForwarded) DecodeTDLibJSON(b tdjson.Decoder) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMessageForwarded#bfd5d134 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("inputMessageForwarded"); err != nil {
				return fmt.Errorf("unable to decode inputMessageForwarded#bfd5d134: %w", err)
			}
		case "from_chat_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageForwarded#bfd5d134: field from_chat_id: %w", err)
			}
			i.FromChatID = value
		case "message_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageForwarded#bfd5d134: field message_id: %w", err)
			}
			i.MessageID = value
		case "in_game_share":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageForwarded#bfd5d134: field in_game_share: %w", err)
			}
			i.InGameShare = value
		case "replace_video_start_timestamp":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageForwarded#bfd5d134: field replace_video_start_timestamp: %w", err)
			}
			i.ReplaceVideoStartTimestamp = value
		case "new_video_start_timestamp":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode inputMessageForwarded#bfd5d134: field new_video_start_timestamp: %w", err)
			}
			i.NewVideoStartTimestamp = value
		case "copy_options":
			if err := i.CopyOptions.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode inputMessageForwarded#bfd5d134: field copy_options: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetFromChatID returns value of FromChatID field.
func (i *InputMessageForwarded) GetFromChatID() (value int64) {
	if i == nil {
		return
	}
	return i.FromChatID
}

// GetMessageID returns value of MessageID field.
func (i *InputMessageForwarded) GetMessageID() (value int64) {
	if i == nil {
		return
	}
	return i.MessageID
}

// GetInGameShare returns value of InGameShare field.
func (i *InputMessageForwarded) GetInGameShare() (value bool) {
	if i == nil {
		return
	}
	return i.InGameShare
}

// GetReplaceVideoStartTimestamp returns value of ReplaceVideoStartTimestamp field.
func (i *InputMessageForwarded) GetReplaceVideoStartTimestamp() (value bool) {
	if i == nil {
		return
	}
	return i.ReplaceVideoStartTimestamp
}

// GetNewVideoStartTimestamp returns value of NewVideoStartTimestamp field.
func (i *InputMessageForwarded) GetNewVideoStartTimestamp() (value int32) {
	if i == nil {
		return
	}
	return i.NewVideoStartTimestamp
}

// GetCopyOptions returns value of CopyOptions field.
func (i *InputMessageForwarded) GetCopyOptions() (value MessageCopyOptions) {
	if i == nil {
		return
	}
	return i.CopyOptions
}

// InputMessageContentClassName is schema name of InputMessageContentClass.
const InputMessageContentClassName = "InputMessageContent"

// InputMessageContentClass represents InputMessageContent generic type.
//
// Example:
//
//	g, err := tdapi.DecodeInputMessageContent(buf)
//	if err != nil {
//	    panic(err)
//	}
//	switch v := g.(type) {
//	case *tdapi.InputMessageText: // inputMessageText#f350d894
//	case *tdapi.InputMessageAnimation: // inputMessageAnimation#19fe563
//	case *tdapi.InputMessageAudio: // inputMessageAudio#daa400b2
//	case *tdapi.InputMessageDocument: // inputMessageDocument#615b72b9
//	case *tdapi.InputMessagePaidMedia: // inputMessagePaidMedia#370c4490
//	case *tdapi.InputMessagePhoto: // inputMessagePhoto#bc78dbcc
//	case *tdapi.InputMessageSticker: // inputMessageSticker#3ff1b6f9
//	case *tdapi.InputMessageVideo: // inputMessageVideo#74f09b52
//	case *tdapi.InputMessageVideoNote: // inputMessageVideoNote#d56816dd
//	case *tdapi.InputMessageVoiceNote: // inputMessageVoiceNote#5723ffac
//	case *tdapi.InputMessageLocation: // inputMessageLocation#26aae970
//	case *tdapi.InputMessageVenue: // inputMessageVenue#564d99fd
//	case *tdapi.InputMessageContact: // inputMessageContact#c5710cff
//	case *tdapi.InputMessageDice: // inputMessageDice#322967a9
//	case *tdapi.InputMessageGame: // inputMessageGame#4aae6ae2
//	case *tdapi.InputMessageInvoice: // inputMessageInvoice#babc8f71
//	case *tdapi.InputMessagePoll: // inputMessagePoll#9046c716
//	case *tdapi.InputMessageStory: // inputMessageStory#e9e713eb
//	case *tdapi.InputMessageForwarded: // inputMessageForwarded#bfd5d134
//	default: panic(v)
//	}
type InputMessageContentClass interface {
	bin.Encoder
	bin.Decoder
	bin.BareEncoder
	bin.BareDecoder
	construct() InputMessageContentClass

	// TypeID returns type id in TL schema.
	//
	// See https://core.telegram.org/mtproto/TL-tl#remarks.
	TypeID() uint32
	// TypeName returns name of type in TL schema.
	TypeName() string
	// String implements fmt.Stringer.
	String() string
	// Zero returns true if current object has a zero value.
	Zero() bool

	EncodeTDLibJSON(b tdjson.Encoder) error
	DecodeTDLibJSON(b tdjson.Decoder) error
}

// DecodeInputMessageContent implements binary de-serialization for InputMessageContentClass.
func DecodeInputMessageContent(buf *bin.Buffer) (InputMessageContentClass, error) {
	id, err := buf.PeekID()
	if err != nil {
		return nil, err
	}
	switch id {
	case InputMessageTextTypeID:
		// Decoding inputMessageText#f350d894.
		v := InputMessageText{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMessageContentClass: %w", err)
		}
		return &v, nil
	case InputMessageAnimationTypeID:
		// Decoding inputMessageAnimation#19fe563.
		v := InputMessageAnimation{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMessageContentClass: %w", err)
		}
		return &v, nil
	case InputMessageAudioTypeID:
		// Decoding inputMessageAudio#daa400b2.
		v := InputMessageAudio{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMessageContentClass: %w", err)
		}
		return &v, nil
	case InputMessageDocumentTypeID:
		// Decoding inputMessageDocument#615b72b9.
		v := InputMessageDocument{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMessageContentClass: %w", err)
		}
		return &v, nil
	case InputMessagePaidMediaTypeID:
		// Decoding inputMessagePaidMedia#370c4490.
		v := InputMessagePaidMedia{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMessageContentClass: %w", err)
		}
		return &v, nil
	case InputMessagePhotoTypeID:
		// Decoding inputMessagePhoto#bc78dbcc.
		v := InputMessagePhoto{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMessageContentClass: %w", err)
		}
		return &v, nil
	case InputMessageStickerTypeID:
		// Decoding inputMessageSticker#3ff1b6f9.
		v := InputMessageSticker{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMessageContentClass: %w", err)
		}
		return &v, nil
	case InputMessageVideoTypeID:
		// Decoding inputMessageVideo#74f09b52.
		v := InputMessageVideo{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMessageContentClass: %w", err)
		}
		return &v, nil
	case InputMessageVideoNoteTypeID:
		// Decoding inputMessageVideoNote#d56816dd.
		v := InputMessageVideoNote{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMessageContentClass: %w", err)
		}
		return &v, nil
	case InputMessageVoiceNoteTypeID:
		// Decoding inputMessageVoiceNote#5723ffac.
		v := InputMessageVoiceNote{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMessageContentClass: %w", err)
		}
		return &v, nil
	case InputMessageLocationTypeID:
		// Decoding inputMessageLocation#26aae970.
		v := InputMessageLocation{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMessageContentClass: %w", err)
		}
		return &v, nil
	case InputMessageVenueTypeID:
		// Decoding inputMessageVenue#564d99fd.
		v := InputMessageVenue{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMessageContentClass: %w", err)
		}
		return &v, nil
	case InputMessageContactTypeID:
		// Decoding inputMessageContact#c5710cff.
		v := InputMessageContact{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMessageContentClass: %w", err)
		}
		return &v, nil
	case InputMessageDiceTypeID:
		// Decoding inputMessageDice#322967a9.
		v := InputMessageDice{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMessageContentClass: %w", err)
		}
		return &v, nil
	case InputMessageGameTypeID:
		// Decoding inputMessageGame#4aae6ae2.
		v := InputMessageGame{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMessageContentClass: %w", err)
		}
		return &v, nil
	case InputMessageInvoiceTypeID:
		// Decoding inputMessageInvoice#babc8f71.
		v := InputMessageInvoice{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMessageContentClass: %w", err)
		}
		return &v, nil
	case InputMessagePollTypeID:
		// Decoding inputMessagePoll#9046c716.
		v := InputMessagePoll{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMessageContentClass: %w", err)
		}
		return &v, nil
	case InputMessageStoryTypeID:
		// Decoding inputMessageStory#e9e713eb.
		v := InputMessageStory{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMessageContentClass: %w", err)
		}
		return &v, nil
	case InputMessageForwardedTypeID:
		// Decoding inputMessageForwarded#bfd5d134.
		v := InputMessageForwarded{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMessageContentClass: %w", err)
		}
		return &v, nil
	default:
		return nil, fmt.Errorf("unable to decode InputMessageContentClass: %w", bin.NewUnexpectedID(id))
	}
}

// DecodeTDLibJSONInputMessageContent implements binary de-serialization for InputMessageContentClass.
func DecodeTDLibJSONInputMessageContent(buf tdjson.Decoder) (InputMessageContentClass, error) {
	id, err := buf.FindTypeID()
	if err != nil {
		return nil, err
	}
	switch id {
	case "inputMessageText":
		// Decoding inputMessageText#f350d894.
		v := InputMessageText{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMessageContentClass: %w", err)
		}
		return &v, nil
	case "inputMessageAnimation":
		// Decoding inputMessageAnimation#19fe563.
		v := InputMessageAnimation{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMessageContentClass: %w", err)
		}
		return &v, nil
	case "inputMessageAudio":
		// Decoding inputMessageAudio#daa400b2.
		v := InputMessageAudio{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMessageContentClass: %w", err)
		}
		return &v, nil
	case "inputMessageDocument":
		// Decoding inputMessageDocument#615b72b9.
		v := InputMessageDocument{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMessageContentClass: %w", err)
		}
		return &v, nil
	case "inputMessagePaidMedia":
		// Decoding inputMessagePaidMedia#370c4490.
		v := InputMessagePaidMedia{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMessageContentClass: %w", err)
		}
		return &v, nil
	case "inputMessagePhoto":
		// Decoding inputMessagePhoto#bc78dbcc.
		v := InputMessagePhoto{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMessageContentClass: %w", err)
		}
		return &v, nil
	case "inputMessageSticker":
		// Decoding inputMessageSticker#3ff1b6f9.
		v := InputMessageSticker{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMessageContentClass: %w", err)
		}
		return &v, nil
	case "inputMessageVideo":
		// Decoding inputMessageVideo#74f09b52.
		v := InputMessageVideo{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMessageContentClass: %w", err)
		}
		return &v, nil
	case "inputMessageVideoNote":
		// Decoding inputMessageVideoNote#d56816dd.
		v := InputMessageVideoNote{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMessageContentClass: %w", err)
		}
		return &v, nil
	case "inputMessageVoiceNote":
		// Decoding inputMessageVoiceNote#5723ffac.
		v := InputMessageVoiceNote{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMessageContentClass: %w", err)
		}
		return &v, nil
	case "inputMessageLocation":
		// Decoding inputMessageLocation#26aae970.
		v := InputMessageLocation{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMessageContentClass: %w", err)
		}
		return &v, nil
	case "inputMessageVenue":
		// Decoding inputMessageVenue#564d99fd.
		v := InputMessageVenue{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMessageContentClass: %w", err)
		}
		return &v, nil
	case "inputMessageContact":
		// Decoding inputMessageContact#c5710cff.
		v := InputMessageContact{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMessageContentClass: %w", err)
		}
		return &v, nil
	case "inputMessageDice":
		// Decoding inputMessageDice#322967a9.
		v := InputMessageDice{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMessageContentClass: %w", err)
		}
		return &v, nil
	case "inputMessageGame":
		// Decoding inputMessageGame#4aae6ae2.
		v := InputMessageGame{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMessageContentClass: %w", err)
		}
		return &v, nil
	case "inputMessageInvoice":
		// Decoding inputMessageInvoice#babc8f71.
		v := InputMessageInvoice{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMessageContentClass: %w", err)
		}
		return &v, nil
	case "inputMessagePoll":
		// Decoding inputMessagePoll#9046c716.
		v := InputMessagePoll{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMessageContentClass: %w", err)
		}
		return &v, nil
	case "inputMessageStory":
		// Decoding inputMessageStory#e9e713eb.
		v := InputMessageStory{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMessageContentClass: %w", err)
		}
		return &v, nil
	case "inputMessageForwarded":
		// Decoding inputMessageForwarded#bfd5d134.
		v := InputMessageForwarded{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMessageContentClass: %w", err)
		}
		return &v, nil
	default:
		return nil, fmt.Errorf("unable to decode InputMessageContentClass: %w", tdjson.NewUnexpectedID(id))
	}
}

// InputMessageContent boxes the InputMessageContentClass providing a helper.
type InputMessageContentBox struct {
	InputMessageContent InputMessageContentClass
}

// Decode implements bin.Decoder for InputMessageContentBox.
func (b *InputMessageContentBox) Decode(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("unable to decode InputMessageContentBox to nil")
	}
	v, err := DecodeInputMessageContent(buf)
	if err != nil {
		return fmt.Errorf("unable to decode boxed value: %w", err)
	}
	b.InputMessageContent = v
	return nil
}

// Encode implements bin.Encode for InputMessageContentBox.
func (b *InputMessageContentBox) Encode(buf *bin.Buffer) error {
	if b == nil || b.InputMessageContent == nil {
		return fmt.Errorf("unable to encode InputMessageContentClass as nil")
	}
	return b.InputMessageContent.Encode(buf)
}

// DecodeTDLibJSON implements bin.Decoder for InputMessageContentBox.
func (b *InputMessageContentBox) DecodeTDLibJSON(buf tdjson.Decoder) error {
	if b == nil {
		return fmt.Errorf("unable to decode InputMessageContentBox to nil")
	}
	v, err := DecodeTDLibJSONInputMessageContent(buf)
	if err != nil {
		return fmt.Errorf("unable to decode boxed value: %w", err)
	}
	b.InputMessageContent = v
	return nil
}

// EncodeTDLibJSON implements bin.Encode for InputMessageContentBox.
func (b *InputMessageContentBox) EncodeTDLibJSON(buf tdjson.Encoder) error {
	if b == nil || b.InputMessageContent == nil {
		return fmt.Errorf("unable to encode InputMessageContentClass as nil")
	}
	return b.InputMessageContent.EncodeTDLibJSON(buf)
}
