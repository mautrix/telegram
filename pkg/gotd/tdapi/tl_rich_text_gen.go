// Code generated by gotdgen, DO NOT EDIT.

package tdapi

import (
	"context"
	"errors"
	"fmt"
	"sort"
	"strings"

	"go.uber.org/multierr"

	"go.mau.fi/mautrix-telegram/pkg/gotd/bin"
	"go.mau.fi/mautrix-telegram/pkg/gotd/tdjson"
	"go.mau.fi/mautrix-telegram/pkg/gotd/tdp"
	"go.mau.fi/mautrix-telegram/pkg/gotd/tgerr"
)

// No-op definition for keeping imports.
var (
	_ = bin.Buffer{}
	_ = context.Background()
	_ = fmt.Stringer(nil)
	_ = strings.Builder{}
	_ = errors.Is
	_ = multierr.AppendInto
	_ = sort.Ints
	_ = tdp.Format
	_ = tgerr.Error{}
	_ = tdjson.Encoder{}
)

// RichTextPlain represents TL type `richTextPlain#1cc42966`.
type RichTextPlain struct {
	// Text
	Text string
}

// RichTextPlainTypeID is TL type id of RichTextPlain.
const RichTextPlainTypeID = 0x1cc42966

// construct implements constructor of RichTextClass.
func (r RichTextPlain) construct() RichTextClass { return &r }

// Ensuring interfaces in compile-time for RichTextPlain.
var (
	_ bin.Encoder     = &RichTextPlain{}
	_ bin.Decoder     = &RichTextPlain{}
	_ bin.BareEncoder = &RichTextPlain{}
	_ bin.BareDecoder = &RichTextPlain{}

	_ RichTextClass = &RichTextPlain{}
)

func (r *RichTextPlain) Zero() bool {
	if r == nil {
		return true
	}
	if !(r.Text == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (r *RichTextPlain) String() string {
	if r == nil {
		return "RichTextPlain(nil)"
	}
	type Alias RichTextPlain
	return fmt.Sprintf("RichTextPlain%+v", Alias(*r))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*RichTextPlain) TypeID() uint32 {
	return RichTextPlainTypeID
}

// TypeName returns name of type in TL schema.
func (*RichTextPlain) TypeName() string {
	return "richTextPlain"
}

// TypeInfo returns info about TL type.
func (r *RichTextPlain) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "richTextPlain",
		ID:   RichTextPlainTypeID,
	}
	if r == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Text",
			SchemaName: "text",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (r *RichTextPlain) Encode(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't encode richTextPlain#1cc42966 as nil")
	}
	b.PutID(RichTextPlainTypeID)
	return r.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (r *RichTextPlain) EncodeBare(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't encode richTextPlain#1cc42966 as nil")
	}
	b.PutString(r.Text)
	return nil
}

// Decode implements bin.Decoder.
func (r *RichTextPlain) Decode(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't decode richTextPlain#1cc42966 to nil")
	}
	if err := b.ConsumeID(RichTextPlainTypeID); err != nil {
		return fmt.Errorf("unable to decode richTextPlain#1cc42966: %w", err)
	}
	return r.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (r *RichTextPlain) DecodeBare(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't decode richTextPlain#1cc42966 to nil")
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode richTextPlain#1cc42966: field text: %w", err)
		}
		r.Text = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (r *RichTextPlain) EncodeTDLibJSON(b tdjson.Encoder) error {
	if r == nil {
		return fmt.Errorf("can't encode richTextPlain#1cc42966 as nil")
	}
	b.ObjStart()
	b.PutID("richTextPlain")
	b.Comma()
	b.FieldStart("text")
	b.PutString(r.Text)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (r *RichTextPlain) DecodeTDLibJSON(b tdjson.Decoder) error {
	if r == nil {
		return fmt.Errorf("can't decode richTextPlain#1cc42966 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("richTextPlain"); err != nil {
				return fmt.Errorf("unable to decode richTextPlain#1cc42966: %w", err)
			}
		case "text":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode richTextPlain#1cc42966: field text: %w", err)
			}
			r.Text = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetText returns value of Text field.
func (r *RichTextPlain) GetText() (value string) {
	if r == nil {
		return
	}
	return r.Text
}

// RichTextBold represents TL type `richTextBold#63970f6c`.
type RichTextBold struct {
	// Text
	Text RichTextClass
}

// RichTextBoldTypeID is TL type id of RichTextBold.
const RichTextBoldTypeID = 0x63970f6c

// construct implements constructor of RichTextClass.
func (r RichTextBold) construct() RichTextClass { return &r }

// Ensuring interfaces in compile-time for RichTextBold.
var (
	_ bin.Encoder     = &RichTextBold{}
	_ bin.Decoder     = &RichTextBold{}
	_ bin.BareEncoder = &RichTextBold{}
	_ bin.BareDecoder = &RichTextBold{}

	_ RichTextClass = &RichTextBold{}
)

func (r *RichTextBold) Zero() bool {
	if r == nil {
		return true
	}
	if !(r.Text == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (r *RichTextBold) String() string {
	if r == nil {
		return "RichTextBold(nil)"
	}
	type Alias RichTextBold
	return fmt.Sprintf("RichTextBold%+v", Alias(*r))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*RichTextBold) TypeID() uint32 {
	return RichTextBoldTypeID
}

// TypeName returns name of type in TL schema.
func (*RichTextBold) TypeName() string {
	return "richTextBold"
}

// TypeInfo returns info about TL type.
func (r *RichTextBold) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "richTextBold",
		ID:   RichTextBoldTypeID,
	}
	if r == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Text",
			SchemaName: "text",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (r *RichTextBold) Encode(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't encode richTextBold#63970f6c as nil")
	}
	b.PutID(RichTextBoldTypeID)
	return r.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (r *RichTextBold) EncodeBare(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't encode richTextBold#63970f6c as nil")
	}
	if r.Text == nil {
		return fmt.Errorf("unable to encode richTextBold#63970f6c: field text is nil")
	}
	if err := r.Text.Encode(b); err != nil {
		return fmt.Errorf("unable to encode richTextBold#63970f6c: field text: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (r *RichTextBold) Decode(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't decode richTextBold#63970f6c to nil")
	}
	if err := b.ConsumeID(RichTextBoldTypeID); err != nil {
		return fmt.Errorf("unable to decode richTextBold#63970f6c: %w", err)
	}
	return r.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (r *RichTextBold) DecodeBare(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't decode richTextBold#63970f6c to nil")
	}
	{
		value, err := DecodeRichText(b)
		if err != nil {
			return fmt.Errorf("unable to decode richTextBold#63970f6c: field text: %w", err)
		}
		r.Text = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (r *RichTextBold) EncodeTDLibJSON(b tdjson.Encoder) error {
	if r == nil {
		return fmt.Errorf("can't encode richTextBold#63970f6c as nil")
	}
	b.ObjStart()
	b.PutID("richTextBold")
	b.Comma()
	b.FieldStart("text")
	if r.Text == nil {
		return fmt.Errorf("unable to encode richTextBold#63970f6c: field text is nil")
	}
	if err := r.Text.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode richTextBold#63970f6c: field text: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (r *RichTextBold) DecodeTDLibJSON(b tdjson.Decoder) error {
	if r == nil {
		return fmt.Errorf("can't decode richTextBold#63970f6c to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("richTextBold"); err != nil {
				return fmt.Errorf("unable to decode richTextBold#63970f6c: %w", err)
			}
		case "text":
			value, err := DecodeTDLibJSONRichText(b)
			if err != nil {
				return fmt.Errorf("unable to decode richTextBold#63970f6c: field text: %w", err)
			}
			r.Text = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetText returns value of Text field.
func (r *RichTextBold) GetText() (value RichTextClass) {
	if r == nil {
		return
	}
	return r.Text
}

// RichTextItalic represents TL type `richTextItalic#6e77f03f`.
type RichTextItalic struct {
	// Text
	Text RichTextClass
}

// RichTextItalicTypeID is TL type id of RichTextItalic.
const RichTextItalicTypeID = 0x6e77f03f

// construct implements constructor of RichTextClass.
func (r RichTextItalic) construct() RichTextClass { return &r }

// Ensuring interfaces in compile-time for RichTextItalic.
var (
	_ bin.Encoder     = &RichTextItalic{}
	_ bin.Decoder     = &RichTextItalic{}
	_ bin.BareEncoder = &RichTextItalic{}
	_ bin.BareDecoder = &RichTextItalic{}

	_ RichTextClass = &RichTextItalic{}
)

func (r *RichTextItalic) Zero() bool {
	if r == nil {
		return true
	}
	if !(r.Text == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (r *RichTextItalic) String() string {
	if r == nil {
		return "RichTextItalic(nil)"
	}
	type Alias RichTextItalic
	return fmt.Sprintf("RichTextItalic%+v", Alias(*r))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*RichTextItalic) TypeID() uint32 {
	return RichTextItalicTypeID
}

// TypeName returns name of type in TL schema.
func (*RichTextItalic) TypeName() string {
	return "richTextItalic"
}

// TypeInfo returns info about TL type.
func (r *RichTextItalic) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "richTextItalic",
		ID:   RichTextItalicTypeID,
	}
	if r == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Text",
			SchemaName: "text",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (r *RichTextItalic) Encode(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't encode richTextItalic#6e77f03f as nil")
	}
	b.PutID(RichTextItalicTypeID)
	return r.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (r *RichTextItalic) EncodeBare(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't encode richTextItalic#6e77f03f as nil")
	}
	if r.Text == nil {
		return fmt.Errorf("unable to encode richTextItalic#6e77f03f: field text is nil")
	}
	if err := r.Text.Encode(b); err != nil {
		return fmt.Errorf("unable to encode richTextItalic#6e77f03f: field text: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (r *RichTextItalic) Decode(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't decode richTextItalic#6e77f03f to nil")
	}
	if err := b.ConsumeID(RichTextItalicTypeID); err != nil {
		return fmt.Errorf("unable to decode richTextItalic#6e77f03f: %w", err)
	}
	return r.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (r *RichTextItalic) DecodeBare(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't decode richTextItalic#6e77f03f to nil")
	}
	{
		value, err := DecodeRichText(b)
		if err != nil {
			return fmt.Errorf("unable to decode richTextItalic#6e77f03f: field text: %w", err)
		}
		r.Text = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (r *RichTextItalic) EncodeTDLibJSON(b tdjson.Encoder) error {
	if r == nil {
		return fmt.Errorf("can't encode richTextItalic#6e77f03f as nil")
	}
	b.ObjStart()
	b.PutID("richTextItalic")
	b.Comma()
	b.FieldStart("text")
	if r.Text == nil {
		return fmt.Errorf("unable to encode richTextItalic#6e77f03f: field text is nil")
	}
	if err := r.Text.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode richTextItalic#6e77f03f: field text: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (r *RichTextItalic) DecodeTDLibJSON(b tdjson.Decoder) error {
	if r == nil {
		return fmt.Errorf("can't decode richTextItalic#6e77f03f to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("richTextItalic"); err != nil {
				return fmt.Errorf("unable to decode richTextItalic#6e77f03f: %w", err)
			}
		case "text":
			value, err := DecodeTDLibJSONRichText(b)
			if err != nil {
				return fmt.Errorf("unable to decode richTextItalic#6e77f03f: field text: %w", err)
			}
			r.Text = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetText returns value of Text field.
func (r *RichTextItalic) GetText() (value RichTextClass) {
	if r == nil {
		return
	}
	return r.Text
}

// RichTextUnderline represents TL type `richTextUnderline#e00cfd8c`.
type RichTextUnderline struct {
	// Text
	Text RichTextClass
}

// RichTextUnderlineTypeID is TL type id of RichTextUnderline.
const RichTextUnderlineTypeID = 0xe00cfd8c

// construct implements constructor of RichTextClass.
func (r RichTextUnderline) construct() RichTextClass { return &r }

// Ensuring interfaces in compile-time for RichTextUnderline.
var (
	_ bin.Encoder     = &RichTextUnderline{}
	_ bin.Decoder     = &RichTextUnderline{}
	_ bin.BareEncoder = &RichTextUnderline{}
	_ bin.BareDecoder = &RichTextUnderline{}

	_ RichTextClass = &RichTextUnderline{}
)

func (r *RichTextUnderline) Zero() bool {
	if r == nil {
		return true
	}
	if !(r.Text == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (r *RichTextUnderline) String() string {
	if r == nil {
		return "RichTextUnderline(nil)"
	}
	type Alias RichTextUnderline
	return fmt.Sprintf("RichTextUnderline%+v", Alias(*r))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*RichTextUnderline) TypeID() uint32 {
	return RichTextUnderlineTypeID
}

// TypeName returns name of type in TL schema.
func (*RichTextUnderline) TypeName() string {
	return "richTextUnderline"
}

// TypeInfo returns info about TL type.
func (r *RichTextUnderline) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "richTextUnderline",
		ID:   RichTextUnderlineTypeID,
	}
	if r == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Text",
			SchemaName: "text",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (r *RichTextUnderline) Encode(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't encode richTextUnderline#e00cfd8c as nil")
	}
	b.PutID(RichTextUnderlineTypeID)
	return r.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (r *RichTextUnderline) EncodeBare(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't encode richTextUnderline#e00cfd8c as nil")
	}
	if r.Text == nil {
		return fmt.Errorf("unable to encode richTextUnderline#e00cfd8c: field text is nil")
	}
	if err := r.Text.Encode(b); err != nil {
		return fmt.Errorf("unable to encode richTextUnderline#e00cfd8c: field text: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (r *RichTextUnderline) Decode(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't decode richTextUnderline#e00cfd8c to nil")
	}
	if err := b.ConsumeID(RichTextUnderlineTypeID); err != nil {
		return fmt.Errorf("unable to decode richTextUnderline#e00cfd8c: %w", err)
	}
	return r.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (r *RichTextUnderline) DecodeBare(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't decode richTextUnderline#e00cfd8c to nil")
	}
	{
		value, err := DecodeRichText(b)
		if err != nil {
			return fmt.Errorf("unable to decode richTextUnderline#e00cfd8c: field text: %w", err)
		}
		r.Text = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (r *RichTextUnderline) EncodeTDLibJSON(b tdjson.Encoder) error {
	if r == nil {
		return fmt.Errorf("can't encode richTextUnderline#e00cfd8c as nil")
	}
	b.ObjStart()
	b.PutID("richTextUnderline")
	b.Comma()
	b.FieldStart("text")
	if r.Text == nil {
		return fmt.Errorf("unable to encode richTextUnderline#e00cfd8c: field text is nil")
	}
	if err := r.Text.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode richTextUnderline#e00cfd8c: field text: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (r *RichTextUnderline) DecodeTDLibJSON(b tdjson.Decoder) error {
	if r == nil {
		return fmt.Errorf("can't decode richTextUnderline#e00cfd8c to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("richTextUnderline"); err != nil {
				return fmt.Errorf("unable to decode richTextUnderline#e00cfd8c: %w", err)
			}
		case "text":
			value, err := DecodeTDLibJSONRichText(b)
			if err != nil {
				return fmt.Errorf("unable to decode richTextUnderline#e00cfd8c: field text: %w", err)
			}
			r.Text = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetText returns value of Text field.
func (r *RichTextUnderline) GetText() (value RichTextClass) {
	if r == nil {
		return
	}
	return r.Text
}

// RichTextStrikethrough represents TL type `richTextStrikethrough#2b1e6a51`.
type RichTextStrikethrough struct {
	// Text
	Text RichTextClass
}

// RichTextStrikethroughTypeID is TL type id of RichTextStrikethrough.
const RichTextStrikethroughTypeID = 0x2b1e6a51

// construct implements constructor of RichTextClass.
func (r RichTextStrikethrough) construct() RichTextClass { return &r }

// Ensuring interfaces in compile-time for RichTextStrikethrough.
var (
	_ bin.Encoder     = &RichTextStrikethrough{}
	_ bin.Decoder     = &RichTextStrikethrough{}
	_ bin.BareEncoder = &RichTextStrikethrough{}
	_ bin.BareDecoder = &RichTextStrikethrough{}

	_ RichTextClass = &RichTextStrikethrough{}
)

func (r *RichTextStrikethrough) Zero() bool {
	if r == nil {
		return true
	}
	if !(r.Text == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (r *RichTextStrikethrough) String() string {
	if r == nil {
		return "RichTextStrikethrough(nil)"
	}
	type Alias RichTextStrikethrough
	return fmt.Sprintf("RichTextStrikethrough%+v", Alias(*r))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*RichTextStrikethrough) TypeID() uint32 {
	return RichTextStrikethroughTypeID
}

// TypeName returns name of type in TL schema.
func (*RichTextStrikethrough) TypeName() string {
	return "richTextStrikethrough"
}

// TypeInfo returns info about TL type.
func (r *RichTextStrikethrough) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "richTextStrikethrough",
		ID:   RichTextStrikethroughTypeID,
	}
	if r == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Text",
			SchemaName: "text",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (r *RichTextStrikethrough) Encode(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't encode richTextStrikethrough#2b1e6a51 as nil")
	}
	b.PutID(RichTextStrikethroughTypeID)
	return r.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (r *RichTextStrikethrough) EncodeBare(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't encode richTextStrikethrough#2b1e6a51 as nil")
	}
	if r.Text == nil {
		return fmt.Errorf("unable to encode richTextStrikethrough#2b1e6a51: field text is nil")
	}
	if err := r.Text.Encode(b); err != nil {
		return fmt.Errorf("unable to encode richTextStrikethrough#2b1e6a51: field text: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (r *RichTextStrikethrough) Decode(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't decode richTextStrikethrough#2b1e6a51 to nil")
	}
	if err := b.ConsumeID(RichTextStrikethroughTypeID); err != nil {
		return fmt.Errorf("unable to decode richTextStrikethrough#2b1e6a51: %w", err)
	}
	return r.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (r *RichTextStrikethrough) DecodeBare(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't decode richTextStrikethrough#2b1e6a51 to nil")
	}
	{
		value, err := DecodeRichText(b)
		if err != nil {
			return fmt.Errorf("unable to decode richTextStrikethrough#2b1e6a51: field text: %w", err)
		}
		r.Text = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (r *RichTextStrikethrough) EncodeTDLibJSON(b tdjson.Encoder) error {
	if r == nil {
		return fmt.Errorf("can't encode richTextStrikethrough#2b1e6a51 as nil")
	}
	b.ObjStart()
	b.PutID("richTextStrikethrough")
	b.Comma()
	b.FieldStart("text")
	if r.Text == nil {
		return fmt.Errorf("unable to encode richTextStrikethrough#2b1e6a51: field text is nil")
	}
	if err := r.Text.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode richTextStrikethrough#2b1e6a51: field text: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (r *RichTextStrikethrough) DecodeTDLibJSON(b tdjson.Decoder) error {
	if r == nil {
		return fmt.Errorf("can't decode richTextStrikethrough#2b1e6a51 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("richTextStrikethrough"); err != nil {
				return fmt.Errorf("unable to decode richTextStrikethrough#2b1e6a51: %w", err)
			}
		case "text":
			value, err := DecodeTDLibJSONRichText(b)
			if err != nil {
				return fmt.Errorf("unable to decode richTextStrikethrough#2b1e6a51: field text: %w", err)
			}
			r.Text = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetText returns value of Text field.
func (r *RichTextStrikethrough) GetText() (value RichTextClass) {
	if r == nil {
		return
	}
	return r.Text
}

// RichTextFixed represents TL type `richTextFixed#b43681c7`.
type RichTextFixed struct {
	// Text
	Text RichTextClass
}

// RichTextFixedTypeID is TL type id of RichTextFixed.
const RichTextFixedTypeID = 0xb43681c7

// construct implements constructor of RichTextClass.
func (r RichTextFixed) construct() RichTextClass { return &r }

// Ensuring interfaces in compile-time for RichTextFixed.
var (
	_ bin.Encoder     = &RichTextFixed{}
	_ bin.Decoder     = &RichTextFixed{}
	_ bin.BareEncoder = &RichTextFixed{}
	_ bin.BareDecoder = &RichTextFixed{}

	_ RichTextClass = &RichTextFixed{}
)

func (r *RichTextFixed) Zero() bool {
	if r == nil {
		return true
	}
	if !(r.Text == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (r *RichTextFixed) String() string {
	if r == nil {
		return "RichTextFixed(nil)"
	}
	type Alias RichTextFixed
	return fmt.Sprintf("RichTextFixed%+v", Alias(*r))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*RichTextFixed) TypeID() uint32 {
	return RichTextFixedTypeID
}

// TypeName returns name of type in TL schema.
func (*RichTextFixed) TypeName() string {
	return "richTextFixed"
}

// TypeInfo returns info about TL type.
func (r *RichTextFixed) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "richTextFixed",
		ID:   RichTextFixedTypeID,
	}
	if r == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Text",
			SchemaName: "text",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (r *RichTextFixed) Encode(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't encode richTextFixed#b43681c7 as nil")
	}
	b.PutID(RichTextFixedTypeID)
	return r.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (r *RichTextFixed) EncodeBare(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't encode richTextFixed#b43681c7 as nil")
	}
	if r.Text == nil {
		return fmt.Errorf("unable to encode richTextFixed#b43681c7: field text is nil")
	}
	if err := r.Text.Encode(b); err != nil {
		return fmt.Errorf("unable to encode richTextFixed#b43681c7: field text: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (r *RichTextFixed) Decode(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't decode richTextFixed#b43681c7 to nil")
	}
	if err := b.ConsumeID(RichTextFixedTypeID); err != nil {
		return fmt.Errorf("unable to decode richTextFixed#b43681c7: %w", err)
	}
	return r.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (r *RichTextFixed) DecodeBare(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't decode richTextFixed#b43681c7 to nil")
	}
	{
		value, err := DecodeRichText(b)
		if err != nil {
			return fmt.Errorf("unable to decode richTextFixed#b43681c7: field text: %w", err)
		}
		r.Text = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (r *RichTextFixed) EncodeTDLibJSON(b tdjson.Encoder) error {
	if r == nil {
		return fmt.Errorf("can't encode richTextFixed#b43681c7 as nil")
	}
	b.ObjStart()
	b.PutID("richTextFixed")
	b.Comma()
	b.FieldStart("text")
	if r.Text == nil {
		return fmt.Errorf("unable to encode richTextFixed#b43681c7: field text is nil")
	}
	if err := r.Text.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode richTextFixed#b43681c7: field text: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (r *RichTextFixed) DecodeTDLibJSON(b tdjson.Decoder) error {
	if r == nil {
		return fmt.Errorf("can't decode richTextFixed#b43681c7 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("richTextFixed"); err != nil {
				return fmt.Errorf("unable to decode richTextFixed#b43681c7: %w", err)
			}
		case "text":
			value, err := DecodeTDLibJSONRichText(b)
			if err != nil {
				return fmt.Errorf("unable to decode richTextFixed#b43681c7: field text: %w", err)
			}
			r.Text = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetText returns value of Text field.
func (r *RichTextFixed) GetText() (value RichTextClass) {
	if r == nil {
		return
	}
	return r.Text
}

// RichTextURL represents TL type `richTextUrl#500cf14`.
type RichTextURL struct {
	// Text
	Text RichTextClass
	// URL
	URL string
	// True, if the URL has cached instant view server-side
	IsCached bool
}

// RichTextURLTypeID is TL type id of RichTextURL.
const RichTextURLTypeID = 0x500cf14

// construct implements constructor of RichTextClass.
func (r RichTextURL) construct() RichTextClass { return &r }

// Ensuring interfaces in compile-time for RichTextURL.
var (
	_ bin.Encoder     = &RichTextURL{}
	_ bin.Decoder     = &RichTextURL{}
	_ bin.BareEncoder = &RichTextURL{}
	_ bin.BareDecoder = &RichTextURL{}

	_ RichTextClass = &RichTextURL{}
)

func (r *RichTextURL) Zero() bool {
	if r == nil {
		return true
	}
	if !(r.Text == nil) {
		return false
	}
	if !(r.URL == "") {
		return false
	}
	if !(r.IsCached == false) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (r *RichTextURL) String() string {
	if r == nil {
		return "RichTextURL(nil)"
	}
	type Alias RichTextURL
	return fmt.Sprintf("RichTextURL%+v", Alias(*r))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*RichTextURL) TypeID() uint32 {
	return RichTextURLTypeID
}

// TypeName returns name of type in TL schema.
func (*RichTextURL) TypeName() string {
	return "richTextUrl"
}

// TypeInfo returns info about TL type.
func (r *RichTextURL) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "richTextUrl",
		ID:   RichTextURLTypeID,
	}
	if r == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Text",
			SchemaName: "text",
		},
		{
			Name:       "URL",
			SchemaName: "url",
		},
		{
			Name:       "IsCached",
			SchemaName: "is_cached",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (r *RichTextURL) Encode(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't encode richTextUrl#500cf14 as nil")
	}
	b.PutID(RichTextURLTypeID)
	return r.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (r *RichTextURL) EncodeBare(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't encode richTextUrl#500cf14 as nil")
	}
	if r.Text == nil {
		return fmt.Errorf("unable to encode richTextUrl#500cf14: field text is nil")
	}
	if err := r.Text.Encode(b); err != nil {
		return fmt.Errorf("unable to encode richTextUrl#500cf14: field text: %w", err)
	}
	b.PutString(r.URL)
	b.PutBool(r.IsCached)
	return nil
}

// Decode implements bin.Decoder.
func (r *RichTextURL) Decode(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't decode richTextUrl#500cf14 to nil")
	}
	if err := b.ConsumeID(RichTextURLTypeID); err != nil {
		return fmt.Errorf("unable to decode richTextUrl#500cf14: %w", err)
	}
	return r.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (r *RichTextURL) DecodeBare(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't decode richTextUrl#500cf14 to nil")
	}
	{
		value, err := DecodeRichText(b)
		if err != nil {
			return fmt.Errorf("unable to decode richTextUrl#500cf14: field text: %w", err)
		}
		r.Text = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode richTextUrl#500cf14: field url: %w", err)
		}
		r.URL = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode richTextUrl#500cf14: field is_cached: %w", err)
		}
		r.IsCached = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (r *RichTextURL) EncodeTDLibJSON(b tdjson.Encoder) error {
	if r == nil {
		return fmt.Errorf("can't encode richTextUrl#500cf14 as nil")
	}
	b.ObjStart()
	b.PutID("richTextUrl")
	b.Comma()
	b.FieldStart("text")
	if r.Text == nil {
		return fmt.Errorf("unable to encode richTextUrl#500cf14: field text is nil")
	}
	if err := r.Text.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode richTextUrl#500cf14: field text: %w", err)
	}
	b.Comma()
	b.FieldStart("url")
	b.PutString(r.URL)
	b.Comma()
	b.FieldStart("is_cached")
	b.PutBool(r.IsCached)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (r *RichTextURL) DecodeTDLibJSON(b tdjson.Decoder) error {
	if r == nil {
		return fmt.Errorf("can't decode richTextUrl#500cf14 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("richTextUrl"); err != nil {
				return fmt.Errorf("unable to decode richTextUrl#500cf14: %w", err)
			}
		case "text":
			value, err := DecodeTDLibJSONRichText(b)
			if err != nil {
				return fmt.Errorf("unable to decode richTextUrl#500cf14: field text: %w", err)
			}
			r.Text = value
		case "url":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode richTextUrl#500cf14: field url: %w", err)
			}
			r.URL = value
		case "is_cached":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode richTextUrl#500cf14: field is_cached: %w", err)
			}
			r.IsCached = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetText returns value of Text field.
func (r *RichTextURL) GetText() (value RichTextClass) {
	if r == nil {
		return
	}
	return r.Text
}

// GetURL returns value of URL field.
func (r *RichTextURL) GetURL() (value string) {
	if r == nil {
		return
	}
	return r.URL
}

// GetIsCached returns value of IsCached field.
func (r *RichTextURL) GetIsCached() (value bool) {
	if r == nil {
		return
	}
	return r.IsCached
}

// RichTextEmailAddress represents TL type `richTextEmailAddress#262a2f7`.
type RichTextEmailAddress struct {
	// Text
	Text RichTextClass
	// Email address
	EmailAddress string
}

// RichTextEmailAddressTypeID is TL type id of RichTextEmailAddress.
const RichTextEmailAddressTypeID = 0x262a2f7

// construct implements constructor of RichTextClass.
func (r RichTextEmailAddress) construct() RichTextClass { return &r }

// Ensuring interfaces in compile-time for RichTextEmailAddress.
var (
	_ bin.Encoder     = &RichTextEmailAddress{}
	_ bin.Decoder     = &RichTextEmailAddress{}
	_ bin.BareEncoder = &RichTextEmailAddress{}
	_ bin.BareDecoder = &RichTextEmailAddress{}

	_ RichTextClass = &RichTextEmailAddress{}
)

func (r *RichTextEmailAddress) Zero() bool {
	if r == nil {
		return true
	}
	if !(r.Text == nil) {
		return false
	}
	if !(r.EmailAddress == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (r *RichTextEmailAddress) String() string {
	if r == nil {
		return "RichTextEmailAddress(nil)"
	}
	type Alias RichTextEmailAddress
	return fmt.Sprintf("RichTextEmailAddress%+v", Alias(*r))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*RichTextEmailAddress) TypeID() uint32 {
	return RichTextEmailAddressTypeID
}

// TypeName returns name of type in TL schema.
func (*RichTextEmailAddress) TypeName() string {
	return "richTextEmailAddress"
}

// TypeInfo returns info about TL type.
func (r *RichTextEmailAddress) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "richTextEmailAddress",
		ID:   RichTextEmailAddressTypeID,
	}
	if r == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Text",
			SchemaName: "text",
		},
		{
			Name:       "EmailAddress",
			SchemaName: "email_address",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (r *RichTextEmailAddress) Encode(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't encode richTextEmailAddress#262a2f7 as nil")
	}
	b.PutID(RichTextEmailAddressTypeID)
	return r.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (r *RichTextEmailAddress) EncodeBare(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't encode richTextEmailAddress#262a2f7 as nil")
	}
	if r.Text == nil {
		return fmt.Errorf("unable to encode richTextEmailAddress#262a2f7: field text is nil")
	}
	if err := r.Text.Encode(b); err != nil {
		return fmt.Errorf("unable to encode richTextEmailAddress#262a2f7: field text: %w", err)
	}
	b.PutString(r.EmailAddress)
	return nil
}

// Decode implements bin.Decoder.
func (r *RichTextEmailAddress) Decode(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't decode richTextEmailAddress#262a2f7 to nil")
	}
	if err := b.ConsumeID(RichTextEmailAddressTypeID); err != nil {
		return fmt.Errorf("unable to decode richTextEmailAddress#262a2f7: %w", err)
	}
	return r.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (r *RichTextEmailAddress) DecodeBare(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't decode richTextEmailAddress#262a2f7 to nil")
	}
	{
		value, err := DecodeRichText(b)
		if err != nil {
			return fmt.Errorf("unable to decode richTextEmailAddress#262a2f7: field text: %w", err)
		}
		r.Text = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode richTextEmailAddress#262a2f7: field email_address: %w", err)
		}
		r.EmailAddress = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (r *RichTextEmailAddress) EncodeTDLibJSON(b tdjson.Encoder) error {
	if r == nil {
		return fmt.Errorf("can't encode richTextEmailAddress#262a2f7 as nil")
	}
	b.ObjStart()
	b.PutID("richTextEmailAddress")
	b.Comma()
	b.FieldStart("text")
	if r.Text == nil {
		return fmt.Errorf("unable to encode richTextEmailAddress#262a2f7: field text is nil")
	}
	if err := r.Text.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode richTextEmailAddress#262a2f7: field text: %w", err)
	}
	b.Comma()
	b.FieldStart("email_address")
	b.PutString(r.EmailAddress)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (r *RichTextEmailAddress) DecodeTDLibJSON(b tdjson.Decoder) error {
	if r == nil {
		return fmt.Errorf("can't decode richTextEmailAddress#262a2f7 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("richTextEmailAddress"); err != nil {
				return fmt.Errorf("unable to decode richTextEmailAddress#262a2f7: %w", err)
			}
		case "text":
			value, err := DecodeTDLibJSONRichText(b)
			if err != nil {
				return fmt.Errorf("unable to decode richTextEmailAddress#262a2f7: field text: %w", err)
			}
			r.Text = value
		case "email_address":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode richTextEmailAddress#262a2f7: field email_address: %w", err)
			}
			r.EmailAddress = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetText returns value of Text field.
func (r *RichTextEmailAddress) GetText() (value RichTextClass) {
	if r == nil {
		return
	}
	return r.Text
}

// GetEmailAddress returns value of EmailAddress field.
func (r *RichTextEmailAddress) GetEmailAddress() (value string) {
	if r == nil {
		return
	}
	return r.EmailAddress
}

// RichTextSubscript represents TL type `richTextSubscript#cc405a4c`.
type RichTextSubscript struct {
	// Text
	Text RichTextClass
}

// RichTextSubscriptTypeID is TL type id of RichTextSubscript.
const RichTextSubscriptTypeID = 0xcc405a4c

// construct implements constructor of RichTextClass.
func (r RichTextSubscript) construct() RichTextClass { return &r }

// Ensuring interfaces in compile-time for RichTextSubscript.
var (
	_ bin.Encoder     = &RichTextSubscript{}
	_ bin.Decoder     = &RichTextSubscript{}
	_ bin.BareEncoder = &RichTextSubscript{}
	_ bin.BareDecoder = &RichTextSubscript{}

	_ RichTextClass = &RichTextSubscript{}
)

func (r *RichTextSubscript) Zero() bool {
	if r == nil {
		return true
	}
	if !(r.Text == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (r *RichTextSubscript) String() string {
	if r == nil {
		return "RichTextSubscript(nil)"
	}
	type Alias RichTextSubscript
	return fmt.Sprintf("RichTextSubscript%+v", Alias(*r))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*RichTextSubscript) TypeID() uint32 {
	return RichTextSubscriptTypeID
}

// TypeName returns name of type in TL schema.
func (*RichTextSubscript) TypeName() string {
	return "richTextSubscript"
}

// TypeInfo returns info about TL type.
func (r *RichTextSubscript) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "richTextSubscript",
		ID:   RichTextSubscriptTypeID,
	}
	if r == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Text",
			SchemaName: "text",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (r *RichTextSubscript) Encode(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't encode richTextSubscript#cc405a4c as nil")
	}
	b.PutID(RichTextSubscriptTypeID)
	return r.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (r *RichTextSubscript) EncodeBare(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't encode richTextSubscript#cc405a4c as nil")
	}
	if r.Text == nil {
		return fmt.Errorf("unable to encode richTextSubscript#cc405a4c: field text is nil")
	}
	if err := r.Text.Encode(b); err != nil {
		return fmt.Errorf("unable to encode richTextSubscript#cc405a4c: field text: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (r *RichTextSubscript) Decode(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't decode richTextSubscript#cc405a4c to nil")
	}
	if err := b.ConsumeID(RichTextSubscriptTypeID); err != nil {
		return fmt.Errorf("unable to decode richTextSubscript#cc405a4c: %w", err)
	}
	return r.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (r *RichTextSubscript) DecodeBare(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't decode richTextSubscript#cc405a4c to nil")
	}
	{
		value, err := DecodeRichText(b)
		if err != nil {
			return fmt.Errorf("unable to decode richTextSubscript#cc405a4c: field text: %w", err)
		}
		r.Text = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (r *RichTextSubscript) EncodeTDLibJSON(b tdjson.Encoder) error {
	if r == nil {
		return fmt.Errorf("can't encode richTextSubscript#cc405a4c as nil")
	}
	b.ObjStart()
	b.PutID("richTextSubscript")
	b.Comma()
	b.FieldStart("text")
	if r.Text == nil {
		return fmt.Errorf("unable to encode richTextSubscript#cc405a4c: field text is nil")
	}
	if err := r.Text.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode richTextSubscript#cc405a4c: field text: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (r *RichTextSubscript) DecodeTDLibJSON(b tdjson.Decoder) error {
	if r == nil {
		return fmt.Errorf("can't decode richTextSubscript#cc405a4c to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("richTextSubscript"); err != nil {
				return fmt.Errorf("unable to decode richTextSubscript#cc405a4c: %w", err)
			}
		case "text":
			value, err := DecodeTDLibJSONRichText(b)
			if err != nil {
				return fmt.Errorf("unable to decode richTextSubscript#cc405a4c: field text: %w", err)
			}
			r.Text = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetText returns value of Text field.
func (r *RichTextSubscript) GetText() (value RichTextClass) {
	if r == nil {
		return
	}
	return r.Text
}

// RichTextSuperscript represents TL type `richTextSuperscript#e9377563`.
type RichTextSuperscript struct {
	// Text
	Text RichTextClass
}

// RichTextSuperscriptTypeID is TL type id of RichTextSuperscript.
const RichTextSuperscriptTypeID = 0xe9377563

// construct implements constructor of RichTextClass.
func (r RichTextSuperscript) construct() RichTextClass { return &r }

// Ensuring interfaces in compile-time for RichTextSuperscript.
var (
	_ bin.Encoder     = &RichTextSuperscript{}
	_ bin.Decoder     = &RichTextSuperscript{}
	_ bin.BareEncoder = &RichTextSuperscript{}
	_ bin.BareDecoder = &RichTextSuperscript{}

	_ RichTextClass = &RichTextSuperscript{}
)

func (r *RichTextSuperscript) Zero() bool {
	if r == nil {
		return true
	}
	if !(r.Text == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (r *RichTextSuperscript) String() string {
	if r == nil {
		return "RichTextSuperscript(nil)"
	}
	type Alias RichTextSuperscript
	return fmt.Sprintf("RichTextSuperscript%+v", Alias(*r))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*RichTextSuperscript) TypeID() uint32 {
	return RichTextSuperscriptTypeID
}

// TypeName returns name of type in TL schema.
func (*RichTextSuperscript) TypeName() string {
	return "richTextSuperscript"
}

// TypeInfo returns info about TL type.
func (r *RichTextSuperscript) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "richTextSuperscript",
		ID:   RichTextSuperscriptTypeID,
	}
	if r == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Text",
			SchemaName: "text",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (r *RichTextSuperscript) Encode(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't encode richTextSuperscript#e9377563 as nil")
	}
	b.PutID(RichTextSuperscriptTypeID)
	return r.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (r *RichTextSuperscript) EncodeBare(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't encode richTextSuperscript#e9377563 as nil")
	}
	if r.Text == nil {
		return fmt.Errorf("unable to encode richTextSuperscript#e9377563: field text is nil")
	}
	if err := r.Text.Encode(b); err != nil {
		return fmt.Errorf("unable to encode richTextSuperscript#e9377563: field text: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (r *RichTextSuperscript) Decode(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't decode richTextSuperscript#e9377563 to nil")
	}
	if err := b.ConsumeID(RichTextSuperscriptTypeID); err != nil {
		return fmt.Errorf("unable to decode richTextSuperscript#e9377563: %w", err)
	}
	return r.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (r *RichTextSuperscript) DecodeBare(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't decode richTextSuperscript#e9377563 to nil")
	}
	{
		value, err := DecodeRichText(b)
		if err != nil {
			return fmt.Errorf("unable to decode richTextSuperscript#e9377563: field text: %w", err)
		}
		r.Text = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (r *RichTextSuperscript) EncodeTDLibJSON(b tdjson.Encoder) error {
	if r == nil {
		return fmt.Errorf("can't encode richTextSuperscript#e9377563 as nil")
	}
	b.ObjStart()
	b.PutID("richTextSuperscript")
	b.Comma()
	b.FieldStart("text")
	if r.Text == nil {
		return fmt.Errorf("unable to encode richTextSuperscript#e9377563: field text is nil")
	}
	if err := r.Text.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode richTextSuperscript#e9377563: field text: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (r *RichTextSuperscript) DecodeTDLibJSON(b tdjson.Decoder) error {
	if r == nil {
		return fmt.Errorf("can't decode richTextSuperscript#e9377563 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("richTextSuperscript"); err != nil {
				return fmt.Errorf("unable to decode richTextSuperscript#e9377563: %w", err)
			}
		case "text":
			value, err := DecodeTDLibJSONRichText(b)
			if err != nil {
				return fmt.Errorf("unable to decode richTextSuperscript#e9377563: field text: %w", err)
			}
			r.Text = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetText returns value of Text field.
func (r *RichTextSuperscript) GetText() (value RichTextClass) {
	if r == nil {
		return
	}
	return r.Text
}

// RichTextMarked represents TL type `richTextMarked#b42ed382`.
type RichTextMarked struct {
	// Text
	Text RichTextClass
}

// RichTextMarkedTypeID is TL type id of RichTextMarked.
const RichTextMarkedTypeID = 0xb42ed382

// construct implements constructor of RichTextClass.
func (r RichTextMarked) construct() RichTextClass { return &r }

// Ensuring interfaces in compile-time for RichTextMarked.
var (
	_ bin.Encoder     = &RichTextMarked{}
	_ bin.Decoder     = &RichTextMarked{}
	_ bin.BareEncoder = &RichTextMarked{}
	_ bin.BareDecoder = &RichTextMarked{}

	_ RichTextClass = &RichTextMarked{}
)

func (r *RichTextMarked) Zero() bool {
	if r == nil {
		return true
	}
	if !(r.Text == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (r *RichTextMarked) String() string {
	if r == nil {
		return "RichTextMarked(nil)"
	}
	type Alias RichTextMarked
	return fmt.Sprintf("RichTextMarked%+v", Alias(*r))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*RichTextMarked) TypeID() uint32 {
	return RichTextMarkedTypeID
}

// TypeName returns name of type in TL schema.
func (*RichTextMarked) TypeName() string {
	return "richTextMarked"
}

// TypeInfo returns info about TL type.
func (r *RichTextMarked) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "richTextMarked",
		ID:   RichTextMarkedTypeID,
	}
	if r == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Text",
			SchemaName: "text",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (r *RichTextMarked) Encode(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't encode richTextMarked#b42ed382 as nil")
	}
	b.PutID(RichTextMarkedTypeID)
	return r.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (r *RichTextMarked) EncodeBare(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't encode richTextMarked#b42ed382 as nil")
	}
	if r.Text == nil {
		return fmt.Errorf("unable to encode richTextMarked#b42ed382: field text is nil")
	}
	if err := r.Text.Encode(b); err != nil {
		return fmt.Errorf("unable to encode richTextMarked#b42ed382: field text: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (r *RichTextMarked) Decode(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't decode richTextMarked#b42ed382 to nil")
	}
	if err := b.ConsumeID(RichTextMarkedTypeID); err != nil {
		return fmt.Errorf("unable to decode richTextMarked#b42ed382: %w", err)
	}
	return r.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (r *RichTextMarked) DecodeBare(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't decode richTextMarked#b42ed382 to nil")
	}
	{
		value, err := DecodeRichText(b)
		if err != nil {
			return fmt.Errorf("unable to decode richTextMarked#b42ed382: field text: %w", err)
		}
		r.Text = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (r *RichTextMarked) EncodeTDLibJSON(b tdjson.Encoder) error {
	if r == nil {
		return fmt.Errorf("can't encode richTextMarked#b42ed382 as nil")
	}
	b.ObjStart()
	b.PutID("richTextMarked")
	b.Comma()
	b.FieldStart("text")
	if r.Text == nil {
		return fmt.Errorf("unable to encode richTextMarked#b42ed382: field text is nil")
	}
	if err := r.Text.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode richTextMarked#b42ed382: field text: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (r *RichTextMarked) DecodeTDLibJSON(b tdjson.Decoder) error {
	if r == nil {
		return fmt.Errorf("can't decode richTextMarked#b42ed382 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("richTextMarked"); err != nil {
				return fmt.Errorf("unable to decode richTextMarked#b42ed382: %w", err)
			}
		case "text":
			value, err := DecodeTDLibJSONRichText(b)
			if err != nil {
				return fmt.Errorf("unable to decode richTextMarked#b42ed382: field text: %w", err)
			}
			r.Text = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetText returns value of Text field.
func (r *RichTextMarked) GetText() (value RichTextClass) {
	if r == nil {
		return
	}
	return r.Text
}

// RichTextPhoneNumber represents TL type `richTextPhoneNumber#7a91543`.
type RichTextPhoneNumber struct {
	// Text
	Text RichTextClass
	// Phone number
	PhoneNumber string
}

// RichTextPhoneNumberTypeID is TL type id of RichTextPhoneNumber.
const RichTextPhoneNumberTypeID = 0x7a91543

// construct implements constructor of RichTextClass.
func (r RichTextPhoneNumber) construct() RichTextClass { return &r }

// Ensuring interfaces in compile-time for RichTextPhoneNumber.
var (
	_ bin.Encoder     = &RichTextPhoneNumber{}
	_ bin.Decoder     = &RichTextPhoneNumber{}
	_ bin.BareEncoder = &RichTextPhoneNumber{}
	_ bin.BareDecoder = &RichTextPhoneNumber{}

	_ RichTextClass = &RichTextPhoneNumber{}
)

func (r *RichTextPhoneNumber) Zero() bool {
	if r == nil {
		return true
	}
	if !(r.Text == nil) {
		return false
	}
	if !(r.PhoneNumber == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (r *RichTextPhoneNumber) String() string {
	if r == nil {
		return "RichTextPhoneNumber(nil)"
	}
	type Alias RichTextPhoneNumber
	return fmt.Sprintf("RichTextPhoneNumber%+v", Alias(*r))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*RichTextPhoneNumber) TypeID() uint32 {
	return RichTextPhoneNumberTypeID
}

// TypeName returns name of type in TL schema.
func (*RichTextPhoneNumber) TypeName() string {
	return "richTextPhoneNumber"
}

// TypeInfo returns info about TL type.
func (r *RichTextPhoneNumber) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "richTextPhoneNumber",
		ID:   RichTextPhoneNumberTypeID,
	}
	if r == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Text",
			SchemaName: "text",
		},
		{
			Name:       "PhoneNumber",
			SchemaName: "phone_number",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (r *RichTextPhoneNumber) Encode(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't encode richTextPhoneNumber#7a91543 as nil")
	}
	b.PutID(RichTextPhoneNumberTypeID)
	return r.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (r *RichTextPhoneNumber) EncodeBare(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't encode richTextPhoneNumber#7a91543 as nil")
	}
	if r.Text == nil {
		return fmt.Errorf("unable to encode richTextPhoneNumber#7a91543: field text is nil")
	}
	if err := r.Text.Encode(b); err != nil {
		return fmt.Errorf("unable to encode richTextPhoneNumber#7a91543: field text: %w", err)
	}
	b.PutString(r.PhoneNumber)
	return nil
}

// Decode implements bin.Decoder.
func (r *RichTextPhoneNumber) Decode(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't decode richTextPhoneNumber#7a91543 to nil")
	}
	if err := b.ConsumeID(RichTextPhoneNumberTypeID); err != nil {
		return fmt.Errorf("unable to decode richTextPhoneNumber#7a91543: %w", err)
	}
	return r.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (r *RichTextPhoneNumber) DecodeBare(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't decode richTextPhoneNumber#7a91543 to nil")
	}
	{
		value, err := DecodeRichText(b)
		if err != nil {
			return fmt.Errorf("unable to decode richTextPhoneNumber#7a91543: field text: %w", err)
		}
		r.Text = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode richTextPhoneNumber#7a91543: field phone_number: %w", err)
		}
		r.PhoneNumber = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (r *RichTextPhoneNumber) EncodeTDLibJSON(b tdjson.Encoder) error {
	if r == nil {
		return fmt.Errorf("can't encode richTextPhoneNumber#7a91543 as nil")
	}
	b.ObjStart()
	b.PutID("richTextPhoneNumber")
	b.Comma()
	b.FieldStart("text")
	if r.Text == nil {
		return fmt.Errorf("unable to encode richTextPhoneNumber#7a91543: field text is nil")
	}
	if err := r.Text.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode richTextPhoneNumber#7a91543: field text: %w", err)
	}
	b.Comma()
	b.FieldStart("phone_number")
	b.PutString(r.PhoneNumber)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (r *RichTextPhoneNumber) DecodeTDLibJSON(b tdjson.Decoder) error {
	if r == nil {
		return fmt.Errorf("can't decode richTextPhoneNumber#7a91543 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("richTextPhoneNumber"); err != nil {
				return fmt.Errorf("unable to decode richTextPhoneNumber#7a91543: %w", err)
			}
		case "text":
			value, err := DecodeTDLibJSONRichText(b)
			if err != nil {
				return fmt.Errorf("unable to decode richTextPhoneNumber#7a91543: field text: %w", err)
			}
			r.Text = value
		case "phone_number":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode richTextPhoneNumber#7a91543: field phone_number: %w", err)
			}
			r.PhoneNumber = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetText returns value of Text field.
func (r *RichTextPhoneNumber) GetText() (value RichTextClass) {
	if r == nil {
		return
	}
	return r.Text
}

// GetPhoneNumber returns value of PhoneNumber field.
func (r *RichTextPhoneNumber) GetPhoneNumber() (value string) {
	if r == nil {
		return
	}
	return r.PhoneNumber
}

// RichTextIcon represents TL type `richTextIcon#a7c42b02`.
type RichTextIcon struct {
	// The image represented as a document. The image can be in GIF, JPEG or PNG format
	Document Document
	// Width of a bounding box in which the image must be shown; 0 if unknown
	Width int32
	// Height of a bounding box in which the image must be shown; 0 if unknown
	Height int32
}

// RichTextIconTypeID is TL type id of RichTextIcon.
const RichTextIconTypeID = 0xa7c42b02

// construct implements constructor of RichTextClass.
func (r RichTextIcon) construct() RichTextClass { return &r }

// Ensuring interfaces in compile-time for RichTextIcon.
var (
	_ bin.Encoder     = &RichTextIcon{}
	_ bin.Decoder     = &RichTextIcon{}
	_ bin.BareEncoder = &RichTextIcon{}
	_ bin.BareDecoder = &RichTextIcon{}

	_ RichTextClass = &RichTextIcon{}
)

func (r *RichTextIcon) Zero() bool {
	if r == nil {
		return true
	}
	if !(r.Document.Zero()) {
		return false
	}
	if !(r.Width == 0) {
		return false
	}
	if !(r.Height == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (r *RichTextIcon) String() string {
	if r == nil {
		return "RichTextIcon(nil)"
	}
	type Alias RichTextIcon
	return fmt.Sprintf("RichTextIcon%+v", Alias(*r))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*RichTextIcon) TypeID() uint32 {
	return RichTextIconTypeID
}

// TypeName returns name of type in TL schema.
func (*RichTextIcon) TypeName() string {
	return "richTextIcon"
}

// TypeInfo returns info about TL type.
func (r *RichTextIcon) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "richTextIcon",
		ID:   RichTextIconTypeID,
	}
	if r == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Document",
			SchemaName: "document",
		},
		{
			Name:       "Width",
			SchemaName: "width",
		},
		{
			Name:       "Height",
			SchemaName: "height",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (r *RichTextIcon) Encode(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't encode richTextIcon#a7c42b02 as nil")
	}
	b.PutID(RichTextIconTypeID)
	return r.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (r *RichTextIcon) EncodeBare(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't encode richTextIcon#a7c42b02 as nil")
	}
	if err := r.Document.Encode(b); err != nil {
		return fmt.Errorf("unable to encode richTextIcon#a7c42b02: field document: %w", err)
	}
	b.PutInt32(r.Width)
	b.PutInt32(r.Height)
	return nil
}

// Decode implements bin.Decoder.
func (r *RichTextIcon) Decode(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't decode richTextIcon#a7c42b02 to nil")
	}
	if err := b.ConsumeID(RichTextIconTypeID); err != nil {
		return fmt.Errorf("unable to decode richTextIcon#a7c42b02: %w", err)
	}
	return r.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (r *RichTextIcon) DecodeBare(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't decode richTextIcon#a7c42b02 to nil")
	}
	{
		if err := r.Document.Decode(b); err != nil {
			return fmt.Errorf("unable to decode richTextIcon#a7c42b02: field document: %w", err)
		}
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode richTextIcon#a7c42b02: field width: %w", err)
		}
		r.Width = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode richTextIcon#a7c42b02: field height: %w", err)
		}
		r.Height = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (r *RichTextIcon) EncodeTDLibJSON(b tdjson.Encoder) error {
	if r == nil {
		return fmt.Errorf("can't encode richTextIcon#a7c42b02 as nil")
	}
	b.ObjStart()
	b.PutID("richTextIcon")
	b.Comma()
	b.FieldStart("document")
	if err := r.Document.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode richTextIcon#a7c42b02: field document: %w", err)
	}
	b.Comma()
	b.FieldStart("width")
	b.PutInt32(r.Width)
	b.Comma()
	b.FieldStart("height")
	b.PutInt32(r.Height)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (r *RichTextIcon) DecodeTDLibJSON(b tdjson.Decoder) error {
	if r == nil {
		return fmt.Errorf("can't decode richTextIcon#a7c42b02 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("richTextIcon"); err != nil {
				return fmt.Errorf("unable to decode richTextIcon#a7c42b02: %w", err)
			}
		case "document":
			if err := r.Document.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode richTextIcon#a7c42b02: field document: %w", err)
			}
		case "width":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode richTextIcon#a7c42b02: field width: %w", err)
			}
			r.Width = value
		case "height":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode richTextIcon#a7c42b02: field height: %w", err)
			}
			r.Height = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetDocument returns value of Document field.
func (r *RichTextIcon) GetDocument() (value Document) {
	if r == nil {
		return
	}
	return r.Document
}

// GetWidth returns value of Width field.
func (r *RichTextIcon) GetWidth() (value int32) {
	if r == nil {
		return
	}
	return r.Width
}

// GetHeight returns value of Height field.
func (r *RichTextIcon) GetHeight() (value int32) {
	if r == nil {
		return
	}
	return r.Height
}

// RichTextReference represents TL type `richTextReference#bb9a1276`.
type RichTextReference struct {
	// The text
	Text RichTextClass
	// The name of a richTextAnchor object, which is the first element of the target
	// richTexts object
	AnchorName string
	// An HTTP URL, opening the reference
	URL string
}

// RichTextReferenceTypeID is TL type id of RichTextReference.
const RichTextReferenceTypeID = 0xbb9a1276

// construct implements constructor of RichTextClass.
func (r RichTextReference) construct() RichTextClass { return &r }

// Ensuring interfaces in compile-time for RichTextReference.
var (
	_ bin.Encoder     = &RichTextReference{}
	_ bin.Decoder     = &RichTextReference{}
	_ bin.BareEncoder = &RichTextReference{}
	_ bin.BareDecoder = &RichTextReference{}

	_ RichTextClass = &RichTextReference{}
)

func (r *RichTextReference) Zero() bool {
	if r == nil {
		return true
	}
	if !(r.Text == nil) {
		return false
	}
	if !(r.AnchorName == "") {
		return false
	}
	if !(r.URL == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (r *RichTextReference) String() string {
	if r == nil {
		return "RichTextReference(nil)"
	}
	type Alias RichTextReference
	return fmt.Sprintf("RichTextReference%+v", Alias(*r))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*RichTextReference) TypeID() uint32 {
	return RichTextReferenceTypeID
}

// TypeName returns name of type in TL schema.
func (*RichTextReference) TypeName() string {
	return "richTextReference"
}

// TypeInfo returns info about TL type.
func (r *RichTextReference) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "richTextReference",
		ID:   RichTextReferenceTypeID,
	}
	if r == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Text",
			SchemaName: "text",
		},
		{
			Name:       "AnchorName",
			SchemaName: "anchor_name",
		},
		{
			Name:       "URL",
			SchemaName: "url",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (r *RichTextReference) Encode(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't encode richTextReference#bb9a1276 as nil")
	}
	b.PutID(RichTextReferenceTypeID)
	return r.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (r *RichTextReference) EncodeBare(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't encode richTextReference#bb9a1276 as nil")
	}
	if r.Text == nil {
		return fmt.Errorf("unable to encode richTextReference#bb9a1276: field text is nil")
	}
	if err := r.Text.Encode(b); err != nil {
		return fmt.Errorf("unable to encode richTextReference#bb9a1276: field text: %w", err)
	}
	b.PutString(r.AnchorName)
	b.PutString(r.URL)
	return nil
}

// Decode implements bin.Decoder.
func (r *RichTextReference) Decode(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't decode richTextReference#bb9a1276 to nil")
	}
	if err := b.ConsumeID(RichTextReferenceTypeID); err != nil {
		return fmt.Errorf("unable to decode richTextReference#bb9a1276: %w", err)
	}
	return r.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (r *RichTextReference) DecodeBare(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't decode richTextReference#bb9a1276 to nil")
	}
	{
		value, err := DecodeRichText(b)
		if err != nil {
			return fmt.Errorf("unable to decode richTextReference#bb9a1276: field text: %w", err)
		}
		r.Text = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode richTextReference#bb9a1276: field anchor_name: %w", err)
		}
		r.AnchorName = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode richTextReference#bb9a1276: field url: %w", err)
		}
		r.URL = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (r *RichTextReference) EncodeTDLibJSON(b tdjson.Encoder) error {
	if r == nil {
		return fmt.Errorf("can't encode richTextReference#bb9a1276 as nil")
	}
	b.ObjStart()
	b.PutID("richTextReference")
	b.Comma()
	b.FieldStart("text")
	if r.Text == nil {
		return fmt.Errorf("unable to encode richTextReference#bb9a1276: field text is nil")
	}
	if err := r.Text.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode richTextReference#bb9a1276: field text: %w", err)
	}
	b.Comma()
	b.FieldStart("anchor_name")
	b.PutString(r.AnchorName)
	b.Comma()
	b.FieldStart("url")
	b.PutString(r.URL)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (r *RichTextReference) DecodeTDLibJSON(b tdjson.Decoder) error {
	if r == nil {
		return fmt.Errorf("can't decode richTextReference#bb9a1276 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("richTextReference"); err != nil {
				return fmt.Errorf("unable to decode richTextReference#bb9a1276: %w", err)
			}
		case "text":
			value, err := DecodeTDLibJSONRichText(b)
			if err != nil {
				return fmt.Errorf("unable to decode richTextReference#bb9a1276: field text: %w", err)
			}
			r.Text = value
		case "anchor_name":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode richTextReference#bb9a1276: field anchor_name: %w", err)
			}
			r.AnchorName = value
		case "url":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode richTextReference#bb9a1276: field url: %w", err)
			}
			r.URL = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetText returns value of Text field.
func (r *RichTextReference) GetText() (value RichTextClass) {
	if r == nil {
		return
	}
	return r.Text
}

// GetAnchorName returns value of AnchorName field.
func (r *RichTextReference) GetAnchorName() (value string) {
	if r == nil {
		return
	}
	return r.AnchorName
}

// GetURL returns value of URL field.
func (r *RichTextReference) GetURL() (value string) {
	if r == nil {
		return
	}
	return r.URL
}

// RichTextAnchor represents TL type `richTextAnchor#4e7f1034`.
type RichTextAnchor struct {
	// Anchor name
	Name string
}

// RichTextAnchorTypeID is TL type id of RichTextAnchor.
const RichTextAnchorTypeID = 0x4e7f1034

// construct implements constructor of RichTextClass.
func (r RichTextAnchor) construct() RichTextClass { return &r }

// Ensuring interfaces in compile-time for RichTextAnchor.
var (
	_ bin.Encoder     = &RichTextAnchor{}
	_ bin.Decoder     = &RichTextAnchor{}
	_ bin.BareEncoder = &RichTextAnchor{}
	_ bin.BareDecoder = &RichTextAnchor{}

	_ RichTextClass = &RichTextAnchor{}
)

func (r *RichTextAnchor) Zero() bool {
	if r == nil {
		return true
	}
	if !(r.Name == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (r *RichTextAnchor) String() string {
	if r == nil {
		return "RichTextAnchor(nil)"
	}
	type Alias RichTextAnchor
	return fmt.Sprintf("RichTextAnchor%+v", Alias(*r))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*RichTextAnchor) TypeID() uint32 {
	return RichTextAnchorTypeID
}

// TypeName returns name of type in TL schema.
func (*RichTextAnchor) TypeName() string {
	return "richTextAnchor"
}

// TypeInfo returns info about TL type.
func (r *RichTextAnchor) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "richTextAnchor",
		ID:   RichTextAnchorTypeID,
	}
	if r == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Name",
			SchemaName: "name",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (r *RichTextAnchor) Encode(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't encode richTextAnchor#4e7f1034 as nil")
	}
	b.PutID(RichTextAnchorTypeID)
	return r.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (r *RichTextAnchor) EncodeBare(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't encode richTextAnchor#4e7f1034 as nil")
	}
	b.PutString(r.Name)
	return nil
}

// Decode implements bin.Decoder.
func (r *RichTextAnchor) Decode(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't decode richTextAnchor#4e7f1034 to nil")
	}
	if err := b.ConsumeID(RichTextAnchorTypeID); err != nil {
		return fmt.Errorf("unable to decode richTextAnchor#4e7f1034: %w", err)
	}
	return r.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (r *RichTextAnchor) DecodeBare(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't decode richTextAnchor#4e7f1034 to nil")
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode richTextAnchor#4e7f1034: field name: %w", err)
		}
		r.Name = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (r *RichTextAnchor) EncodeTDLibJSON(b tdjson.Encoder) error {
	if r == nil {
		return fmt.Errorf("can't encode richTextAnchor#4e7f1034 as nil")
	}
	b.ObjStart()
	b.PutID("richTextAnchor")
	b.Comma()
	b.FieldStart("name")
	b.PutString(r.Name)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (r *RichTextAnchor) DecodeTDLibJSON(b tdjson.Decoder) error {
	if r == nil {
		return fmt.Errorf("can't decode richTextAnchor#4e7f1034 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("richTextAnchor"); err != nil {
				return fmt.Errorf("unable to decode richTextAnchor#4e7f1034: %w", err)
			}
		case "name":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode richTextAnchor#4e7f1034: field name: %w", err)
			}
			r.Name = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetName returns value of Name field.
func (r *RichTextAnchor) GetName() (value string) {
	if r == nil {
		return
	}
	return r.Name
}

// RichTextAnchorLink represents TL type `richTextAnchorLink#a41fd2d6`.
type RichTextAnchorLink struct {
	// The link text
	Text RichTextClass
	// The anchor name. If the name is empty, the link must bring back to top
	AnchorName string
	// An HTTP URL, opening the anchor
	URL string
}

// RichTextAnchorLinkTypeID is TL type id of RichTextAnchorLink.
const RichTextAnchorLinkTypeID = 0xa41fd2d6

// construct implements constructor of RichTextClass.
func (r RichTextAnchorLink) construct() RichTextClass { return &r }

// Ensuring interfaces in compile-time for RichTextAnchorLink.
var (
	_ bin.Encoder     = &RichTextAnchorLink{}
	_ bin.Decoder     = &RichTextAnchorLink{}
	_ bin.BareEncoder = &RichTextAnchorLink{}
	_ bin.BareDecoder = &RichTextAnchorLink{}

	_ RichTextClass = &RichTextAnchorLink{}
)

func (r *RichTextAnchorLink) Zero() bool {
	if r == nil {
		return true
	}
	if !(r.Text == nil) {
		return false
	}
	if !(r.AnchorName == "") {
		return false
	}
	if !(r.URL == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (r *RichTextAnchorLink) String() string {
	if r == nil {
		return "RichTextAnchorLink(nil)"
	}
	type Alias RichTextAnchorLink
	return fmt.Sprintf("RichTextAnchorLink%+v", Alias(*r))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*RichTextAnchorLink) TypeID() uint32 {
	return RichTextAnchorLinkTypeID
}

// TypeName returns name of type in TL schema.
func (*RichTextAnchorLink) TypeName() string {
	return "richTextAnchorLink"
}

// TypeInfo returns info about TL type.
func (r *RichTextAnchorLink) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "richTextAnchorLink",
		ID:   RichTextAnchorLinkTypeID,
	}
	if r == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Text",
			SchemaName: "text",
		},
		{
			Name:       "AnchorName",
			SchemaName: "anchor_name",
		},
		{
			Name:       "URL",
			SchemaName: "url",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (r *RichTextAnchorLink) Encode(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't encode richTextAnchorLink#a41fd2d6 as nil")
	}
	b.PutID(RichTextAnchorLinkTypeID)
	return r.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (r *RichTextAnchorLink) EncodeBare(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't encode richTextAnchorLink#a41fd2d6 as nil")
	}
	if r.Text == nil {
		return fmt.Errorf("unable to encode richTextAnchorLink#a41fd2d6: field text is nil")
	}
	if err := r.Text.Encode(b); err != nil {
		return fmt.Errorf("unable to encode richTextAnchorLink#a41fd2d6: field text: %w", err)
	}
	b.PutString(r.AnchorName)
	b.PutString(r.URL)
	return nil
}

// Decode implements bin.Decoder.
func (r *RichTextAnchorLink) Decode(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't decode richTextAnchorLink#a41fd2d6 to nil")
	}
	if err := b.ConsumeID(RichTextAnchorLinkTypeID); err != nil {
		return fmt.Errorf("unable to decode richTextAnchorLink#a41fd2d6: %w", err)
	}
	return r.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (r *RichTextAnchorLink) DecodeBare(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't decode richTextAnchorLink#a41fd2d6 to nil")
	}
	{
		value, err := DecodeRichText(b)
		if err != nil {
			return fmt.Errorf("unable to decode richTextAnchorLink#a41fd2d6: field text: %w", err)
		}
		r.Text = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode richTextAnchorLink#a41fd2d6: field anchor_name: %w", err)
		}
		r.AnchorName = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode richTextAnchorLink#a41fd2d6: field url: %w", err)
		}
		r.URL = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (r *RichTextAnchorLink) EncodeTDLibJSON(b tdjson.Encoder) error {
	if r == nil {
		return fmt.Errorf("can't encode richTextAnchorLink#a41fd2d6 as nil")
	}
	b.ObjStart()
	b.PutID("richTextAnchorLink")
	b.Comma()
	b.FieldStart("text")
	if r.Text == nil {
		return fmt.Errorf("unable to encode richTextAnchorLink#a41fd2d6: field text is nil")
	}
	if err := r.Text.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode richTextAnchorLink#a41fd2d6: field text: %w", err)
	}
	b.Comma()
	b.FieldStart("anchor_name")
	b.PutString(r.AnchorName)
	b.Comma()
	b.FieldStart("url")
	b.PutString(r.URL)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (r *RichTextAnchorLink) DecodeTDLibJSON(b tdjson.Decoder) error {
	if r == nil {
		return fmt.Errorf("can't decode richTextAnchorLink#a41fd2d6 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("richTextAnchorLink"); err != nil {
				return fmt.Errorf("unable to decode richTextAnchorLink#a41fd2d6: %w", err)
			}
		case "text":
			value, err := DecodeTDLibJSONRichText(b)
			if err != nil {
				return fmt.Errorf("unable to decode richTextAnchorLink#a41fd2d6: field text: %w", err)
			}
			r.Text = value
		case "anchor_name":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode richTextAnchorLink#a41fd2d6: field anchor_name: %w", err)
			}
			r.AnchorName = value
		case "url":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode richTextAnchorLink#a41fd2d6: field url: %w", err)
			}
			r.URL = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetText returns value of Text field.
func (r *RichTextAnchorLink) GetText() (value RichTextClass) {
	if r == nil {
		return
	}
	return r.Text
}

// GetAnchorName returns value of AnchorName field.
func (r *RichTextAnchorLink) GetAnchorName() (value string) {
	if r == nil {
		return
	}
	return r.AnchorName
}

// GetURL returns value of URL field.
func (r *RichTextAnchorLink) GetURL() (value string) {
	if r == nil {
		return
	}
	return r.URL
}

// RichTexts represents TL type `richTexts#94b21889`.
type RichTexts struct {
	// Texts
	Texts []RichTextClass
}

// RichTextsTypeID is TL type id of RichTexts.
const RichTextsTypeID = 0x94b21889

// construct implements constructor of RichTextClass.
func (r RichTexts) construct() RichTextClass { return &r }

// Ensuring interfaces in compile-time for RichTexts.
var (
	_ bin.Encoder     = &RichTexts{}
	_ bin.Decoder     = &RichTexts{}
	_ bin.BareEncoder = &RichTexts{}
	_ bin.BareDecoder = &RichTexts{}

	_ RichTextClass = &RichTexts{}
)

func (r *RichTexts) Zero() bool {
	if r == nil {
		return true
	}
	if !(r.Texts == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (r *RichTexts) String() string {
	if r == nil {
		return "RichTexts(nil)"
	}
	type Alias RichTexts
	return fmt.Sprintf("RichTexts%+v", Alias(*r))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*RichTexts) TypeID() uint32 {
	return RichTextsTypeID
}

// TypeName returns name of type in TL schema.
func (*RichTexts) TypeName() string {
	return "richTexts"
}

// TypeInfo returns info about TL type.
func (r *RichTexts) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "richTexts",
		ID:   RichTextsTypeID,
	}
	if r == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Texts",
			SchemaName: "texts",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (r *RichTexts) Encode(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't encode richTexts#94b21889 as nil")
	}
	b.PutID(RichTextsTypeID)
	return r.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (r *RichTexts) EncodeBare(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't encode richTexts#94b21889 as nil")
	}
	b.PutInt(len(r.Texts))
	for idx, v := range r.Texts {
		if v == nil {
			return fmt.Errorf("unable to encode richTexts#94b21889: field texts element with index %d is nil", idx)
		}
		if err := v.EncodeBare(b); err != nil {
			return fmt.Errorf("unable to encode bare richTexts#94b21889: field texts element with index %d: %w", idx, err)
		}
	}
	return nil
}

// Decode implements bin.Decoder.
func (r *RichTexts) Decode(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't decode richTexts#94b21889 to nil")
	}
	if err := b.ConsumeID(RichTextsTypeID); err != nil {
		return fmt.Errorf("unable to decode richTexts#94b21889: %w", err)
	}
	return r.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (r *RichTexts) DecodeBare(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't decode richTexts#94b21889 to nil")
	}
	{
		headerLen, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode richTexts#94b21889: field texts: %w", err)
		}

		if headerLen > 0 {
			r.Texts = make([]RichTextClass, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := DecodeRichText(b)
			if err != nil {
				return fmt.Errorf("unable to decode richTexts#94b21889: field texts: %w", err)
			}
			r.Texts = append(r.Texts, value)
		}
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (r *RichTexts) EncodeTDLibJSON(b tdjson.Encoder) error {
	if r == nil {
		return fmt.Errorf("can't encode richTexts#94b21889 as nil")
	}
	b.ObjStart()
	b.PutID("richTexts")
	b.Comma()
	b.FieldStart("texts")
	b.ArrStart()
	for idx, v := range r.Texts {
		if v == nil {
			return fmt.Errorf("unable to encode richTexts#94b21889: field texts element with index %d is nil", idx)
		}
		if err := v.EncodeTDLibJSON(b); err != nil {
			return fmt.Errorf("unable to encode richTexts#94b21889: field texts element with index %d: %w", idx, err)
		}
		b.Comma()
	}
	b.StripComma()
	b.ArrEnd()
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (r *RichTexts) DecodeTDLibJSON(b tdjson.Decoder) error {
	if r == nil {
		return fmt.Errorf("can't decode richTexts#94b21889 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("richTexts"); err != nil {
				return fmt.Errorf("unable to decode richTexts#94b21889: %w", err)
			}
		case "texts":
			if err := b.Arr(func(b tdjson.Decoder) error {
				value, err := DecodeTDLibJSONRichText(b)
				if err != nil {
					return fmt.Errorf("unable to decode richTexts#94b21889: field texts: %w", err)
				}
				r.Texts = append(r.Texts, value)
				return nil
			}); err != nil {
				return fmt.Errorf("unable to decode richTexts#94b21889: field texts: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetTexts returns value of Texts field.
func (r *RichTexts) GetTexts() (value []RichTextClass) {
	if r == nil {
		return
	}
	return r.Texts
}

// RichTextClassName is schema name of RichTextClass.
const RichTextClassName = "RichText"

// RichTextClass represents RichText generic type.
//
// Example:
//
//	g, err := tdapi.DecodeRichText(buf)
//	if err != nil {
//	    panic(err)
//	}
//	switch v := g.(type) {
//	case *tdapi.RichTextPlain: // richTextPlain#1cc42966
//	case *tdapi.RichTextBold: // richTextBold#63970f6c
//	case *tdapi.RichTextItalic: // richTextItalic#6e77f03f
//	case *tdapi.RichTextUnderline: // richTextUnderline#e00cfd8c
//	case *tdapi.RichTextStrikethrough: // richTextStrikethrough#2b1e6a51
//	case *tdapi.RichTextFixed: // richTextFixed#b43681c7
//	case *tdapi.RichTextURL: // richTextUrl#500cf14
//	case *tdapi.RichTextEmailAddress: // richTextEmailAddress#262a2f7
//	case *tdapi.RichTextSubscript: // richTextSubscript#cc405a4c
//	case *tdapi.RichTextSuperscript: // richTextSuperscript#e9377563
//	case *tdapi.RichTextMarked: // richTextMarked#b42ed382
//	case *tdapi.RichTextPhoneNumber: // richTextPhoneNumber#7a91543
//	case *tdapi.RichTextIcon: // richTextIcon#a7c42b02
//	case *tdapi.RichTextReference: // richTextReference#bb9a1276
//	case *tdapi.RichTextAnchor: // richTextAnchor#4e7f1034
//	case *tdapi.RichTextAnchorLink: // richTextAnchorLink#a41fd2d6
//	case *tdapi.RichTexts: // richTexts#94b21889
//	default: panic(v)
//	}
type RichTextClass interface {
	bin.Encoder
	bin.Decoder
	bin.BareEncoder
	bin.BareDecoder
	construct() RichTextClass

	// TypeID returns type id in TL schema.
	//
	// See https://core.telegram.org/mtproto/TL-tl#remarks.
	TypeID() uint32
	// TypeName returns name of type in TL schema.
	TypeName() string
	// String implements fmt.Stringer.
	String() string
	// Zero returns true if current object has a zero value.
	Zero() bool

	EncodeTDLibJSON(b tdjson.Encoder) error
	DecodeTDLibJSON(b tdjson.Decoder) error
}

// DecodeRichText implements binary de-serialization for RichTextClass.
func DecodeRichText(buf *bin.Buffer) (RichTextClass, error) {
	id, err := buf.PeekID()
	if err != nil {
		return nil, err
	}
	switch id {
	case RichTextPlainTypeID:
		// Decoding richTextPlain#1cc42966.
		v := RichTextPlain{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode RichTextClass: %w", err)
		}
		return &v, nil
	case RichTextBoldTypeID:
		// Decoding richTextBold#63970f6c.
		v := RichTextBold{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode RichTextClass: %w", err)
		}
		return &v, nil
	case RichTextItalicTypeID:
		// Decoding richTextItalic#6e77f03f.
		v := RichTextItalic{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode RichTextClass: %w", err)
		}
		return &v, nil
	case RichTextUnderlineTypeID:
		// Decoding richTextUnderline#e00cfd8c.
		v := RichTextUnderline{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode RichTextClass: %w", err)
		}
		return &v, nil
	case RichTextStrikethroughTypeID:
		// Decoding richTextStrikethrough#2b1e6a51.
		v := RichTextStrikethrough{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode RichTextClass: %w", err)
		}
		return &v, nil
	case RichTextFixedTypeID:
		// Decoding richTextFixed#b43681c7.
		v := RichTextFixed{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode RichTextClass: %w", err)
		}
		return &v, nil
	case RichTextURLTypeID:
		// Decoding richTextUrl#500cf14.
		v := RichTextURL{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode RichTextClass: %w", err)
		}
		return &v, nil
	case RichTextEmailAddressTypeID:
		// Decoding richTextEmailAddress#262a2f7.
		v := RichTextEmailAddress{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode RichTextClass: %w", err)
		}
		return &v, nil
	case RichTextSubscriptTypeID:
		// Decoding richTextSubscript#cc405a4c.
		v := RichTextSubscript{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode RichTextClass: %w", err)
		}
		return &v, nil
	case RichTextSuperscriptTypeID:
		// Decoding richTextSuperscript#e9377563.
		v := RichTextSuperscript{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode RichTextClass: %w", err)
		}
		return &v, nil
	case RichTextMarkedTypeID:
		// Decoding richTextMarked#b42ed382.
		v := RichTextMarked{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode RichTextClass: %w", err)
		}
		return &v, nil
	case RichTextPhoneNumberTypeID:
		// Decoding richTextPhoneNumber#7a91543.
		v := RichTextPhoneNumber{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode RichTextClass: %w", err)
		}
		return &v, nil
	case RichTextIconTypeID:
		// Decoding richTextIcon#a7c42b02.
		v := RichTextIcon{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode RichTextClass: %w", err)
		}
		return &v, nil
	case RichTextReferenceTypeID:
		// Decoding richTextReference#bb9a1276.
		v := RichTextReference{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode RichTextClass: %w", err)
		}
		return &v, nil
	case RichTextAnchorTypeID:
		// Decoding richTextAnchor#4e7f1034.
		v := RichTextAnchor{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode RichTextClass: %w", err)
		}
		return &v, nil
	case RichTextAnchorLinkTypeID:
		// Decoding richTextAnchorLink#a41fd2d6.
		v := RichTextAnchorLink{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode RichTextClass: %w", err)
		}
		return &v, nil
	case RichTextsTypeID:
		// Decoding richTexts#94b21889.
		v := RichTexts{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode RichTextClass: %w", err)
		}
		return &v, nil
	default:
		return nil, fmt.Errorf("unable to decode RichTextClass: %w", bin.NewUnexpectedID(id))
	}
}

// DecodeTDLibJSONRichText implements binary de-serialization for RichTextClass.
func DecodeTDLibJSONRichText(buf tdjson.Decoder) (RichTextClass, error) {
	id, err := buf.FindTypeID()
	if err != nil {
		return nil, err
	}
	switch id {
	case "richTextPlain":
		// Decoding richTextPlain#1cc42966.
		v := RichTextPlain{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode RichTextClass: %w", err)
		}
		return &v, nil
	case "richTextBold":
		// Decoding richTextBold#63970f6c.
		v := RichTextBold{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode RichTextClass: %w", err)
		}
		return &v, nil
	case "richTextItalic":
		// Decoding richTextItalic#6e77f03f.
		v := RichTextItalic{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode RichTextClass: %w", err)
		}
		return &v, nil
	case "richTextUnderline":
		// Decoding richTextUnderline#e00cfd8c.
		v := RichTextUnderline{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode RichTextClass: %w", err)
		}
		return &v, nil
	case "richTextStrikethrough":
		// Decoding richTextStrikethrough#2b1e6a51.
		v := RichTextStrikethrough{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode RichTextClass: %w", err)
		}
		return &v, nil
	case "richTextFixed":
		// Decoding richTextFixed#b43681c7.
		v := RichTextFixed{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode RichTextClass: %w", err)
		}
		return &v, nil
	case "richTextUrl":
		// Decoding richTextUrl#500cf14.
		v := RichTextURL{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode RichTextClass: %w", err)
		}
		return &v, nil
	case "richTextEmailAddress":
		// Decoding richTextEmailAddress#262a2f7.
		v := RichTextEmailAddress{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode RichTextClass: %w", err)
		}
		return &v, nil
	case "richTextSubscript":
		// Decoding richTextSubscript#cc405a4c.
		v := RichTextSubscript{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode RichTextClass: %w", err)
		}
		return &v, nil
	case "richTextSuperscript":
		// Decoding richTextSuperscript#e9377563.
		v := RichTextSuperscript{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode RichTextClass: %w", err)
		}
		return &v, nil
	case "richTextMarked":
		// Decoding richTextMarked#b42ed382.
		v := RichTextMarked{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode RichTextClass: %w", err)
		}
		return &v, nil
	case "richTextPhoneNumber":
		// Decoding richTextPhoneNumber#7a91543.
		v := RichTextPhoneNumber{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode RichTextClass: %w", err)
		}
		return &v, nil
	case "richTextIcon":
		// Decoding richTextIcon#a7c42b02.
		v := RichTextIcon{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode RichTextClass: %w", err)
		}
		return &v, nil
	case "richTextReference":
		// Decoding richTextReference#bb9a1276.
		v := RichTextReference{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode RichTextClass: %w", err)
		}
		return &v, nil
	case "richTextAnchor":
		// Decoding richTextAnchor#4e7f1034.
		v := RichTextAnchor{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode RichTextClass: %w", err)
		}
		return &v, nil
	case "richTextAnchorLink":
		// Decoding richTextAnchorLink#a41fd2d6.
		v := RichTextAnchorLink{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode RichTextClass: %w", err)
		}
		return &v, nil
	case "richTexts":
		// Decoding richTexts#94b21889.
		v := RichTexts{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode RichTextClass: %w", err)
		}
		return &v, nil
	default:
		return nil, fmt.Errorf("unable to decode RichTextClass: %w", tdjson.NewUnexpectedID(id))
	}
}

// RichText boxes the RichTextClass providing a helper.
type RichTextBox struct {
	RichText RichTextClass
}

// Decode implements bin.Decoder for RichTextBox.
func (b *RichTextBox) Decode(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("unable to decode RichTextBox to nil")
	}
	v, err := DecodeRichText(buf)
	if err != nil {
		return fmt.Errorf("unable to decode boxed value: %w", err)
	}
	b.RichText = v
	return nil
}

// Encode implements bin.Encode for RichTextBox.
func (b *RichTextBox) Encode(buf *bin.Buffer) error {
	if b == nil || b.RichText == nil {
		return fmt.Errorf("unable to encode RichTextClass as nil")
	}
	return b.RichText.Encode(buf)
}

// DecodeTDLibJSON implements bin.Decoder for RichTextBox.
func (b *RichTextBox) DecodeTDLibJSON(buf tdjson.Decoder) error {
	if b == nil {
		return fmt.Errorf("unable to decode RichTextBox to nil")
	}
	v, err := DecodeTDLibJSONRichText(buf)
	if err != nil {
		return fmt.Errorf("unable to decode boxed value: %w", err)
	}
	b.RichText = v
	return nil
}

// EncodeTDLibJSON implements bin.Encode for RichTextBox.
func (b *RichTextBox) EncodeTDLibJSON(buf tdjson.Encoder) error {
	if b == nil || b.RichText == nil {
		return fmt.Errorf("unable to encode RichTextClass as nil")
	}
	return b.RichText.EncodeTDLibJSON(buf)
}
