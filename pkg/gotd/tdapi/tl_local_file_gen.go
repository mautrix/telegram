// Code generated by gotdgen, DO NOT EDIT.

package tdapi

import (
	"context"
	"errors"
	"fmt"
	"sort"
	"strings"

	"go.uber.org/multierr"

	"go.mau.fi/mautrix-telegram/pkg/gotd/bin"
	"go.mau.fi/mautrix-telegram/pkg/gotd/tdjson"
	"go.mau.fi/mautrix-telegram/pkg/gotd/tdp"
	"go.mau.fi/mautrix-telegram/pkg/gotd/tgerr"
)

// No-op definition for keeping imports.
var (
	_ = bin.Buffer{}
	_ = context.Background()
	_ = fmt.Stringer(nil)
	_ = strings.Builder{}
	_ = errors.Is
	_ = multierr.AppendInto
	_ = sort.Ints
	_ = tdp.Format
	_ = tgerr.Error{}
	_ = tdjson.Encoder{}
)

// LocalFile represents TL type `localFile#a2da9987`.
type LocalFile struct {
	// Local path to the locally available file part; may be empty
	Path string
	// True, if it is possible to download or generate the file
	CanBeDownloaded bool
	// True, if the file can be deleted
	CanBeDeleted bool
	// True, if the file is currently being downloaded (or a local copy is being generated by
	// some other means)
	IsDownloadingActive bool
	// True, if the local copy is fully available
	IsDownloadingCompleted bool
	// Download will be started from this offset. downloaded_prefix_size is calculated from
	// this offset
	DownloadOffset int64
	// If is_downloading_completed is false, then only some prefix of the file starting from
	// download_offset is ready to be read. downloaded_prefix_size is the size of that prefix
	// in bytes
	DownloadedPrefixSize int64
	// Total downloaded file size, in bytes. Can be used only for calculating download
	// progress. The actual file size may be bigger, and some parts of it may contain garbage
	DownloadedSize int64
}

// LocalFileTypeID is TL type id of LocalFile.
const LocalFileTypeID = 0xa2da9987

// Ensuring interfaces in compile-time for LocalFile.
var (
	_ bin.Encoder     = &LocalFile{}
	_ bin.Decoder     = &LocalFile{}
	_ bin.BareEncoder = &LocalFile{}
	_ bin.BareDecoder = &LocalFile{}
)

func (l *LocalFile) Zero() bool {
	if l == nil {
		return true
	}
	if !(l.Path == "") {
		return false
	}
	if !(l.CanBeDownloaded == false) {
		return false
	}
	if !(l.CanBeDeleted == false) {
		return false
	}
	if !(l.IsDownloadingActive == false) {
		return false
	}
	if !(l.IsDownloadingCompleted == false) {
		return false
	}
	if !(l.DownloadOffset == 0) {
		return false
	}
	if !(l.DownloadedPrefixSize == 0) {
		return false
	}
	if !(l.DownloadedSize == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (l *LocalFile) String() string {
	if l == nil {
		return "LocalFile(nil)"
	}
	type Alias LocalFile
	return fmt.Sprintf("LocalFile%+v", Alias(*l))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*LocalFile) TypeID() uint32 {
	return LocalFileTypeID
}

// TypeName returns name of type in TL schema.
func (*LocalFile) TypeName() string {
	return "localFile"
}

// TypeInfo returns info about TL type.
func (l *LocalFile) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "localFile",
		ID:   LocalFileTypeID,
	}
	if l == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Path",
			SchemaName: "path",
		},
		{
			Name:       "CanBeDownloaded",
			SchemaName: "can_be_downloaded",
		},
		{
			Name:       "CanBeDeleted",
			SchemaName: "can_be_deleted",
		},
		{
			Name:       "IsDownloadingActive",
			SchemaName: "is_downloading_active",
		},
		{
			Name:       "IsDownloadingCompleted",
			SchemaName: "is_downloading_completed",
		},
		{
			Name:       "DownloadOffset",
			SchemaName: "download_offset",
		},
		{
			Name:       "DownloadedPrefixSize",
			SchemaName: "downloaded_prefix_size",
		},
		{
			Name:       "DownloadedSize",
			SchemaName: "downloaded_size",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (l *LocalFile) Encode(b *bin.Buffer) error {
	if l == nil {
		return fmt.Errorf("can't encode localFile#a2da9987 as nil")
	}
	b.PutID(LocalFileTypeID)
	return l.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (l *LocalFile) EncodeBare(b *bin.Buffer) error {
	if l == nil {
		return fmt.Errorf("can't encode localFile#a2da9987 as nil")
	}
	b.PutString(l.Path)
	b.PutBool(l.CanBeDownloaded)
	b.PutBool(l.CanBeDeleted)
	b.PutBool(l.IsDownloadingActive)
	b.PutBool(l.IsDownloadingCompleted)
	b.PutInt53(l.DownloadOffset)
	b.PutInt53(l.DownloadedPrefixSize)
	b.PutInt53(l.DownloadedSize)
	return nil
}

// Decode implements bin.Decoder.
func (l *LocalFile) Decode(b *bin.Buffer) error {
	if l == nil {
		return fmt.Errorf("can't decode localFile#a2da9987 to nil")
	}
	if err := b.ConsumeID(LocalFileTypeID); err != nil {
		return fmt.Errorf("unable to decode localFile#a2da9987: %w", err)
	}
	return l.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (l *LocalFile) DecodeBare(b *bin.Buffer) error {
	if l == nil {
		return fmt.Errorf("can't decode localFile#a2da9987 to nil")
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode localFile#a2da9987: field path: %w", err)
		}
		l.Path = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode localFile#a2da9987: field can_be_downloaded: %w", err)
		}
		l.CanBeDownloaded = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode localFile#a2da9987: field can_be_deleted: %w", err)
		}
		l.CanBeDeleted = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode localFile#a2da9987: field is_downloading_active: %w", err)
		}
		l.IsDownloadingActive = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode localFile#a2da9987: field is_downloading_completed: %w", err)
		}
		l.IsDownloadingCompleted = value
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode localFile#a2da9987: field download_offset: %w", err)
		}
		l.DownloadOffset = value
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode localFile#a2da9987: field downloaded_prefix_size: %w", err)
		}
		l.DownloadedPrefixSize = value
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode localFile#a2da9987: field downloaded_size: %w", err)
		}
		l.DownloadedSize = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (l *LocalFile) EncodeTDLibJSON(b tdjson.Encoder) error {
	if l == nil {
		return fmt.Errorf("can't encode localFile#a2da9987 as nil")
	}
	b.ObjStart()
	b.PutID("localFile")
	b.Comma()
	b.FieldStart("path")
	b.PutString(l.Path)
	b.Comma()
	b.FieldStart("can_be_downloaded")
	b.PutBool(l.CanBeDownloaded)
	b.Comma()
	b.FieldStart("can_be_deleted")
	b.PutBool(l.CanBeDeleted)
	b.Comma()
	b.FieldStart("is_downloading_active")
	b.PutBool(l.IsDownloadingActive)
	b.Comma()
	b.FieldStart("is_downloading_completed")
	b.PutBool(l.IsDownloadingCompleted)
	b.Comma()
	b.FieldStart("download_offset")
	b.PutInt53(l.DownloadOffset)
	b.Comma()
	b.FieldStart("downloaded_prefix_size")
	b.PutInt53(l.DownloadedPrefixSize)
	b.Comma()
	b.FieldStart("downloaded_size")
	b.PutInt53(l.DownloadedSize)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (l *LocalFile) DecodeTDLibJSON(b tdjson.Decoder) error {
	if l == nil {
		return fmt.Errorf("can't decode localFile#a2da9987 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("localFile"); err != nil {
				return fmt.Errorf("unable to decode localFile#a2da9987: %w", err)
			}
		case "path":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode localFile#a2da9987: field path: %w", err)
			}
			l.Path = value
		case "can_be_downloaded":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode localFile#a2da9987: field can_be_downloaded: %w", err)
			}
			l.CanBeDownloaded = value
		case "can_be_deleted":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode localFile#a2da9987: field can_be_deleted: %w", err)
			}
			l.CanBeDeleted = value
		case "is_downloading_active":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode localFile#a2da9987: field is_downloading_active: %w", err)
			}
			l.IsDownloadingActive = value
		case "is_downloading_completed":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode localFile#a2da9987: field is_downloading_completed: %w", err)
			}
			l.IsDownloadingCompleted = value
		case "download_offset":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode localFile#a2da9987: field download_offset: %w", err)
			}
			l.DownloadOffset = value
		case "downloaded_prefix_size":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode localFile#a2da9987: field downloaded_prefix_size: %w", err)
			}
			l.DownloadedPrefixSize = value
		case "downloaded_size":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode localFile#a2da9987: field downloaded_size: %w", err)
			}
			l.DownloadedSize = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetPath returns value of Path field.
func (l *LocalFile) GetPath() (value string) {
	if l == nil {
		return
	}
	return l.Path
}

// GetCanBeDownloaded returns value of CanBeDownloaded field.
func (l *LocalFile) GetCanBeDownloaded() (value bool) {
	if l == nil {
		return
	}
	return l.CanBeDownloaded
}

// GetCanBeDeleted returns value of CanBeDeleted field.
func (l *LocalFile) GetCanBeDeleted() (value bool) {
	if l == nil {
		return
	}
	return l.CanBeDeleted
}

// GetIsDownloadingActive returns value of IsDownloadingActive field.
func (l *LocalFile) GetIsDownloadingActive() (value bool) {
	if l == nil {
		return
	}
	return l.IsDownloadingActive
}

// GetIsDownloadingCompleted returns value of IsDownloadingCompleted field.
func (l *LocalFile) GetIsDownloadingCompleted() (value bool) {
	if l == nil {
		return
	}
	return l.IsDownloadingCompleted
}

// GetDownloadOffset returns value of DownloadOffset field.
func (l *LocalFile) GetDownloadOffset() (value int64) {
	if l == nil {
		return
	}
	return l.DownloadOffset
}

// GetDownloadedPrefixSize returns value of DownloadedPrefixSize field.
func (l *LocalFile) GetDownloadedPrefixSize() (value int64) {
	if l == nil {
		return
	}
	return l.DownloadedPrefixSize
}

// GetDownloadedSize returns value of DownloadedSize field.
func (l *LocalFile) GetDownloadedSize() (value int64) {
	if l == nil {
		return
	}
	return l.DownloadedSize
}
